// This file was originally generated by the Gtk# (gapi3) code generator.
// It is now maintained by hand.

namespace GI
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;

#region Autogenerated code
    public partial class Typelib : GLib.Opaque
    {

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_typelib_get_namespace (IntPtr raw);

        public string Namespace {
            get {
                IntPtr raw_ret = g_typelib_get_namespace (Handle);
                string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_typelib_symbol (IntPtr raw, IntPtr symbol_name, IntPtr symbol);

        public bool Symbol (string symbol_name, IntPtr symbol)
        {
            IntPtr native_symbol_name = GLib.Marshaller.StringToPtrGStrdup (symbol_name);
            bool raw_ret = g_typelib_symbol (Handle, native_symbol_name, symbol);
            bool ret = raw_ret;
            GLib.Marshaller.Free (native_symbol_name);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_typelib_error_quark ();

        public static int ErrorDomain {
            get {
                int raw_ret = g_typelib_error_quark ();
                int ret = raw_ret;
                return ret;
            }
        }

        public Typelib (IntPtr raw) : base (raw)
        {
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_typelib_new_from_const_memory (byte[] memory, UIntPtr n_memory, out IntPtr error);

        public static unsafe Typelib NewFromConstMemory (byte[] memory)
        {
            IntPtr error = IntPtr.Zero;
            Typelib result = new Typelib (g_typelib_new_from_const_memory (memory, new UIntPtr ((ulong)(memory == null ? 0 : memory.Length)), out error));
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
            return result;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_typelib_new_from_mapped_file (IntPtr mfile, out IntPtr error);

        public unsafe Typelib (GI.MappedFile mfile)
        {
            IntPtr error = IntPtr.Zero;
            Raw = g_typelib_new_from_mapped_file (mfile == null ? IntPtr.Zero : mfile.Handle, out error);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_typelib_new_from_memory (byte[] memory, UIntPtr n_memory, out IntPtr error);

        public unsafe Typelib (byte[] memory)
        {
            IntPtr error = IntPtr.Zero;
            Raw = g_typelib_new_from_memory (memory, new UIntPtr ((ulong)(memory == null ? 0 : memory.Length)), out error);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_typelib_free (IntPtr raw);

        protected override void Free (IntPtr raw)
        {
            g_typelib_free (raw);
        }

        class FinalizerInfo
        {
            IntPtr handle;

            public FinalizerInfo (IntPtr handle)
            {
                this.handle = handle;
            }

            public bool Handler ()
            {
                g_typelib_free (handle);
                return false;
            }
        }

        ~Typelib ()
        {
            if (!Owned)
                return;
            FinalizerInfo info = new FinalizerInfo (Handle);
            GLib.Timeout.Add (50, new GLib.TimeoutHandler (info.Handler));
        }

#endregion
    }
}

// This file was originally generated by the Gtk# (gapi3) code generator.
// It is now maintained by hand.

namespace GI
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;

#region Autogenerated code
    public partial class MappedFile : GLib.Opaque
    {

        public byte[] Bytes {
            get {
                var bytes = new byte[Length];
                Marshal.Copy (Contents, bytes, 0, (int)Length);
                return bytes;
            }
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern UIntPtr g_mapped_file_get_length (IntPtr raw);

        public ulong Length {
            get {
                UIntPtr raw_ret = g_mapped_file_get_length (Handle);
                ulong ret = (ulong)raw_ret;
                return ret;
            }
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_mapped_file_get_contents (IntPtr raw);

        protected IntPtr Contents {
            get {
                IntPtr raw_ret = g_mapped_file_get_contents (Handle);
                IntPtr ret = raw_ret;
                return ret;
            }
        }

        public MappedFile (IntPtr raw) : base (raw)
        {
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_mapped_file_new (IntPtr filename, bool writable, out IntPtr error);

        public unsafe MappedFile (string filename, bool writable)
        {
            IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
            IntPtr error = IntPtr.Zero;
            Raw = g_mapped_file_new (native_filename, writable, out error);
            GLib.Marshaller.Free (native_filename);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_mapped_file_new_from_fd (int fd, bool writable, out IntPtr error);

        public unsafe MappedFile (int fd, bool writable)
        {
            IntPtr error = IntPtr.Zero;
            Raw = g_mapped_file_new_from_fd (fd, writable, out error);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_mapped_file_ref (IntPtr raw);

        protected override void Ref (IntPtr raw)
        {
            if (!Owned) {
                g_mapped_file_ref (raw);
                Owned = true;
            }
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_mapped_file_unref (IntPtr raw);

        protected override void Unref (IntPtr raw)
        {
            if (Owned) {
                g_mapped_file_unref (raw);
                Owned = false;
            }
        }

        [DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_mapped_file_free (IntPtr raw);

        protected override void Free (IntPtr raw)
        {
            g_mapped_file_free (raw);
        }

        class FinalizerInfo
        {
            IntPtr handle;

            public FinalizerInfo (IntPtr handle)
            {
                this.handle = handle;
            }

            public bool Handler ()
            {
                g_mapped_file_free (handle);
                return false;
            }
        }

        ~MappedFile ()
        {
            if (!Owned)
                return;
            FinalizerInfo info = new FinalizerInfo (Handle);
            GLib.Timeout.Add (50, new GLib.TimeoutHandler (info.Handler));
        }

#endregion
    }
}

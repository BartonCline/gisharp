// This file was originally generated by the Gtk# (gapi3) code generator.
// It is now maintained by hand.

namespace GI
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;

#region Autogenerated code
    public partial class Repository : GLib.Object
    {

        public const string BuiltIn = "<builtin>";

        NamespaceCollection namespaces;

        internal InfoCollection<BaseInfo> GetInfos (string @namespace)
        {
            return new InfoCollection<BaseInfo> (() => GetNInfos (@namespace), (i) => GetInfo (@namespace, i));
        }

        public NamespaceCollection Namespaces {
            get {
                if (namespaces == null)
                    namespaces = new NamespaceCollection (this);
                return namespaces;
            }
        }

        public Repository (IntPtr raw) : base (raw)
        {
        }

        protected Repository () : base (IntPtr.Zero)
        {
            CreateNativeObject (new string [0], new GLib.Value [0]);
        }

        [StructLayout (LayoutKind.Sequential)]
        struct GIRepositoryClass
        {
        }

        static uint class_offset = ((GLib.GType)typeof(GLib.Object)).GetClassSize ();
        static Dictionary<GLib.GType, GIRepositoryClass> class_structs;

        static GIRepositoryClass GetClassStruct (GLib.GType gtype, bool use_cache)
        {
            if (class_structs == null)
                class_structs = new Dictionary<GLib.GType, GIRepositoryClass> ();

            if (use_cache && class_structs.ContainsKey (gtype))
                return class_structs [gtype];
            else {
                IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
                GIRepositoryClass class_struct = (GIRepositoryClass)Marshal.PtrToStructure (class_ptr, typeof(GIRepositoryClass));
                if (use_cache)
                    class_structs.Add (gtype, class_struct);
                return class_struct;
            }
        }

        static void OverrideClassStruct (GLib.GType gtype, GIRepositoryClass class_struct)
        {
            IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
            Marshal.StructureToPtr (class_struct, class_ptr, false);
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe bool g_irepository_dump (IntPtr arg, out IntPtr error);

        public static unsafe bool Dump (string arg)
        {
            IntPtr native_arg = GLib.Marshaller.StringToPtrGStrdup (arg);
            IntPtr error = IntPtr.Zero;
            bool raw_ret = g_irepository_dump (native_arg, out error);
            bool ret = raw_ret;
            GLib.Marshaller.Free (native_arg);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_enumerate_versions (IntPtr raw, IntPtr namespace_);

        internal string[] GetVersions (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_enumerate_versions (Handle, native_namespace_);
            string[] ret = (string[])GLib.Marshaller.ListPtrToArray (raw_ret, typeof(GLib.List), false, false, typeof(string));
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_irepository_error_quark ();

        public static int ErrorDomain {
            get {
                int raw_ret = g_irepository_error_quark ();
                int ret = raw_ret;
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_find_by_error_domain (IntPtr raw, int domain);

        public GI.EnumInfo FindByErrorDomain (int domain)
        {
            IntPtr raw_ret = g_irepository_find_by_error_domain (Handle, domain);
            GI.EnumInfo ret = raw_ret == IntPtr.Zero ? null : (GI.EnumInfo)GLib.Opaque.GetOpaque (raw_ret, typeof(GI.EnumInfo), false);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_find_by_gtype (IntPtr raw, IntPtr gtype);

        public GI.BaseInfo FindByGType (GLib.GType gtype)
        {
            IntPtr raw_ret = g_irepository_find_by_gtype (Handle, gtype.Val);
            GI.BaseInfo ret = GI.BaseInfo.MarshalPtr (raw_ret);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_find_by_name (IntPtr raw, IntPtr namespace_, IntPtr name);

        internal GI.BaseInfo FindByName (string namespace_, string name)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
            IntPtr raw_ret = g_irepository_find_by_name (Handle, native_namespace_, native_name);
            GI.BaseInfo ret = GI.BaseInfo.MarshalPtr (raw_ret);
            GLib.Marshaller.Free (native_namespace_);
            GLib.Marshaller.Free (native_name);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_c_prefix (IntPtr raw, IntPtr namespace_);

        internal string GetCPrefix (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_get_c_prefix (Handle, native_namespace_);
            string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_default ();

        public static GI.Repository Default {
            get {
                IntPtr raw_ret = g_irepository_get_default ();
                GI.Repository ret = GLib.Object.GetObject (raw_ret) as GI.Repository;
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_dependencies (IntPtr raw, IntPtr namespace_);

        internal string[] GetDependencies (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_get_dependencies (Handle, native_namespace_);
            string[] ret = GLib.Marshaller.NullTermPtrToStringArray (raw_ret, false);
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_info (IntPtr raw, IntPtr namespace_, int index);

        internal GI.BaseInfo GetInfo (string namespace_, int index)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_get_info (Handle, native_namespace_, index);
            GI.BaseInfo ret = GI.BaseInfo.MarshalPtr (raw_ret);
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_loaded_namespaces (IntPtr raw);

        public string[] LoadedNamespaces {
            get {
                IntPtr raw_ret = g_irepository_get_loaded_namespaces (Handle);
                string[] ret = GLib.Marshaller.NullTermPtrToStringArray (raw_ret, false);
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_irepository_get_n_infos (IntPtr raw, IntPtr namespace_);

        protected int GetNInfos (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            int raw_ret = g_irepository_get_n_infos (Handle, native_namespace_);
            int ret = raw_ret;
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_option_group ();

        public static GI.OptionGroup OptionGroup {
            get {
                IntPtr raw_ret = g_irepository_get_option_group ();
                GI.OptionGroup ret = raw_ret == IntPtr.Zero ? null : (GI.OptionGroup)GLib.Opaque.GetOpaque (raw_ret, typeof(GI.OptionGroup), false);
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_search_path ();

        public static string[] SearchPath {
            get {
                IntPtr raw_ret = g_irepository_get_search_path ();
                string[] ret = (string[])GLib.Marshaller.ListPtrToArray (raw_ret, typeof(GLib.SList), false, false, typeof(string));
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_shared_library (IntPtr raw, IntPtr namespace_);

        internal string GetSharedLibrary (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_get_shared_library (Handle, native_namespace_);
            string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_type ();

        public static new GLib.GType GType {
            get {
                IntPtr raw_ret = g_irepository_get_type ();
                GLib.GType ret = new GLib.GType (raw_ret);
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_typelib_path (IntPtr raw, IntPtr namespace_);

        internal string GetTypelibPath (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_get_typelib_path (Handle, native_namespace_);
            string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_irepository_get_version (IntPtr raw, IntPtr namespace_);

        internal string GetVersion (string namespace_)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr raw_ret = g_irepository_get_version (Handle, native_namespace_);
            string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
            GLib.Marshaller.Free (native_namespace_);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_irepository_is_registered (IntPtr raw, IntPtr namespace_, IntPtr version);

        public bool IsRegistered (string namespace_, string version)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr native_version = GLib.Marshaller.StringToPtrGStrdup (version);
            bool raw_ret = g_irepository_is_registered (Handle, native_namespace_, native_version);
            bool ret = raw_ret;
            GLib.Marshaller.Free (native_namespace_);
            GLib.Marshaller.Free (native_version);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_irepository_load_typelib (IntPtr raw, IntPtr typelib, int flags, out IntPtr error);

        public unsafe string LoadTypelib (GI.Typelib typelib, GI.RepositoryLoadFlags flags)
        {
            IntPtr error = IntPtr.Zero;
            IntPtr raw_ret = g_irepository_load_typelib (Handle, typelib == null ? IntPtr.Zero : typelib.Handle, (int)flags, out error);
            string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_irepository_prepend_library_path (IntPtr directory);

        public static void PrependLibraryPath (string directory)
        {
            IntPtr native_directory = GLib.Marshaller.StringToPtrGStrdup (directory);
            g_irepository_prepend_library_path (native_directory);
            GLib.Marshaller.Free (native_directory);
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_irepository_prepend_search_path (IntPtr directory);

        public static void PrependSearchPath (string directory)
        {
            IntPtr native_directory = GLib.Marshaller.StringToPtrGStrdup (directory);
            g_irepository_prepend_search_path (native_directory);
            GLib.Marshaller.Free (native_directory);
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_irepository_require (IntPtr raw, IntPtr namespace_, IntPtr version, int flags, out IntPtr error);

        public unsafe GI.Typelib Require (string namespace_, string version, GI.RepositoryLoadFlags flags)
        {
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr native_version = GLib.Marshaller.StringToPtrGStrdup (version);
            IntPtr error = IntPtr.Zero;
            IntPtr raw_ret = g_irepository_require (Handle, native_namespace_, native_version, (int)flags, out error);
            GI.Typelib ret = raw_ret == IntPtr.Zero ? null : (GI.Typelib)GLib.Opaque.GetOpaque (raw_ret, typeof(GI.Typelib), false);
            GLib.Marshaller.Free (native_namespace_);
            GLib.Marshaller.Free (native_version);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
            return ret;
        }

        [DllImport ("libgirepository-1.0.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr g_irepository_require_private (IntPtr raw, IntPtr typelib_dir, IntPtr namespace_, IntPtr version, int flags, out IntPtr error);

        public unsafe GI.Typelib RequirePrivate (string typelib_dir, string namespace_, string version, GI.RepositoryLoadFlags flags)
        {
            IntPtr native_typelib_dir = GLib.Marshaller.StringToPtrGStrdup (typelib_dir);
            IntPtr native_namespace_ = GLib.Marshaller.StringToPtrGStrdup (namespace_);
            IntPtr native_version = GLib.Marshaller.StringToPtrGStrdup (version);
            IntPtr error = IntPtr.Zero;
            IntPtr raw_ret = g_irepository_require_private (Handle, native_typelib_dir, native_namespace_, native_version, (int)flags, out error);
            GI.Typelib ret = raw_ret == IntPtr.Zero ? null : (GI.Typelib)GLib.Opaque.GetOpaque (raw_ret, typeof(GI.Typelib), false);
            GLib.Marshaller.Free (native_typelib_dir);
            GLib.Marshaller.Free (native_namespace_);
            GLib.Marshaller.Free (native_version);
            if (error != IntPtr.Zero)
                throw new GLib.GException (error);
            return ret;
        }


        static Repository ()
        {
            GtkSharp.GiSharp.ObjectManager.Initialize ();
        }

#endregion
    }
}

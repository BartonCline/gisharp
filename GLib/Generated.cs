namespace GISharp.GLib
{
    /// <summary>
    /// Integer representing a day of the month; between 1 and 31.
    /// #G_DATE_BAD_DAY represents an invalid day of the month.
    /// </summary>
    [GISharp.Core.GirXml("<alias name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Integer representing a day of the month; between 1 and 31.\n#G_DATE_BAD_DAY represents an invalid day of the month.</doc>\n  <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n  <field name=\"value\" gs:access-modifier=\"private\" gs:managed-name=\"value\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n    <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n  </field>\n</alias>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct DateDay
    {
        System.Byte value;
    }

    /// <summary>
    /// Integer representing a year; #G_DATE_BAD_YEAR is the invalid
    /// value. The year must be 1 or higher; negative (BC) years are not
    /// allowed. The year is represented with four digits.
    /// </summary>
    [GISharp.Core.GirXml("<alias name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Integer representing a year; #G_DATE_BAD_YEAR is the invalid\nvalue. The year must be 1 or higher; negative (BC) years are not\nallowed. The year is represented with four digits.</doc>\n  <type name=\"guint16\" c:type=\"guint16\" gs:managed-name=\"Guint16\" />\n  <field name=\"value\" gs:access-modifier=\"private\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n    <type name=\"guint16\" c:type=\"guint16\" gs:managed-name=\"Guint16\" />\n  </field>\n</alias>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct DateYear
    {
        System.UInt16 value;
    }

    /// <summary>
    /// A GQuark is a non-zero integer which uniquely identifies a
    /// particular string. A GQuark value of zero is associated to %NULL.
    /// </summary>
    [GISharp.Core.GirXml("<alias name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A GQuark is a non-zero integer which uniquely identifies a\nparticular string. A GQuark value of zero is associated to %NULL.</doc>\n  <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n  <function name=\"from_string\" c:identifier=\"g_quark_from_string\" gs:managed-name=\"FromString\">\n    <doc xml:space=\"preserve\">Gets the #GQuark identifying the given string. If the string does\nnot currently have an associated #GQuark, a new #GQuark is created,\nusing a copy of the string.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">the #GQuark identifying the string, or 0 if @string is %NULL</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <method name=\"to_string\" c:identifier=\"g_quark_to_string\" gs:managed-name=\"ToString\" gs:special-func=\"to-string\">\n    <doc xml:space=\"preserve\">Gets the string associated with the given #GQuark.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the string associated with the #GQuark</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters />\n    <instance-parameter name=\"quark\" transfer-ownership=\"none\" gs:managed-name=\"quark\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">a #GQuark.</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </instance-parameter>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"try_string\" c:identifier=\"g_quark_try_string\" gs:managed-name=\"TryString\">\n    <doc xml:space=\"preserve\">Gets the #GQuark associated with the given string, or 0 if string is\n%NULL or it has no associated #GQuark.\n\nIf you want the GQuark to be created if it doesn't already exist,\nuse g_quark_from_string() or g_quark_from_static_string().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">the #GQuark associated with the string, or 0 if @string is\n    %NULL or there is no #GQuark associated with it</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"intern_string\" c:identifier=\"g_intern_string\" version=\"2.10\" gs:managed-name=\"InternString\">\n    <doc xml:space=\"preserve\">Returns a canonical representation for @string. Interned strings\ncan be compared for equality by comparing the pointers, instead of\nusing strcmp().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a canonical representation for the string</doc>\n      <type name=\"gpointer\" c:type=\"const gchar*\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <field name=\"value\" gs:access-modifier=\"private\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n    <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n  </field>\n</alias>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Quark
    {
        System.UInt32 value;

        /// <summary>
        /// Gets the #GQuark identifying the given string. If the string does
        /// not currently have an associated #GQuark, a new #GQuark is created,
        /// using a copy of the string.
        /// </summary>
        /// <param name="string">
        /// a string
        /// </param>
        /// <returns>
        /// the #GQuark identifying the string, or 0 if @string is %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.Quark g_quark_from_string(
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Gets the #GQuark identifying the given string. If the string does
        /// not currently have an associated #GQuark, a new #GQuark is created,
        /// using a copy of the string.
        /// </summary>
        /// <param name="string">
        /// a string
        /// </param>
        /// <returns>
        /// the #GQuark identifying the string, or 0 if @string is %NULL
        /// </returns>
        public static GISharp.GLib.Quark FromString(
            System.String @string)
        {
            return default(GISharp.GLib.Quark);
        }

        /// <summary>
        /// Gets the #GQuark associated with the given string, or 0 if string is
        /// %NULL or it has no associated #GQuark.
        /// </summary>
        /// <remarks>
        /// If you want the GQuark to be created if it doesn't already exist,
        /// use g_quark_from_string() or g_quark_from_static_string().
        /// </remarks>
        /// <param name="string">
        /// a string
        /// </param>
        /// <returns>
        /// the #GQuark associated with the string, or 0 if @string is
        ///     %NULL or there is no #GQuark associated with it
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.Quark g_quark_try_string(
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Gets the #GQuark associated with the given string, or 0 if string is
        /// %NULL or it has no associated #GQuark.
        /// </summary>
        /// <remarks>
        /// If you want the GQuark to be created if it doesn't already exist,
        /// use g_quark_from_string() or g_quark_from_static_string().
        /// </remarks>
        /// <param name="string">
        /// a string
        /// </param>
        /// <returns>
        /// the #GQuark associated with the string, or 0 if @string is
        ///     %NULL or there is no #GQuark associated with it
        /// </returns>
        public static GISharp.GLib.Quark TryString(
            System.String @string)
        {
            return default(GISharp.GLib.Quark);
        }

        /// <summary>
        /// Returns a canonical representation for @string. Interned strings
        /// can be compared for equality by comparing the pointers, instead of
        /// using strcmp().
        /// </summary>
        /// <param name="string">
        /// a string
        /// </param>
        /// <returns>
        /// a canonical representation for the string
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.10")]
        static extern System.IntPtr g_intern_string(
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Returns a canonical representation for @string. Interned strings
        /// can be compared for equality by comparing the pointers, instead of
        /// using strcmp().
        /// </summary>
        /// <param name="string">
        /// a string
        /// </param>
        /// <returns>
        /// a canonical representation for the string
        /// </returns>
        [GISharp.Core.Since("2.10")]
        public static System.IntPtr InternString(
            System.String @string)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Gets the string associated with the given #GQuark.
        /// </summary>
        /// <returns>
        /// the string associated with the #GQuark
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_quark_to_string();

        /// <summary>
        /// Gets the string associated with the given #GQuark.
        /// </summary>
        /// <returns>
        /// the string associated with the #GQuark
        /// </returns>
        public override System.String ToString()
        {
            return default(System.String);
        }
    }

    /// <summary>
    /// A C representable type name for #G_TYPE_STRV.
    /// </summary>
    [GISharp.Core.GirXml("<alias name=\"Strv\" c:type=\"GStrv\" gs:managed-name=\"Strv\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A C representable type name for #G_TYPE_STRV.</doc>\n  <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  <field name=\"value\" gs:access-modifier=\"private\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </field>\n</alias>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Strv
    {
        System.IntPtr value;
    }

    /// <summary>
    /// A value representing an interval of time, in microseconds.
    /// </summary>
    [GISharp.Core.GirXml("<alias name=\"TimeSpan\" c:type=\"GTimeSpan\" gs:managed-name=\"TimeSpan\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A value representing an interval of time, in microseconds.</doc>\n  <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  <constant name=\"DAY\" value=\"86400000000\" c:type=\"G_TIME_SPAN_DAY\" version=\"2.26\" gs:managed-name=\"Day\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">Evaluates to a time span of one day.</doc>\n    <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  </constant>\n  <constant name=\"HOUR\" value=\"3600000000\" c:type=\"G_TIME_SPAN_HOUR\" version=\"2.26\" gs:managed-name=\"Hour\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">Evaluates to a time span of one hour.</doc>\n    <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  </constant>\n  <constant name=\"MILLISECOND\" value=\"1000\" c:type=\"G_TIME_SPAN_MILLISECOND\" version=\"2.26\" gs:managed-name=\"Millisecond\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">Evaluates to a time span of one millisecond.</doc>\n    <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  </constant>\n  <constant name=\"MINUTE\" value=\"60000000\" c:type=\"G_TIME_SPAN_MINUTE\" version=\"2.26\" gs:managed-name=\"Minute\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">Evaluates to a time span of one minute.</doc>\n    <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  </constant>\n  <constant name=\"SECOND\" value=\"1000000\" c:type=\"G_TIME_SPAN_SECOND\" version=\"2.26\" gs:managed-name=\"Second\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">Evaluates to a time span of one second.</doc>\n    <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  </constant>\n  <field name=\"value\" gs:access-modifier=\"private\" gs:managed-name=\"value\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n  </field>\n</alias>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TimeSpan
    {
        /// <summary>
        /// Evaluates to a time span of one day.
        /// </summary>
        [GISharp.Core.Since("2.26")]
        public const System.Int64 Day = 86400000000L;

        /// <summary>
        /// Evaluates to a time span of one hour.
        /// </summary>
        [GISharp.Core.Since("2.26")]
        public const System.Int64 Hour = 3600000000L;

        /// <summary>
        /// Evaluates to a time span of one millisecond.
        /// </summary>
        [GISharp.Core.Since("2.26")]
        public const System.Int64 Millisecond = 1000L;

        /// <summary>
        /// Evaluates to a time span of one minute.
        /// </summary>
        [GISharp.Core.Since("2.26")]
        public const System.Int64 Minute = 60000000L;

        /// <summary>
        /// Evaluates to a time span of one second.
        /// </summary>
        [GISharp.Core.Since("2.26")]
        public const System.Int64 Second = 1000000L;
        System.Int64 value;
    }

    /// <summary>
    /// Contains the public fields of a GByteArray.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"ByteArray\" c:type=\"GByteArray\" glib:type-name=\"GByteArray\" glib:get-type=\"g_byte_array_get_type\" c:symbol-prefix=\"byte_array\" gs:managed-name=\"ByteArray\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Contains the public fields of a GByteArray.</doc>\n  <method name=\"append\" c:identifier=\"g_byte_array_append\" introspectable=\"0\" gs:managed-name=\"Append\">\n    <doc xml:space=\"preserve\">Adds the given bytes to the end of the #GByteArray.\nThe array will grow in size automatically if necessary.</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <doc xml:space=\"preserve\">the byte data to be added</doc>\n        <type name=\"guint8\" c:type=\"const guint8*\" gs:managed-name=\"Guint8\" />\n      </parameter>\n      <parameter name=\"len\" transfer-ownership=\"none\" gs:managed-name=\"len\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of bytes to add</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <doc xml:space=\"preserve\">the byte data to be added</doc>\n        <type name=\"guint8\" c:type=\"const guint8*\" gs:managed-name=\"Guint8\" />\n      </parameter>\n      <parameter name=\"len\" transfer-ownership=\"none\" gs:managed-name=\"len\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of bytes to add</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free\" c:identifier=\"g_byte_array_free\" gs:managed-name=\"Free\">\n    <doc xml:space=\"preserve\">Frees the memory allocated by the #GByteArray. If @free_segment is\n%TRUE it frees the actual byte data. If the reference count of\n@array is greater than one, the #GByteArray wrapper is preserved but\nthe size of @array will be set to zero.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n      <doc xml:space=\"preserve\">the element data if @free_segment is %FALSE, otherwise\n         %NULL.  The element data should be freed using g_free().</doc>\n      <type name=\"guint8\" c:type=\"guint8*\" gs:managed-name=\"Guint8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"free_segment\" transfer-ownership=\"none\" gs:managed-name=\"freeSegment\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">if %TRUE the actual byte data is freed as well</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"free_segment\" transfer-ownership=\"none\" gs:managed-name=\"freeSegment\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">if %TRUE the actual byte data is freed as well</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free_to_bytes\" c:identifier=\"g_byte_array_free_to_bytes\" version=\"2.32\" gs:managed-name=\"FreeToBytes\">\n    <doc xml:space=\"preserve\">Transfers the data from the #GByteArray into a new immutable #GBytes.\n\nThe #GByteArray is freed unless the reference count of @array is greater\nthan one, the #GByteArray wrapper is preserved but the size of @array\nwill be set to zero.\n\nThis is identical to using g_bytes_new_take() and g_byte_array_free()\ntogether.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new immutable #GBytes representing same\n    byte data that was in the array</doc>\n      <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"full\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <constructor name=\"new\" c:identifier=\"g_byte_array_new\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GByteArray with a reference count of 1.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n  </constructor>\n  <constructor name=\"new_take\" c:identifier=\"g_byte_array_new_take\" version=\"2.32\" gs:managed-name=\"NewTake\">\n    <doc xml:space=\"preserve\">Create byte array containing the data. The data will be owned by the array\nand will be freed with g_free(), i.e. it could be allocated using g_strdup().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <parameter name=\"data\" transfer-ownership=\"full\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">byte data for the array</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"guint8*\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n      <parameter name=\"len\" transfer-ownership=\"none\" gs:managed-name=\"len\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">length of @data</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"full\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">byte data for the array</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"guint8*\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"prepend\" c:identifier=\"g_byte_array_prepend\" introspectable=\"0\" gs:managed-name=\"Prepend\">\n    <doc xml:space=\"preserve\">Adds the given data to the start of the #GByteArray.\nThe array will grow in size automatically if necessary.</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <doc xml:space=\"preserve\">the byte data to be added</doc>\n        <type name=\"guint8\" c:type=\"const guint8*\" gs:managed-name=\"Guint8\" />\n      </parameter>\n      <parameter name=\"len\" transfer-ownership=\"none\" gs:managed-name=\"len\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of bytes to add</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <doc xml:space=\"preserve\">the byte data to be added</doc>\n        <type name=\"guint8\" c:type=\"const guint8*\" gs:managed-name=\"Guint8\" />\n      </parameter>\n      <parameter name=\"len\" transfer-ownership=\"none\" gs:managed-name=\"len\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of bytes to add</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_byte_array_ref\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Atomically increments the reference count of @array by one.\nThis function is thread-safe and may be called from any thread.</doc>\n    <return-value skip=\"1\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">The passed in #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove_index\" c:identifier=\"g_byte_array_remove_index\" introspectable=\"0\" gs:managed-name=\"RemoveIndex\">\n    <doc xml:space=\"preserve\">Removes the byte at the given index from a #GByteArray.\nThe following bytes are moved down one place.</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the byte to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the byte to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_index_fast\" c:identifier=\"g_byte_array_remove_index_fast\" introspectable=\"0\" gs:managed-name=\"RemoveIndexFast\">\n    <doc xml:space=\"preserve\">Removes the byte at the given index from a #GByteArray. The last\nelement in the array is used to fill in the space, so this function\ndoes not preserve the order of the #GByteArray. But it is faster\nthan g_byte_array_remove_index().</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the byte to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the byte to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_range\" c:identifier=\"g_byte_array_remove_range\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"RemoveRange\">\n    <doc xml:space=\"preserve\">Removes the given number of bytes starting at the given index from a\n#GByteArray.  The following elements are moved to close the gap.</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a @GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the first byte to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of bytes to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the first byte to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of bytes to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_size\" c:identifier=\"g_byte_array_set_size\" introspectable=\"0\" gs:managed-name=\"SetSize\">\n    <doc xml:space=\"preserve\">Sets the size of the #GByteArray, expanding it if necessary.</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the new size of the #GByteArray</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the new size of the #GByteArray</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <constructor name=\"sized_new\" c:identifier=\"g_byte_array_sized_new\" introspectable=\"0\" gs:managed-name=\"SizedNew\">\n    <doc xml:space=\"preserve\">Creates a new #GByteArray with @reserved_size bytes preallocated.\nThis avoids frequent reallocation, if you are going to add many\nbytes to the array. Note however that the size of the array is still\n0.</doc>\n    <return-value gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new #GByteArray</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <parameter name=\"reserved_size\" transfer-ownership=\"none\" gs:managed-name=\"reservedSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of bytes preallocated</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"reserved_size\" transfer-ownership=\"none\" gs:managed-name=\"reservedSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of bytes preallocated</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"sort\" c:identifier=\"g_byte_array_sort\" introspectable=\"0\" gs:managed-name=\"Sort\">\n    <doc xml:space=\"preserve\">Sorts a byte array, using @compare_func which should be a\nqsort()-style comparison function (returns less than zero for first\narg is less than second arg, zero for equal, greater than zero if\nfirst arg is greater than second arg).\n\nIf two array elements compare equal, their order in the sorted array\nis undefined. If you want equal elements to keep their order (i.e.\nyou want a stable sort) you can write a comparison function that,\nif two elements would otherwise compare equal, compares them by\ntheir addresses.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"sort_with_data\" c:identifier=\"g_byte_array_sort_with_data\" introspectable=\"0\" gs:managed-name=\"SortWithData\">\n    <doc xml:space=\"preserve\">Like g_byte_array_sort(), but the comparison function takes an extra\nuser data argument.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @compare_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @compare_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_byte_array_unref\" version=\"2.22\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Atomically decrements the reference count of @array by one. If the\nreference count drops to 0, all memory allocated by the array is\nreleased. This function is thread-safe and may be called from any\nthread.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GByteArray</doc>\n        <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    public partial class ByteArray : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.ByteArray>
    {
        public ByteArray(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GByteArray with a reference count of 1.
        /// </summary>
        /// <returns>
        /// the new #GByteArray
        /// </returns>
        public ByteArray() : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Create byte array containing the data. The data will be owned by the array
        /// and will be freed with g_free(), i.e. it could be allocated using g_strdup().
        /// </summary>
        /// <param name="data">
        /// byte data for the array
        /// </param>
        /// <param name="len">
        /// length of @data
        /// </param>
        /// <returns>
        /// a new #GByteArray
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public ByteArray(
            System.Byte[] data) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GByteArray with @reserved_size bytes preallocated.
        /// This avoids frequent reallocation, if you are going to add many
        /// bytes to the array. Note however that the size of the array is still
        /// 0.
        /// </summary>
        /// <param name="reservedSize">
        /// number of bytes preallocated
        /// </param>
        /// <returns>
        /// the new #GByteArray
        /// </returns>
        public ByteArray(
            System.UInt32 reservedSize) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GByteArray with a reference count of 1.
        /// </summary>
        /// <returns>
        /// the new #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_new();

        /// <summary>
        /// Create byte array containing the data. The data will be owned by the array
        /// and will be freed with g_free(), i.e. it could be allocated using g_strdup().
        /// </summary>
        /// <param name="data">
        /// byte data for the array
        /// </param>
        /// <param name="len">
        /// length of @data
        /// </param>
        /// <returns>
        /// a new #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_byte_array_new_take(
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)] System.Byte[] data,
            [System.Runtime.InteropServices.In()] System.UInt64 len);

        /// <summary>
        /// Creates a new #GByteArray with @reserved_size bytes preallocated.
        /// This avoids frequent reallocation, if you are going to add many
        /// bytes to the array. Note however that the size of the array is still
        /// 0.
        /// </summary>
        /// <param name="reservedSize">
        /// number of bytes preallocated
        /// </param>
        /// <returns>
        /// the new #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_sized_new(
            [System.Runtime.InteropServices.In()] System.UInt32 reservedSize);

        /// <summary>
        /// Adds the given bytes to the end of the #GByteArray.
        /// The array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="data">
        /// the byte data to be added
        /// </param>
        /// <param name="len">
        /// the number of bytes to add
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_append(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.Byte data,
            [System.Runtime.InteropServices.In()] System.UInt32 len);

        /// <summary>
        /// Adds the given bytes to the end of the #GByteArray.
        /// The array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="data">
        /// the byte data to be added
        /// </param>
        /// <param name="len">
        /// the number of bytes to add
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        public GISharp.Core.ByteArray Append(
            System.Byte data,
            System.UInt32 len)
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Frees the memory allocated by the #GByteArray. If @free_segment is
        /// %TRUE it frees the actual byte data. If the reference count of
        /// @array is greater than one, the #GByteArray wrapper is preserved but
        /// the size of @array will be set to zero.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="freeSegment">
        /// if %TRUE the actual byte data is freed as well
        /// </param>
        /// <returns>
        /// the element data if @free_segment is %FALSE, otherwise
        ///          %NULL.  The element data should be freed using g_free().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Byte g_byte_array_free(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.Boolean freeSegment);

        /// <summary>
        /// Frees the memory allocated by the #GByteArray. If @free_segment is
        /// %TRUE it frees the actual byte data. If the reference count of
        /// @array is greater than one, the #GByteArray wrapper is preserved but
        /// the size of @array will be set to zero.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="freeSegment">
        /// if %TRUE the actual byte data is freed as well
        /// </param>
        /// <returns>
        /// the element data if @free_segment is %FALSE, otherwise
        ///          %NULL.  The element data should be freed using g_free().
        /// </returns>
        public System.Byte Free(
            System.Boolean freeSegment)
        {
            return default(System.Byte);
        }

        /// <summary>
        /// Transfers the data from the #GByteArray into a new immutable #GBytes.
        /// </summary>
        /// <remarks>
        /// The #GByteArray is freed unless the reference count of @array is greater
        /// than one, the #GByteArray wrapper is preserved but the size of @array
        /// will be set to zero.
        /// 
        /// This is identical to using g_bytes_new_take() and g_byte_array_free()
        /// together.
        /// </remarks>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <returns>
        /// a new immutable #GBytes representing same
        ///     byte data that was in the array
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_byte_array_free_to_bytes(
            [System.Runtime.InteropServices.In()] System.IntPtr array);

        /// <summary>
        /// Transfers the data from the #GByteArray into a new immutable #GBytes.
        /// </summary>
        /// <remarks>
        /// The #GByteArray is freed unless the reference count of @array is greater
        /// than one, the #GByteArray wrapper is preserved but the size of @array
        /// will be set to zero.
        /// 
        /// This is identical to using g_bytes_new_take() and g_byte_array_free()
        /// together.
        /// </remarks>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <returns>
        /// a new immutable #GBytes representing same
        ///     byte data that was in the array
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public GISharp.GLib.Bytes FreeToBytes()
        {
            return default(GISharp.GLib.Bytes);
        }

        /// <summary>
        /// Adds the given data to the start of the #GByteArray.
        /// The array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="data">
        /// the byte data to be added
        /// </param>
        /// <param name="len">
        /// the number of bytes to add
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_prepend(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.Byte data,
            [System.Runtime.InteropServices.In()] System.UInt32 len);

        /// <summary>
        /// Adds the given data to the start of the #GByteArray.
        /// The array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="data">
        /// the byte data to be added
        /// </param>
        /// <param name="len">
        /// the number of bytes to add
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        public GISharp.Core.ByteArray Prepend(
            System.Byte data,
            System.UInt32 len)
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Atomically increments the reference count of @array by one.
        /// This function is thread-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// A #GByteArray
        /// </param>
        /// <returns>
        /// The passed in #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern System.IntPtr g_byte_array_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr array);

        /// <summary>
        /// Atomically increments the reference count of @array by one.
        /// This function is thread-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// A #GByteArray
        /// </param>
        /// <returns>
        /// The passed in #GByteArray
        /// </returns>
        [GISharp.Core.Since("2.22")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Removes the byte at the given index from a #GByteArray.
        /// The following bytes are moved down one place.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="index">
        /// the index of the byte to remove
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_remove_index(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 index);

        /// <summary>
        /// Removes the byte at the given index from a #GByteArray.
        /// The following bytes are moved down one place.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="index">
        /// the index of the byte to remove
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        public GISharp.Core.ByteArray RemoveIndex(
            System.UInt32 index)
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Removes the byte at the given index from a #GByteArray. The last
        /// element in the array is used to fill in the space, so this function
        /// does not preserve the order of the #GByteArray. But it is faster
        /// than g_byte_array_remove_index().
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="index">
        /// the index of the byte to remove
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_remove_index_fast(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 index);

        /// <summary>
        /// Removes the byte at the given index from a #GByteArray. The last
        /// element in the array is used to fill in the space, so this function
        /// does not preserve the order of the #GByteArray. But it is faster
        /// than g_byte_array_remove_index().
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="index">
        /// the index of the byte to remove
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        public GISharp.Core.ByteArray RemoveIndexFast(
            System.UInt32 index)
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Removes the given number of bytes starting at the given index from a
        /// #GByteArray.  The following elements are moved to close the gap.
        /// </summary>
        /// <param name="array">
        /// a @GByteArray
        /// </param>
        /// <param name="index">
        /// the index of the first byte to remove
        /// </param>
        /// <param name="length">
        /// the number of bytes to remove
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_byte_array_remove_range(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 index,
            [System.Runtime.InteropServices.In()] System.UInt32 length);

        /// <summary>
        /// Removes the given number of bytes starting at the given index from a
        /// #GByteArray.  The following elements are moved to close the gap.
        /// </summary>
        /// <param name="array">
        /// a @GByteArray
        /// </param>
        /// <param name="index">
        /// the index of the first byte to remove
        /// </param>
        /// <param name="length">
        /// the number of bytes to remove
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.ByteArray RemoveRange(
            System.UInt32 index,
            System.UInt32 length)
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Sets the size of the #GByteArray, expanding it if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="length">
        /// the new size of the #GByteArray
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_byte_array_set_size(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 length);

        /// <summary>
        /// Sets the size of the #GByteArray, expanding it if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="length">
        /// the new size of the #GByteArray
        /// </param>
        /// <returns>
        /// the #GByteArray
        /// </returns>
        public GISharp.Core.ByteArray SetSize(
            System.UInt32 length)
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Sorts a byte array, using @compare_func which should be a
        /// qsort()-style comparison function (returns less than zero for first
        /// arg is less than second arg, zero for equal, greater than zero if
        /// first arg is greater than second arg).
        /// </summary>
        /// <remarks>
        /// If two array elements compare equal, their order in the sorted array
        /// is undefined. If you want equal elements to keep their order (i.e.
        /// you want a stable sort) you can write a comparison function that,
        /// if two elements would otherwise compare equal, compares them by
        /// their addresses.
        /// </remarks>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_byte_array_sort(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative compareFunc);

        /// <summary>
        /// Sorts a byte array, using @compare_func which should be a
        /// qsort()-style comparison function (returns less than zero for first
        /// arg is less than second arg, zero for equal, greater than zero if
        /// first arg is greater than second arg).
        /// </summary>
        /// <remarks>
        /// If two array elements compare equal, their order in the sorted array
        /// is undefined. If you want equal elements to keep their order (i.e.
        /// you want a stable sort) you can write a comparison function that,
        /// if two elements would otherwise compare equal, compares them by
        /// their addresses.
        /// </remarks>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        public void Sort(
            GISharp.Core.CompareFuncNative compareFunc)
        {
        }

        /// <summary>
        /// Like g_byte_array_sort(), but the comparison function takes an extra
        /// user data argument.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to @compare_func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_byte_array_sort_with_data(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative compareFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Like g_byte_array_sort(), but the comparison function takes an extra
        /// user data argument.
        /// </summary>
        /// <param name="array">
        /// a #GByteArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to @compare_func
        /// </param>
        public void SortWithData(
            GISharp.Core.CompareDataFuncNative compareFunc,
            System.IntPtr userData)
        {
        }

        /// <summary>
        /// Atomically decrements the reference count of @array by one. If the
        /// reference count drops to 0, all memory allocated by the array is
        /// released. This function is thread-safe and may be called from any
        /// thread.
        /// </summary>
        /// <param name="array">
        /// A #GByteArray
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern void g_byte_array_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr array);

        /// <summary>
        /// Atomically decrements the reference count of @array by one. If the
        /// reference count drops to 0, all memory allocated by the array is
        /// released. This function is thread-safe and may be called from any
        /// thread.
        /// </summary>
        /// <param name="array">
        /// A #GByteArray
        /// </param>
        [GISharp.Core.Since("2.22")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// A simple refcounted data type representing an immutable sequence of zero or
    /// more bytes from an unspecified origin.
    /// </summary>
    /// <remarks>
    /// The purpose of a #GBytes is to keep the memory region that it holds
    /// alive for as long as anyone holds a reference to the bytes.  When
    /// the last reference count is dropped, the memory is released. Multiple
    /// unrelated callers can use byte data in the #GBytes without coordinating
    /// their activities, resting assured that the byte data will not change or
    /// move while they hold a reference.
    /// 
    /// A #GBytes can come from many different origins that may have
    /// different procedures for freeing the memory region.  Examples are
    /// memory from g_malloc(), from memory slices, from a #GMappedFile or
    /// memory from other allocators.
    /// 
    /// #GBytes work well as keys in #GHashTable. Use g_bytes_equal() and
    /// g_bytes_hash() as parameters to g_hash_table_new() or g_hash_table_new_full().
    /// #GBytes can also be used as keys in a #GTree by passing the g_bytes_compare()
    /// function to g_tree_new().
    /// 
    /// The data pointed to by this bytes must not be modified. For a mutable
    /// array of bytes see #GByteArray. Use g_bytes_unref_to_array() to create a
    /// mutable array for a #GBytes sequence. To create an immutable #GBytes from
    /// a mutable #GByteArray, use the g_byte_array_free_to_bytes() function.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"Bytes\" c:type=\"GBytes\" version=\"2.32\" glib:type-name=\"GBytes\" glib:get-type=\"g_bytes_get_type\" c:symbol-prefix=\"bytes\" gs:managed-name=\"Bytes\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A simple refcounted data type representing an immutable sequence of zero or\nmore bytes from an unspecified origin.\n\nThe purpose of a #GBytes is to keep the memory region that it holds\nalive for as long as anyone holds a reference to the bytes.  When\nthe last reference count is dropped, the memory is released. Multiple\nunrelated callers can use byte data in the #GBytes without coordinating\ntheir activities, resting assured that the byte data will not change or\nmove while they hold a reference.\n\nA #GBytes can come from many different origins that may have\ndifferent procedures for freeing the memory region.  Examples are\nmemory from g_malloc(), from memory slices, from a #GMappedFile or\nmemory from other allocators.\n\n#GBytes work well as keys in #GHashTable. Use g_bytes_equal() and\ng_bytes_hash() as parameters to g_hash_table_new() or g_hash_table_new_full().\n#GBytes can also be used as keys in a #GTree by passing the g_bytes_compare()\nfunction to g_tree_new().\n\nThe data pointed to by this bytes must not be modified. For a mutable\narray of bytes see #GByteArray. Use g_bytes_unref_to_array() to create a\nmutable array for a #GBytes sequence. To create an immutable #GBytes from\na mutable #GByteArray, use the g_byte_array_free_to_bytes() function.</doc>\n  <constructor name=\"new\" c:identifier=\"g_bytes_new\" version=\"2.32\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GBytes from @data.\n\n@data is copied. If @size is 0, @data may be %NULL.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GBytes</doc>\n      <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">\n       the data to be used for the bytes</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n      <parameter name=\"size\" transfer-ownership=\"none\" gs:managed-name=\"size\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of @data</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">\n       the data to be used for the bytes</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_with_free_func\" c:identifier=\"g_bytes_new_with_free_func\" version=\"2.32\" introspectable=\"0\" pinvoke-only=\"1\" gs:managed-name=\"NewWithFreeFunc\">\n    <doc xml:space=\"preserve\">Creates a #GBytes from @data.\n\nWhen the last reference is dropped, @free_func will be called with the\n@user_data argument.\n\n@data must not be modified after this call is made until @free_func has\nbeen called to indicate that the bytes is no longer in use.\n\n@data may be %NULL if @size is 0.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GBytes</doc>\n      <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">the data to be used for the bytes</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </parameter>\n      <parameter name=\"size\" transfer-ownership=\"none\" gs:managed-name=\"size\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of @data</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"free_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"freeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">the function to call to release the data</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @free_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">the data to be used for the bytes</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </parameter>\n      <parameter name=\"free_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"freeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">the function to call to release the data</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @free_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"compare\" c:identifier=\"g_bytes_compare\" version=\"2.32\" gs:managed-name=\"CompareTo\" gs:special-func=\"compare\">\n    <doc xml:space=\"preserve\">Compares the two #GBytes values.\n\nThis function can be used to sort GBytes instances in lexographical order.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">a negative value if bytes2 is lesser, a positive value if bytes2 is\n         greater, and zero if bytes2 is equal to bytes1</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes1\" transfer-ownership=\"none\" gs:managed-name=\"bytes1\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n      <parameter name=\"bytes2\" transfer-ownership=\"none\" gs:managed-name=\"bytes2\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes to compare with @bytes1</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"bytes2\" transfer-ownership=\"none\" gs:managed-name=\"bytes2\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes to compare with @bytes1</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"equal\" c:identifier=\"g_bytes_equal\" version=\"2.32\" gs:managed-name=\"Equals\" gs:special-func=\"equal\">\n    <doc xml:space=\"preserve\">Compares the two #GBytes values being pointed to and returns\n%TRUE if they are equal.\n\nThis function can be passed to g_hash_table_new() as the @key_equal_func\nparameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the two keys match.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes1\" transfer-ownership=\"none\" gs:managed-name=\"bytes1\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n      <parameter name=\"bytes2\" transfer-ownership=\"none\" gs:managed-name=\"bytes2\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes to compare with @bytes1</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"bytes2\" transfer-ownership=\"none\" gs:managed-name=\"bytes2\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes to compare with @bytes1</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_data\" c:identifier=\"g_bytes_get_data\" version=\"2.32\" gs:managed-name=\"get_Data\" gs:property=\"Data\">\n    <doc xml:space=\"preserve\">Get the byte data in the #GBytes. This data should not be modified.\n\nThis function will always return the same pointer for a given #GBytes.\n\n%NULL may be returned if @size is 0. This is not guaranteed, as the #GBytes\nmay represent an empty string with @data non-%NULL and @size as 0. %NULL will\nnot be returned if @size is non-zero.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n      <doc xml:space=\"preserve\">a pointer to the\n         byte data, or %NULL</doc>\n      <array length=\"0\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"gconstpointer\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n      <parameter name=\"size\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"size\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">location to return size of byte data</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_size\" c:identifier=\"g_bytes_get_size\" version=\"2.32\" gs:managed-name=\"get_Size\" gs:property=\"Size\">\n    <doc xml:space=\"preserve\">Get the size of the byte data in the #GBytes.\n\nThis function will always return the same value for a given #GBytes.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the size</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"hash\" c:identifier=\"g_bytes_hash\" version=\"2.32\" gs:managed-name=\"Hash\" gs:special-func=\"hash\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Creates an integer hash code for the byte data in the #GBytes.\n\nThis function can be passed to g_hash_table_new() as the @key_hash_func\nparameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">a hash value corresponding to the key.</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GBytes key</doc>\n        <type name=\"Bytes\" c:type=\"gconstpointer\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"new_from_bytes\" c:identifier=\"g_bytes_new_from_bytes\" version=\"2.32\" gs:managed-name=\"NewFromBytes\">\n    <doc xml:space=\"preserve\">Creates a #GBytes which is a subsection of another #GBytes. The @offset +\n@length may not be longer than the size of @bytes.\n\nA reference to @bytes will be held by the newly created #GBytes until\nthe byte data is no longer needed.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GBytes</doc>\n      <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n      <parameter name=\"offset\" transfer-ownership=\"none\" gs:managed-name=\"offset\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">offset which subsection starts at</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">length of subsection</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"offset\" transfer-ownership=\"none\" gs:managed-name=\"offset\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">offset which subsection starts at</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">length of subsection</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_bytes_ref\" version=\"2.32\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increase the reference count on @bytes.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GBytes</doc>\n      <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref\" c:identifier=\"g_bytes_unref\" version=\"2.32\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Releases a reference on @bytes.  This may result in the bytes being\nfreed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref_to_array\" c:identifier=\"g_bytes_unref_to_array\" version=\"2.32\" gs:managed-name=\"UnrefToArray\">\n    <doc xml:space=\"preserve\">Unreferences the bytes, and returns a new mutable #GByteArray containing\nthe same byte data.\n\nAs an optimization, the byte data is transferred to the array without copying\nif this was the last reference to bytes and bytes was created with\ng_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all\nother cases the data is copied.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"GLib.ByteArray`1[System.Byte]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new mutable #GByteArray containing the same byte data</doc>\n      <array name=\"GLib.ByteArray\" c:type=\"GByteArray*\" gs:managed-name=\"GLib.ByteArray\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"full\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref_to_data\" c:identifier=\"g_bytes_unref_to_data\" version=\"2.32\" gs:managed-name=\"UnrefToData\">\n    <doc xml:space=\"preserve\">Unreferences the bytes, and returns a pointer the same byte data\ncontents.\n\nAs an optimization, the byte data is returned without copying if this was\nthe last reference to bytes and bytes was created with g_bytes_new(),\ng_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the\ndata is copied.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a pointer to the same byte data, which should\n         be freed with g_free()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"bytes\" transfer-ownership=\"full\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </instance-parameter>\n      <parameter name=\"size\" transfer-ownership=\"none\" gs:managed-name=\"size\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">location to place the length of the returned data</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"size\" transfer-ownership=\"none\" gs:managed-name=\"size\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">location to place the length of the returned data</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n</record>")]
    [GISharp.Core.Since("2.32")]
    public partial class Bytes : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.Bytes>,
        System.IComparable<GISharp.GLib.Bytes>,
        System.IEquatable<GISharp.GLib.Bytes>
    {
        /// <summary>
        /// Get the byte data in the #GBytes. This data should not be modified.
        /// </summary>
        /// <remarks>
        /// This function will always return the same pointer for a given #GBytes.
        /// 
        /// %NULL may be returned if @size is 0. This is not guaranteed, as the #GBytes
        /// may represent an empty string with @data non-%NULL and @size as 0. %NULL will
        /// not be returned if @size is non-zero.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="size">
        /// location to return size of byte data
        /// </param>
        /// <returns>
        /// a pointer to the
        ///          byte data, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public System.Byte[] Data
        {
            get
            {
                return default(System.Byte[]);
            }
        }

        /// <summary>
        /// Get the size of the byte data in the #GBytes.
        /// </summary>
        /// <remarks>
        /// This function will always return the same value for a given #GBytes.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <returns>
        /// the size
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public System.UInt64 Size
        {
            get
            {
                return default(System.UInt64);
            }
        }

        public Bytes(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GBytes from @data.
        /// </summary>
        /// <remarks>
        /// @data is copied. If @size is 0, @data may be %NULL.
        /// </remarks>
        /// <param name="data">
        /// 
        ///        the data to be used for the bytes
        /// </param>
        /// <param name="size">
        /// the size of @data
        /// </param>
        /// <returns>
        /// a new #GBytes
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public Bytes(
            System.Byte[] data) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a #GBytes from @data.
        /// </summary>
        /// <remarks>
        /// When the last reference is dropped, @free_func will be called with the
        /// @user_data argument.
        /// 
        /// @data must not be modified after this call is made until @free_func has
        /// been called to indicate that the bytes is no longer in use.
        /// 
        /// @data may be %NULL if @size is 0.
        /// </remarks>
        /// <param name="data">
        /// the data to be used for the bytes
        /// </param>
        /// <param name="size">
        /// the size of @data
        /// </param>
        /// <param name="freeFunc">
        /// the function to call to release the data
        /// </param>
        /// <param name="userData">
        /// data to pass to @free_func
        /// </param>
        /// <returns>
        /// a new #GBytes
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public Bytes(
            System.IntPtr[] data,
            GISharp.GLib.DestroyNotify freeFunc,
            System.IntPtr userData) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GBytes from @data.
        /// </summary>
        /// <remarks>
        /// @data is copied. If @size is 0, @data may be %NULL.
        /// </remarks>
        /// <param name="data">
        /// 
        ///        the data to be used for the bytes
        /// </param>
        /// <param name="size">
        /// the size of @data
        /// </param>
        /// <returns>
        /// a new #GBytes
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_bytes_new(
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)] System.Byte[] data,
            [System.Runtime.InteropServices.In()] System.UInt64 size);

        /// <summary>
        /// Creates a #GBytes from @data.
        /// </summary>
        /// <remarks>
        /// When the last reference is dropped, @free_func will be called with the
        /// @user_data argument.
        /// 
        /// @data must not be modified after this call is made until @free_func has
        /// been called to indicate that the bytes is no longer in use.
        /// 
        /// @data may be %NULL if @size is 0.
        /// </remarks>
        /// <param name="data">
        /// the data to be used for the bytes
        /// </param>
        /// <param name="size">
        /// the size of @data
        /// </param>
        /// <param name="freeFunc">
        /// the function to call to release the data
        /// </param>
        /// <param name="userData">
        /// data to pass to @free_func
        /// </param>
        /// <returns>
        /// a new #GBytes
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_bytes_new_with_free_func(
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)] System.IntPtr[] data,
            [System.Runtime.InteropServices.In()] System.UInt64 size,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify freeFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Compares the two #GBytes values.
        /// </summary>
        /// <remarks>
        /// This function can be used to sort GBytes instances in lexographical order.
        /// </remarks>
        /// <param name="bytes1">
        /// a pointer to a #GBytes
        /// </param>
        /// <param name="bytes2">
        /// a pointer to a #GBytes to compare with @bytes1
        /// </param>
        /// <returns>
        /// a negative value if bytes2 is lesser, a positive value if bytes2 is
        ///          greater, and zero if bytes2 is equal to bytes1
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.Int32 g_bytes_compare(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes1,
            [System.Runtime.InteropServices.In()] System.IntPtr bytes2);

        /// <summary>
        /// Compares the two #GBytes values.
        /// </summary>
        /// <remarks>
        /// This function can be used to sort GBytes instances in lexographical order.
        /// </remarks>
        /// <param name="bytes1">
        /// a pointer to a #GBytes
        /// </param>
        /// <param name="bytes2">
        /// a pointer to a #GBytes to compare with @bytes1
        /// </param>
        /// <returns>
        /// a negative value if bytes2 is lesser, a positive value if bytes2 is
        ///          greater, and zero if bytes2 is equal to bytes1
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public System.Int32 CompareTo(
            GISharp.GLib.Bytes bytes2)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Compares the two #GBytes values being pointed to and returns
        /// %TRUE if they are equal.
        /// </summary>
        /// <remarks>
        /// This function can be passed to g_hash_table_new() as the @key_equal_func
        /// parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
        /// </remarks>
        /// <param name="bytes1">
        /// a pointer to a #GBytes
        /// </param>
        /// <param name="bytes2">
        /// a pointer to a #GBytes to compare with @bytes1
        /// </param>
        /// <returns>
        /// %TRUE if the two keys match.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.Boolean g_bytes_equal(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes1,
            [System.Runtime.InteropServices.In()] System.IntPtr bytes2);

        /// <summary>
        /// Compares the two #GBytes values being pointed to and returns
        /// %TRUE if they are equal.
        /// </summary>
        /// <remarks>
        /// This function can be passed to g_hash_table_new() as the @key_equal_func
        /// parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
        /// </remarks>
        /// <param name="bytes1">
        /// a pointer to a #GBytes
        /// </param>
        /// <param name="bytes2">
        /// a pointer to a #GBytes to compare with @bytes1
        /// </param>
        /// <returns>
        /// %TRUE if the two keys match.
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public System.Boolean Equals(
            GISharp.GLib.Bytes bytes2)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Get the byte data in the #GBytes. This data should not be modified.
        /// </summary>
        /// <remarks>
        /// This function will always return the same pointer for a given #GBytes.
        /// 
        /// %NULL may be returned if @size is 0. This is not guaranteed, as the #GBytes
        /// may represent an empty string with @data non-%NULL and @size as 0. %NULL will
        /// not be returned if @size is non-zero.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="size">
        /// location to return size of byte data
        /// </param>
        /// <returns>
        /// a pointer to the
        ///          byte data, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)]
        static extern System.Byte[] g_bytes_get_data(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes,
            [System.Runtime.InteropServices.Out()] out System.UInt64 size);

        /// <summary>
        /// Get the size of the byte data in the #GBytes.
        /// </summary>
        /// <remarks>
        /// This function will always return the same value for a given #GBytes.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <returns>
        /// the size
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.UInt64 g_bytes_get_size(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes);

        /// <summary>
        /// Creates an integer hash code for the byte data in the #GBytes.
        /// </summary>
        /// <remarks>
        /// This function can be passed to g_hash_table_new() as the @key_hash_func
        /// parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
        /// </remarks>
        /// <param name="bytes">
        /// a pointer to a #GBytes key
        /// </param>
        /// <returns>
        /// a hash value corresponding to the key.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.UInt32 g_bytes_hash(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes);

        /// <summary>
        /// Creates an integer hash code for the byte data in the #GBytes.
        /// </summary>
        /// <remarks>
        /// This function can be passed to g_hash_table_new() as the @key_hash_func
        /// parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
        /// </remarks>
        /// <param name="bytes">
        /// a pointer to a #GBytes key
        /// </param>
        /// <returns>
        /// a hash value corresponding to the key.
        /// </returns>
        [GISharp.Core.Since("2.32")]
        protected System.UInt32 Hash()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Creates a #GBytes which is a subsection of another #GBytes. The @offset +
        /// @length may not be longer than the size of @bytes.
        /// </summary>
        /// <remarks>
        /// A reference to @bytes will be held by the newly created #GBytes until
        /// the byte data is no longer needed.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="offset">
        /// offset which subsection starts at
        /// </param>
        /// <param name="length">
        /// length of subsection
        /// </param>
        /// <returns>
        /// a new #GBytes
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_bytes_new_from_bytes(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes,
            [System.Runtime.InteropServices.In()] System.UInt64 offset,
            [System.Runtime.InteropServices.In()] System.UInt64 length);

        /// <summary>
        /// Creates a #GBytes which is a subsection of another #GBytes. The @offset +
        /// @length may not be longer than the size of @bytes.
        /// </summary>
        /// <remarks>
        /// A reference to @bytes will be held by the newly created #GBytes until
        /// the byte data is no longer needed.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="offset">
        /// offset which subsection starts at
        /// </param>
        /// <param name="length">
        /// length of subsection
        /// </param>
        /// <returns>
        /// a new #GBytes
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public GISharp.GLib.Bytes NewFromBytes(
            System.UInt64 offset,
            System.UInt64 length)
        {
            return default(GISharp.GLib.Bytes);
        }

        /// <summary>
        /// Increase the reference count on @bytes.
        /// </summary>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <returns>
        /// the #GBytes
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_bytes_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes);

        /// <summary>
        /// Increase the reference count on @bytes.
        /// </summary>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <returns>
        /// the #GBytes
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Releases a reference on @bytes.  This may result in the bytes being
        /// freed.
        /// </summary>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern void g_bytes_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes);

        /// <summary>
        /// Releases a reference on @bytes.  This may result in the bytes being
        /// freed.
        /// </summary>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        [GISharp.Core.Since("2.32")]
        public override void Unref()
        {
        }

        /// <summary>
        /// Unreferences the bytes, and returns a new mutable #GByteArray containing
        /// the same byte data.
        /// </summary>
        /// <remarks>
        /// As an optimization, the byte data is transferred to the array without copying
        /// if this was the last reference to bytes and bytes was created with
        /// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
        /// other cases the data is copied.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <returns>
        /// a new mutable #GByteArray containing the same byte data
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_bytes_unref_to_array(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes);

        /// <summary>
        /// Unreferences the bytes, and returns a new mutable #GByteArray containing
        /// the same byte data.
        /// </summary>
        /// <remarks>
        /// As an optimization, the byte data is transferred to the array without copying
        /// if this was the last reference to bytes and bytes was created with
        /// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
        /// other cases the data is copied.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <returns>
        /// a new mutable #GByteArray containing the same byte data
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public GISharp.Core.ByteArray UnrefToArray()
        {
            return default(GISharp.Core.ByteArray);
        }

        /// <summary>
        /// Unreferences the bytes, and returns a pointer the same byte data
        /// contents.
        /// </summary>
        /// <remarks>
        /// As an optimization, the byte data is returned without copying if this was
        /// the last reference to bytes and bytes was created with g_bytes_new(),
        /// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
        /// data is copied.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="size">
        /// location to place the length of the returned data
        /// </param>
        /// <returns>
        /// a pointer to the same byte data, which should
        ///          be freed with g_free()
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_bytes_unref_to_data(
            [System.Runtime.InteropServices.In()] System.IntPtr bytes,
            [System.Runtime.InteropServices.In()] System.UInt64 size);

        /// <summary>
        /// Unreferences the bytes, and returns a pointer the same byte data
        /// contents.
        /// </summary>
        /// <remarks>
        /// As an optimization, the byte data is returned without copying if this was
        /// the last reference to bytes and bytes was created with g_bytes_new(),
        /// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
        /// data is copied.
        /// </remarks>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="size">
        /// location to place the length of the returned data
        /// </param>
        /// <returns>
        /// a pointer to the same byte data, which should
        ///          be freed with g_free()
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public System.IntPtr UnrefToData(
            System.UInt64 size)
        {
            return default(System.IntPtr);
        }

        public static bool operator <(GISharp.GLib.Bytes one, GISharp.GLib.Bytes two)
        {
            return one.CompareTo(two) < 0;
        }

        public static bool operator <=(GISharp.GLib.Bytes one, GISharp.GLib.Bytes two)
        {
            return one.CompareTo(two) <= 0;
        }

        public static bool operator >=(GISharp.GLib.Bytes one, GISharp.GLib.Bytes two)
        {
            return one.CompareTo(two) >= 0;
        }

        public static bool operator >(GISharp.GLib.Bytes one, GISharp.GLib.Bytes two)
        {
            return one.CompareTo(two) > 0;
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as GISharp.GLib.Bytes);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public static bool operator ==(GISharp.GLib.Bytes one, GISharp.GLib.Bytes two)
        {
            if ((object)one == null)
            {
                return (object)two == null;
            }
            return one.Equals(two);
        }

        public static bool operator !=(GISharp.GLib.Bytes one, GISharp.GLib.Bytes two)
        {
            return !(one == two);
        }
    }

    /// <summary>
    /// The #GData struct is an opaque data structure to represent a
    /// [Keyed Data List][glib-Keyed-Data-Lists]. It should only be
    /// accessed via the following functions.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Data\" c:type=\"GData\" disguised=\"1\" gs:managed-name=\"Data\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The #GData struct is an opaque data structure to represent a\n[Keyed Data List][glib-Keyed-Data-Lists]. It should only be\naccessed via the following functions.</doc>\n</record>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Data
    {
    }

    /// <summary>
    /// Specifies the type of function passed to g_dataset_foreach(). It is
    /// called with each #GQuark id and associated data element, together
    /// with the @user_data parameter supplied to g_dataset_foreach().
    /// </summary>
    /// <param name="keyId">
    /// the #GQuark id to identifying the data element.
    /// </param>
    /// <param name="data">
    /// the data element.
    /// </param>
    /// <param name="userData">
    /// user data passed to g_dataset_foreach().
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"DataForeachFunc\" c:type=\"GDataForeachFunc\" gs:managed-name=\"DataForeachFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_dataset_foreach(). It is\ncalled with each #GQuark id and associated data element, together\nwith the @user_data parameter supplied to g_dataset_foreach().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"key_id\" transfer-ownership=\"none\" gs:managed-name=\"keyId\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">the #GQuark id to identifying the data element.</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_dataset_foreach().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"key_id\" transfer-ownership=\"none\" gs:managed-name=\"keyId\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">the #GQuark id to identifying the data element.</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void DataForeachFuncNative(
        [System.Runtime.InteropServices.In()] GISharp.GLib.Quark keyId,
        [System.Runtime.InteropServices.In()] System.IntPtr data,
        [System.Runtime.InteropServices.In()] System.IntPtr userData);

    /// <summary>
    /// Specifies the type of function passed to g_dataset_foreach(). It is
    /// called with each #GQuark id and associated data element, together
    /// with the @user_data parameter supplied to g_dataset_foreach().
    /// </summary>
    /// <param name="keyId">
    /// the #GQuark id to identifying the data element.
    /// </param>
    /// <param name="data">
    /// the data element.
    /// </param>
    /// <param name="userData">
    /// user data passed to g_dataset_foreach().
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"DataForeachFunc\" c:type=\"GDataForeachFunc\" gs:managed-name=\"DataForeachFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_dataset_foreach(). It is\ncalled with each #GQuark id and associated data element, together\nwith the @user_data parameter supplied to g_dataset_foreach().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"key_id\" transfer-ownership=\"none\" gs:managed-name=\"keyId\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">the #GQuark id to identifying the data element.</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_dataset_foreach().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"key_id\" transfer-ownership=\"none\" gs:managed-name=\"keyId\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <doc xml:space=\"preserve\">the #GQuark id to identifying the data element.</doc>\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate void DataForeachFunc(
        GISharp.GLib.Quark keyId,
        System.IntPtr data);

    /// <summary>
    /// Represents a day between January 1, Year 1 and a few thousand years in
    /// the future. None of its members should be accessed directly.
    /// </summary>
    /// <remarks>
    /// If the #GDate-struct is obtained from g_date_new(), it will be safe
    /// to mutate but invalid and thus not safe for calendrical computations.
    /// 
    /// If it's declared on the stack, it will contain garbage so must be
    /// initialized with g_date_clear(). g_date_clear() makes the date invalid
    /// but sane. An invalid date doesn't represent a day, it's "empty." A date
    /// becomes valid after you set it to a Julian day or you set a day, month,
    /// and year.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"Date\" c:type=\"GDate\" glib:type-name=\"GDate\" glib:get-type=\"g_date_get_type\" c:symbol-prefix=\"date\" gs:managed-name=\"Date\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Represents a day between January 1, Year 1 and a few thousand years in\nthe future. None of its members should be accessed directly.\n\nIf the #GDate-struct is obtained from g_date_new(), it will be safe\nto mutate but invalid and thus not safe for calendrical computations.\n\nIf it's declared on the stack, it will contain garbage so must be\ninitialized with g_date_clear(). g_date_clear() makes the date invalid\nbut sane. An invalid date doesn't represent a day, it's \"empty.\" A date\nbecomes valid after you set it to a Julian day or you set a day, month,\nand year.</doc>\n  <constructor name=\"new\" c:identifier=\"g_date_new\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Allocates a #GDate and initializes\nit to a sane state. The new date will\nbe cleared (as if you'd called g_date_clear()) but invalid (it won't\nrepresent an existing day). Free the return value with g_date_free().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly-allocated #GDate</doc>\n      <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n    </return-value>\n  </constructor>\n  <constructor name=\"new_dmy\" c:identifier=\"g_date_new_dmy\" gs:managed-name=\"NewDmy\">\n    <doc xml:space=\"preserve\">Like g_date_new(), but also sets the value of the date. Assuming the\nday-month-year triplet you pass in represents an existing day, the\nreturned date will be valid.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly-allocated #GDate initialized with @day, @month, and @year</doc>\n      <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day of the month</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month of the year</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day of the month</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month of the year</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_julian\" c:identifier=\"g_date_new_julian\" gs:managed-name=\"NewJulian\">\n    <doc xml:space=\"preserve\">Like g_date_new(), but also sets the value of the date. Assuming the\nJulian day number you pass in is valid (greater than 0, less than an\nunreasonably large number), the returned date will be valid.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly-allocated #GDate initialized with @julian_day</doc>\n      <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"julian_day\" transfer-ownership=\"none\" gs:managed-name=\"julianDay\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">days since January 1, Year 1</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"julian_day\" transfer-ownership=\"none\" gs:managed-name=\"julianDay\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">days since January 1, Year 1</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"add_days\" c:identifier=\"g_date_add_days\" gs:managed-name=\"AddDays\">\n    <doc xml:space=\"preserve\">Increments a date some number of days.\nTo move forward by weeks, add weeks*7 days.\nThe date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to increment</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_days\" transfer-ownership=\"none\" gs:managed-name=\"nDays\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of days to move the date forward</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_days\" transfer-ownership=\"none\" gs:managed-name=\"nDays\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of days to move the date forward</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_months\" c:identifier=\"g_date_add_months\" gs:managed-name=\"AddMonths\">\n    <doc xml:space=\"preserve\">Increments a date by some number of months.\nIf the day of the month is greater than 28,\nthis routine may change the day of the month\n(because the destination month may not have\nthe current day in it). The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to increment</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_months\" transfer-ownership=\"none\" gs:managed-name=\"nMonths\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of months to move forward</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_months\" transfer-ownership=\"none\" gs:managed-name=\"nMonths\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of months to move forward</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_years\" c:identifier=\"g_date_add_years\" gs:managed-name=\"AddYears\">\n    <doc xml:space=\"preserve\">Increments a date by some number of years.\nIf the date is February 29, and the destination\nyear is not a leap year, the date will be changed\nto February 28. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to increment</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_years\" transfer-ownership=\"none\" gs:managed-name=\"nYears\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of years to move forward</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_years\" transfer-ownership=\"none\" gs:managed-name=\"nYears\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of years to move forward</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"clamp\" c:identifier=\"g_date_clamp\" gs:managed-name=\"Clamp\">\n    <doc xml:space=\"preserve\">If @date is prior to @min_date, sets @date equal to @min_date.\nIf @date falls after @max_date, sets @date equal to @max_date.\nOtherwise, @date is unchanged.\nEither of @min_date and @max_date may be %NULL.\nAll non-%NULL dates must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to clamp</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"min_date\" transfer-ownership=\"none\" gs:managed-name=\"minDate\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">minimum accepted value for @date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n      <parameter name=\"max_date\" transfer-ownership=\"none\" gs:managed-name=\"maxDate\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">maximum accepted value for @date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"min_date\" transfer-ownership=\"none\" gs:managed-name=\"minDate\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">minimum accepted value for @date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n      <parameter name=\"max_date\" transfer-ownership=\"none\" gs:managed-name=\"maxDate\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">maximum accepted value for @date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"clear\" c:identifier=\"g_date_clear\" gs:managed-name=\"Clear\">\n    <doc xml:space=\"preserve\">Initializes one or more #GDate structs to a sane but invalid\nstate. The cleared dates will not represent an existing date, but will\nnot contain garbage. Useful to init a date declared on the stack.\nValidity can be tested with g_date_valid().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">pointer to one or more dates to clear</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_dates\" transfer-ownership=\"none\" gs:managed-name=\"nDates\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of dates to clear</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_dates\" transfer-ownership=\"none\" gs:managed-name=\"nDates\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of dates to clear</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"compare\" c:identifier=\"g_date_compare\" gs:managed-name=\"CompareTo\" gs:special-func=\"compare\">\n    <doc xml:space=\"preserve\">qsort()-style comparison function for dates.\nBoth dates must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">0 for equal, less than zero if @lhs is less than @rhs,\n    greater than zero if @lhs is greater than @rhs</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"lhs\" transfer-ownership=\"none\" gs:managed-name=\"lhs\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">first date to compare</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"rhs\" transfer-ownership=\"none\" gs:managed-name=\"rhs\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">second date to compare</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"rhs\" transfer-ownership=\"none\" gs:managed-name=\"rhs\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">second date to compare</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"days_between\" c:identifier=\"g_date_days_between\" gs:managed-name=\"DaysBetween\">\n    <doc xml:space=\"preserve\">Computes the number of days between two dates.\nIf @date2 is prior to @date1, the returned value is negative.\nBoth dates must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the number of days between @date1 and @date2</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date1\" transfer-ownership=\"none\" gs:managed-name=\"date1\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the first date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"date2\" transfer-ownership=\"none\" gs:managed-name=\"date2\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the second date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"date2\" transfer-ownership=\"none\" gs:managed-name=\"date2\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the second date</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free\" c:identifier=\"g_date_free\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees a #GDate returned from g_date_new().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to free</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_day\" c:identifier=\"g_date_get_day\" gs:managed-name=\"get_Day\" gs:property=\"Day\">\n    <doc xml:space=\"preserve\">Returns the day of the month. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n      <doc xml:space=\"preserve\">day of the month</doc>\n      <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to extract the day of the month from</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_day_of_year\" c:identifier=\"g_date_get_day_of_year\" gs:managed-name=\"get_DayOfYear\" gs:property=\"DayOfYear\">\n    <doc xml:space=\"preserve\">Returns the day of the year, where Jan 1 is the first day of the\nyear. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">day of the year</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to extract day of year from</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_iso8601_week_of_year\" c:identifier=\"g_date_get_iso8601_week_of_year\" version=\"2.6\" gs:managed-name=\"get_Iso8601WeekOfYear\" gs:property=\"Iso8601WeekOfYear\">\n    <doc xml:space=\"preserve\">Returns the week of the year, where weeks are interpreted according\nto ISO 8601.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">ISO 8601 week number of the year.</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_julian\" c:identifier=\"g_date_get_julian\" gs:managed-name=\"get_Julian\" gs:property=\"Julian\">\n    <doc xml:space=\"preserve\">Returns the Julian day or \"serial number\" of the #GDate. The\nJulian day is simply the number of days since January 1, Year 1; i.e.,\nJanuary 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,\netc. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">Julian day</doc>\n      <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to extract the Julian day from</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_monday_week_of_year\" c:identifier=\"g_date_get_monday_week_of_year\" gs:managed-name=\"get_MondayWeekOfYear\" gs:property=\"MondayWeekOfYear\">\n    <doc xml:space=\"preserve\">Returns the week of the year, where weeks are understood to start on\nMonday. If the date is before the first Monday of the year, return\n0. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">week of the year</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_month\" c:identifier=\"g_date_get_month\" gs:managed-name=\"get_Month\" gs:property=\"Month\">\n    <doc xml:space=\"preserve\">Returns the month of the year. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n      <doc xml:space=\"preserve\">month of the year as a #GDateMonth</doc>\n      <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to get the month from</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_sunday_week_of_year\" c:identifier=\"g_date_get_sunday_week_of_year\" gs:managed-name=\"get_SundayWeekOfYear\" gs:property=\"SundayWeekOfYear\">\n    <doc xml:space=\"preserve\">Returns the week of the year during which this date falls, if weeks\nare understood to being on Sunday. The date must be valid. Can return\n0 if the day is before the first Sunday of the year.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">week number</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_weekday\" c:identifier=\"g_date_get_weekday\" gs:managed-name=\"get_Weekday\" gs:property=\"Weekday\">\n    <doc xml:space=\"preserve\">Returns the day of the week for a #GDate. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"DateWeekday\" gs:unmanaged-type=\"DateWeekday\">\n      <doc xml:space=\"preserve\">day of the week as a #GDateWeekday.</doc>\n      <type name=\"DateWeekday\" c:type=\"GDateWeekday\" gs:managed-name=\"DateWeekday\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_year\" c:identifier=\"g_date_get_year\" gs:managed-name=\"get_Year\" gs:property=\"Year\">\n    <doc xml:space=\"preserve\">Returns the year of a #GDate. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n      <doc xml:space=\"preserve\">year in which the date falls</doc>\n      <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_first_of_month\" c:identifier=\"g_date_is_first_of_month\" gs:managed-name=\"get_IsFirstOfMonth\" gs:property=\"IsFirstOfMonth\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the date is on the first of a month.\nThe date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the date is the first of the month</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to check</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_last_of_month\" c:identifier=\"g_date_is_last_of_month\" gs:managed-name=\"get_IsLastOfMonth\" gs:property=\"IsLastOfMonth\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the date is the last day of the month.\nThe date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the date is the last day of the month</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to check</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"order\" c:identifier=\"g_date_order\" gs:managed-name=\"Order\">\n    <doc xml:space=\"preserve\">Checks if @date1 is less than or equal to @date2,\nand swap the values if this is not the case.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date1\" transfer-ownership=\"none\" gs:managed-name=\"date1\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the first date</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"date2\" transfer-ownership=\"none\" gs:managed-name=\"date2\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the second date</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"date2\" transfer-ownership=\"none\" gs:managed-name=\"date2\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the second date</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_day\" c:identifier=\"g_date_set_day\" gs:managed-name=\"set_Day\" gs:property=\"Day\">\n    <doc xml:space=\"preserve\">Sets the day of the month for a #GDate. If the resulting\nday-month-year triplet is invalid, the date will be invalid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day to set</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day to set</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_dmy\" c:identifier=\"g_date_set_dmy\" gs:managed-name=\"SetDmy\">\n    <doc xml:space=\"preserve\">Sets the value of a #GDate from a day, month, and year.\nThe day-month-year triplet must be valid; if you aren't\nsure it is, call g_date_valid_dmy() to check before you\nset it.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"y\" transfer-ownership=\"none\" gs:managed-name=\"y\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"y\" transfer-ownership=\"none\" gs:managed-name=\"y\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_julian\" c:identifier=\"g_date_set_julian\" gs:managed-name=\"set_Julian\" gs:property=\"Julian\">\n    <doc xml:space=\"preserve\">Sets the value of a #GDate from a Julian day number.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"julian_date\" transfer-ownership=\"none\" gs:managed-name=\"julianDate\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">Julian day number (days since January 1, Year 1)</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"julian_date\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">Julian day number (days since January 1, Year 1)</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_month\" c:identifier=\"g_date_set_month\" gs:managed-name=\"set_Month\" gs:property=\"Month\">\n    <doc xml:space=\"preserve\">Sets the month of the year for a #GDate.  If the resulting\nday-month-year triplet is invalid, the date will be invalid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month to set</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month to set</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_parse\" c:identifier=\"g_date_set_parse\" gs:managed-name=\"SetParse\">\n    <doc xml:space=\"preserve\">Parses a user-inputted string @str, and try to figure out what date it\nrepresents, taking the [current locale][setlocale] into account. If the\nstring is successfully parsed, the date will be valid after the call.\nOtherwise, it will be invalid. You should check using g_date_valid()\nto see whether the parsing succeeded.\n\nThis function is not appropriate for file formats and the like; it\nisn't very precise, and its exact behavior varies with the locale.\nIt's intended to be a heuristic routine that guesses what the user\nmeans by a given string (and it does work pretty well in that\ncapacity).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to fill in</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"str\" transfer-ownership=\"none\" gs:managed-name=\"str\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">string to parse</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"str\" transfer-ownership=\"none\" gs:managed-name=\"str\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">string to parse</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_time_val\" c:identifier=\"g_date_set_time_val\" version=\"2.10\" gs:managed-name=\"SetTimeVal\">\n    <doc xml:space=\"preserve\">Sets the value of a date from a #GTimeVal value.  Note that the\n@tv_usec member is ignored, because #GDate can't make use of the\nadditional precision.\n\nThe time to date conversion is done using the user's current timezone.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"timeval\" transfer-ownership=\"none\" gs:managed-name=\"timeval\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">#GTimeVal value to set</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"timeval\" transfer-ownership=\"none\" gs:managed-name=\"timeval\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">#GTimeVal value to set</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_year\" c:identifier=\"g_date_set_year\" gs:managed-name=\"set_Year\" gs:property=\"Year\">\n    <doc xml:space=\"preserve\">Sets the year for a #GDate. If the resulting day-month-year\ntriplet is invalid, the date will be invalid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year to set</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year to set</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"subtract_days\" c:identifier=\"g_date_subtract_days\" gs:managed-name=\"SubtractDays\">\n    <doc xml:space=\"preserve\">Moves a date some number of days into the past.\nTo move by weeks, just move by weeks*7 days.\nThe date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to decrement</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_days\" transfer-ownership=\"none\" gs:managed-name=\"nDays\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of days to move</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_days\" transfer-ownership=\"none\" gs:managed-name=\"nDays\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of days to move</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"subtract_months\" c:identifier=\"g_date_subtract_months\" gs:managed-name=\"SubtractMonths\">\n    <doc xml:space=\"preserve\">Moves a date some number of months into the past.\nIf the current day of the month doesn't exist in\nthe destination month, the day of the month\nmay change. The date must be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to decrement</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_months\" transfer-ownership=\"none\" gs:managed-name=\"nMonths\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of months to move</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_months\" transfer-ownership=\"none\" gs:managed-name=\"nMonths\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of months to move</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"subtract_years\" c:identifier=\"g_date_subtract_years\" gs:managed-name=\"SubtractYears\">\n    <doc xml:space=\"preserve\">Moves a date some number of years into the past.\nIf the current day doesn't exist in the destination\nyear (i.e. it's February 29 and you move to a non-leap-year)\nthen the day is changed to February 29. The date\nmust be valid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to decrement</doc>\n        <type name=\"Date\" c:type=\"GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"n_years\" transfer-ownership=\"none\" gs:managed-name=\"nYears\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of years to move</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n_years\" transfer-ownership=\"none\" gs:managed-name=\"nYears\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of years to move</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"to_struct_tm\" c:identifier=\"g_date_to_struct_tm\" gs:managed-name=\"ToStructTm\">\n    <doc xml:space=\"preserve\">Fills in the date-related bits of a struct tm using the @date value.\nInitializes the non-date parts with something sane but meaningless.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to set the struct tm from</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n      <parameter name=\"tm\" transfer-ownership=\"none\" gs:managed-name=\"tm\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">struct tm to fill</doc>\n        <type name=\"gpointer\" c:type=\"tm*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tm\" transfer-ownership=\"none\" gs:managed-name=\"tm\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">struct tm to fill</doc>\n        <type name=\"gpointer\" c:type=\"tm*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"valid\" c:identifier=\"g_date_valid\" gs:managed-name=\"Valid\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the #GDate represents an existing day. The date must not\ncontain garbage; it should have been initialized with g_date_clear()\nif it wasn't allocated by one of the g_date_new() variants.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">Whether the date is valid</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDate to check</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"get_days_in_month\" c:identifier=\"g_date_get_days_in_month\" gs:managed-name=\"GetDaysInMonth\">\n    <doc xml:space=\"preserve\">Returns the number of days in a month, taking leap\nyears into account.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n      <doc xml:space=\"preserve\">number of days in @month during the @year</doc>\n      <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"get_monday_weeks_in_year\" c:identifier=\"g_date_get_monday_weeks_in_year\" gs:managed-name=\"GetMondayWeeksInYear\">\n    <doc xml:space=\"preserve\">Returns the number of weeks in the year, where weeks\nare taken to start on Monday. Will be 52 or 53. The\ndate must be valid. (Years always have 52 7-day periods,\nplus 1 or 2 extra days depending on whether it's a leap\nyear. This function is basically telling you how many\nMondays are in the year, i.e. there are 53 Mondays if\none of the extra days happens to be a Monday.)</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n      <doc xml:space=\"preserve\">number of Mondays in the year</doc>\n      <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">a year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">a year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"get_sunday_weeks_in_year\" c:identifier=\"g_date_get_sunday_weeks_in_year\" gs:managed-name=\"GetSundayWeeksInYear\">\n    <doc xml:space=\"preserve\">Returns the number of weeks in the year, where weeks\nare taken to start on Sunday. Will be 52 or 53. The\ndate must be valid. (Years always have 52 7-day periods,\nplus 1 or 2 extra days depending on whether it's a leap\nyear. This function is basically telling you how many\nSundays are in the year, i.e. there are 53 Sundays if\none of the extra days happens to be a Sunday.)</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n      <doc xml:space=\"preserve\">the number of weeks in @year</doc>\n      <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year to count weeks in</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year to count weeks in</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"is_leap_year\" c:identifier=\"g_date_is_leap_year\" gs:managed-name=\"IsLeapYear\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the year is a leap year.\n\nFor the purposes of this function, leap year is every year\ndivisible by 4 unless that year is divisible by 100. If it\nis divisible by 100 it would be a leap year only if that year\nis also divisible by 400.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the year is a leap year</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year to check</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year to check</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"strftime\" c:identifier=\"g_date_strftime\" gs:managed-name=\"Strftime\">\n    <doc xml:space=\"preserve\">Generates a printed representation of the date, in a\n[locale][setlocale]-specific way.\nWorks just like the platform's C library strftime() function,\nbut only accepts date-related formats; time-related formats\ngive undefined results. Date must be valid. Unlike strftime()\n(which uses the locale encoding), works on a UTF-8 format\nstring and stores a UTF-8 result.\n\nThis function does not provide any conversion specifiers in\naddition to those implemented by the platform's C library.\nFor example, don't expect that using g_date_strftime() would\nmake the \\%F provided by the C99 strftime() work on Windows\nwhere the C library only complies to C89.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">number of characters written to the buffer, or 0 the buffer was too small</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"s\" transfer-ownership=\"none\" gs:managed-name=\"s\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">destination buffer</doc>\n        <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"slen\" transfer-ownership=\"none\" gs:managed-name=\"slen\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">buffer size</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">valid #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"s\" transfer-ownership=\"none\" gs:managed-name=\"s\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">destination buffer</doc>\n        <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"slen\" transfer-ownership=\"none\" gs:managed-name=\"slen\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">buffer size</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"date\" transfer-ownership=\"none\" gs:managed-name=\"date\" gs:managed-type=\"Date\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">valid #GDate</doc>\n        <type name=\"Date\" c:type=\"const GDate*\" gs:managed-name=\"Date\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"valid_day\" c:identifier=\"g_date_valid_day\" gs:managed-name=\"ValidDay\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the day of the month is valid (a day is valid if it's\nbetween 1 and 31 inclusive).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the day is valid</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day to check</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day to check</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"valid_dmy\" c:identifier=\"g_date_valid_dmy\" gs:managed-name=\"ValidDmy\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the day-month-year triplet forms a valid, existing day\nin the range of days #GDate understands (Year 1 or later, no more than\na few thousand years in the future).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the date is a valid one</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"DateDay\" gs:unmanaged-type=\"DateDay\">\n        <doc xml:space=\"preserve\">day</doc>\n        <type name=\"DateDay\" c:type=\"GDateDay\" gs:managed-name=\"DateDay\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"valid_julian\" c:identifier=\"g_date_valid_julian\" gs:managed-name=\"ValidJulian\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the Julian day is valid. Anything greater than zero\nis basically a valid Julian, though there is a 32-bit limit.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the Julian day is valid</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"julian_date\" transfer-ownership=\"none\" gs:managed-name=\"julianDate\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">Julian day to check</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"julian_date\" transfer-ownership=\"none\" gs:managed-name=\"julianDate\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">Julian day to check</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"valid_month\" c:identifier=\"g_date_valid_month\" gs:managed-name=\"ValidMonth\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the month value is valid. The 12 #GDateMonth\nenumeration values are the only valid months.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the month is valid</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"DateMonth\" gs:unmanaged-type=\"DateMonth\">\n        <doc xml:space=\"preserve\">month</doc>\n        <type name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"valid_weekday\" c:identifier=\"g_date_valid_weekday\" gs:managed-name=\"ValidWeekday\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration\nvalues are the only valid weekdays.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the weekday is valid</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"weekday\" transfer-ownership=\"none\" gs:managed-name=\"weekday\" gs:managed-type=\"DateWeekday\" gs:unmanaged-type=\"DateWeekday\">\n        <doc xml:space=\"preserve\">weekday</doc>\n        <type name=\"DateWeekday\" c:type=\"GDateWeekday\" gs:managed-name=\"DateWeekday\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"weekday\" transfer-ownership=\"none\" gs:managed-name=\"weekday\" gs:managed-type=\"DateWeekday\" gs:unmanaged-type=\"DateWeekday\">\n        <doc xml:space=\"preserve\">weekday</doc>\n        <type name=\"DateWeekday\" c:type=\"GDateWeekday\" gs:managed-name=\"DateWeekday\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"valid_year\" c:identifier=\"g_date_valid_year\" gs:managed-name=\"ValidYear\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the year is valid. Any year greater than 0 is valid,\nthough there is a 16-bit limit to what #GDate will understand.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the year is valid</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"DateYear\" gs:unmanaged-type=\"DateYear\">\n        <doc xml:space=\"preserve\">year</doc>\n        <type name=\"DateYear\" c:type=\"GDateYear\" gs:managed-name=\"DateYear\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <constant name=\"BAD_DAY\" value=\"0\" c:type=\"G_DATE_BAD_DAY\" gs:managed-name=\"BadDay\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n    <doc xml:space=\"preserve\">Represents an invalid #GDateDay.</doc>\n    <type name=\"guint8\" c:type=\"guint8\" gs:managed-name=\"Guint8\" />\n  </constant>\n  <constant name=\"BAD_JULIAN\" value=\"0\" c:type=\"G_DATE_BAD_JULIAN\" gs:managed-name=\"BadJulian\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <doc xml:space=\"preserve\">Represents an invalid Julian day number.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"BAD_YEAR\" value=\"0\" c:type=\"G_DATE_BAD_YEAR\" gs:managed-name=\"BadYear\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n    <doc xml:space=\"preserve\">Represents an invalid year.</doc>\n    <type name=\"guint16\" c:type=\"guint16\" gs:managed-name=\"Guint16\" />\n  </constant>\n</record>")]
    public partial class Date : GISharp.Core.OwnedOpaque<GISharp.GLib.Date>,
        System.IComparable<GISharp.GLib.Date>
    {
        /// <summary>
        /// Represents an invalid #GDateDay.
        /// </summary>
        public const System.Byte BadDay = 0;

        /// <summary>
        /// Represents an invalid Julian day number.
        /// </summary>
        public const System.Int32 BadJulian = 0;

        /// <summary>
        /// Represents an invalid year.
        /// </summary>
        public const System.UInt16 BadYear = 0;

        /// <summary>
        /// Returns the day of the month. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to extract the day of the month from
        /// </param>
        /// <returns>
        /// day of the month
        /// </returns>
        public GISharp.GLib.DateDay Day
        {
            get
            {
                return default(GISharp.GLib.DateDay);
            }

            set
            {
            }
        }

        /// <summary>
        /// Returns the day of the year, where Jan 1 is the first day of the
        /// year. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to extract day of year from
        /// </param>
        /// <returns>
        /// day of the year
        /// </returns>
        public System.UInt32 DayOfYear
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Returns the week of the year, where weeks are interpreted according
        /// to ISO 8601.
        /// </summary>
        /// <param name="date">
        /// a valid #GDate
        /// </param>
        /// <returns>
        /// ISO 8601 week number of the year.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.UInt32 Iso8601WeekOfYear
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Returns the Julian day or "serial number" of the #GDate. The
        /// Julian day is simply the number of days since January 1, Year 1; i.e.,
        /// January 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,
        /// etc. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to extract the Julian day from
        /// </param>
        /// <returns>
        /// Julian day
        /// </returns>
        public System.UInt32 Julian
        {
            get
            {
                return default(System.UInt32);
            }

            set
            {
            }
        }

        /// <summary>
        /// Returns the week of the year, where weeks are understood to start on
        /// Monday. If the date is before the first Monday of the year, return
        /// 0. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// week of the year
        /// </returns>
        public System.UInt32 MondayWeekOfYear
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Returns the month of the year. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to get the month from
        /// </param>
        /// <returns>
        /// month of the year as a #GDateMonth
        /// </returns>
        public GISharp.GLib.DateMonth Month
        {
            get
            {
                return default(GISharp.GLib.DateMonth);
            }

            set
            {
            }
        }

        /// <summary>
        /// Returns the week of the year during which this date falls, if weeks
        /// are understood to being on Sunday. The date must be valid. Can return
        /// 0 if the day is before the first Sunday of the year.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// week number
        /// </returns>
        public System.UInt32 SundayWeekOfYear
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Returns the day of the week for a #GDate. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// day of the week as a #GDateWeekday.
        /// </returns>
        public GISharp.GLib.DateWeekday Weekday
        {
            get
            {
                return default(GISharp.GLib.DateWeekday);
            }
        }

        /// <summary>
        /// Returns the year of a #GDate. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// year in which the date falls
        /// </returns>
        public GISharp.GLib.DateYear Year
        {
            get
            {
                return default(GISharp.GLib.DateYear);
            }

            set
            {
            }
        }

        /// <summary>
        /// Returns %TRUE if the date is on the first of a month.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to check
        /// </param>
        /// <returns>
        /// %TRUE if the date is the first of the month
        /// </returns>
        public System.Boolean IsFirstOfMonth
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Returns %TRUE if the date is the last day of the month.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to check
        /// </param>
        /// <returns>
        /// %TRUE if the date is the last day of the month
        /// </returns>
        public System.Boolean IsLastOfMonth
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public Date(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Allocates a #GDate and initializes
        /// it to a sane state. The new date will
        /// be cleared (as if you'd called g_date_clear()) but invalid (it won't
        /// represent an existing day). Free the return value with g_date_free().
        /// </summary>
        /// <returns>
        /// a newly-allocated #GDate
        /// </returns>
        public Date() : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Like g_date_new(), but also sets the value of the date. Assuming the
        /// day-month-year triplet you pass in represents an existing day, the
        /// returned date will be valid.
        /// </summary>
        /// <param name="day">
        /// day of the month
        /// </param>
        /// <param name="month">
        /// month of the year
        /// </param>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// a newly-allocated #GDate initialized with @day, @month, and @year
        /// </returns>
        public Date(
            GISharp.GLib.DateDay day,
            GISharp.GLib.DateMonth month,
            GISharp.GLib.DateYear year) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Like g_date_new(), but also sets the value of the date. Assuming the
        /// Julian day number you pass in is valid (greater than 0, less than an
        /// unreasonably large number), the returned date will be valid.
        /// </summary>
        /// <param name="julianDay">
        /// days since January 1, Year 1
        /// </param>
        /// <returns>
        /// a newly-allocated #GDate initialized with @julian_day
        /// </returns>
        public Date(
            System.UInt32 julianDay) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Allocates a #GDate and initializes
        /// it to a sane state. The new date will
        /// be cleared (as if you'd called g_date_clear()) but invalid (it won't
        /// represent an existing day). Free the return value with g_date_free().
        /// </summary>
        /// <returns>
        /// a newly-allocated #GDate
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_date_new();

        /// <summary>
        /// Like g_date_new(), but also sets the value of the date. Assuming the
        /// day-month-year triplet you pass in represents an existing day, the
        /// returned date will be valid.
        /// </summary>
        /// <param name="day">
        /// day of the month
        /// </param>
        /// <param name="month">
        /// month of the year
        /// </param>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// a newly-allocated #GDate initialized with @day, @month, and @year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_date_new_dmy(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateDay day,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateMonth month,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Like g_date_new(), but also sets the value of the date. Assuming the
        /// Julian day number you pass in is valid (greater than 0, less than an
        /// unreasonably large number), the returned date will be valid.
        /// </summary>
        /// <param name="julianDay">
        /// days since January 1, Year 1
        /// </param>
        /// <returns>
        /// a newly-allocated #GDate initialized with @julian_day
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_date_new_julian(
            [System.Runtime.InteropServices.In()] System.UInt32 julianDay);

        /// <summary>
        /// Returns the number of days in a month, taking leap
        /// years into account.
        /// </summary>
        /// <param name="month">
        /// month
        /// </param>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// number of days in @month during the @year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Byte g_date_get_days_in_month(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateMonth month,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Returns the number of days in a month, taking leap
        /// years into account.
        /// </summary>
        /// <param name="month">
        /// month
        /// </param>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// number of days in @month during the @year
        /// </returns>
        public static System.Byte GetDaysInMonth(
            GISharp.GLib.DateMonth month,
            GISharp.GLib.DateYear year)
        {
            return default(System.Byte);
        }

        /// <summary>
        /// Returns the number of weeks in the year, where weeks
        /// are taken to start on Monday. Will be 52 or 53. The
        /// date must be valid. (Years always have 52 7-day periods,
        /// plus 1 or 2 extra days depending on whether it's a leap
        /// year. This function is basically telling you how many
        /// Mondays are in the year, i.e. there are 53 Mondays if
        /// one of the extra days happens to be a Monday.)
        /// </summary>
        /// <param name="year">
        /// a year
        /// </param>
        /// <returns>
        /// number of Mondays in the year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Byte g_date_get_monday_weeks_in_year(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Returns the number of weeks in the year, where weeks
        /// are taken to start on Monday. Will be 52 or 53. The
        /// date must be valid. (Years always have 52 7-day periods,
        /// plus 1 or 2 extra days depending on whether it's a leap
        /// year. This function is basically telling you how many
        /// Mondays are in the year, i.e. there are 53 Mondays if
        /// one of the extra days happens to be a Monday.)
        /// </summary>
        /// <param name="year">
        /// a year
        /// </param>
        /// <returns>
        /// number of Mondays in the year
        /// </returns>
        public static System.Byte GetMondayWeeksInYear(
            GISharp.GLib.DateYear year)
        {
            return default(System.Byte);
        }

        /// <summary>
        /// Returns the number of weeks in the year, where weeks
        /// are taken to start on Sunday. Will be 52 or 53. The
        /// date must be valid. (Years always have 52 7-day periods,
        /// plus 1 or 2 extra days depending on whether it's a leap
        /// year. This function is basically telling you how many
        /// Sundays are in the year, i.e. there are 53 Sundays if
        /// one of the extra days happens to be a Sunday.)
        /// </summary>
        /// <param name="year">
        /// year to count weeks in
        /// </param>
        /// <returns>
        /// the number of weeks in @year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Byte g_date_get_sunday_weeks_in_year(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Returns the number of weeks in the year, where weeks
        /// are taken to start on Sunday. Will be 52 or 53. The
        /// date must be valid. (Years always have 52 7-day periods,
        /// plus 1 or 2 extra days depending on whether it's a leap
        /// year. This function is basically telling you how many
        /// Sundays are in the year, i.e. there are 53 Sundays if
        /// one of the extra days happens to be a Sunday.)
        /// </summary>
        /// <param name="year">
        /// year to count weeks in
        /// </param>
        /// <returns>
        /// the number of weeks in @year
        /// </returns>
        public static System.Byte GetSundayWeeksInYear(
            GISharp.GLib.DateYear year)
        {
            return default(System.Byte);
        }

        /// <summary>
        /// Returns %TRUE if the year is a leap year.
        /// </summary>
        /// <remarks>
        /// For the purposes of this function, leap year is every year
        /// divisible by 4 unless that year is divisible by 100. If it
        /// is divisible by 100 it would be a leap year only if that year
        /// is also divisible by 400.
        /// </remarks>
        /// <param name="year">
        /// year to check
        /// </param>
        /// <returns>
        /// %TRUE if the year is a leap year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_is_leap_year(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Returns %TRUE if the year is a leap year.
        /// </summary>
        /// <remarks>
        /// For the purposes of this function, leap year is every year
        /// divisible by 4 unless that year is divisible by 100. If it
        /// is divisible by 100 it would be a leap year only if that year
        /// is also divisible by 400.
        /// </remarks>
        /// <param name="year">
        /// year to check
        /// </param>
        /// <returns>
        /// %TRUE if the year is a leap year
        /// </returns>
        public static System.Boolean IsLeapYear(
            GISharp.GLib.DateYear year)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Generates a printed representation of the date, in a
        /// [locale][setlocale]-specific way.
        /// Works just like the platform's C library strftime() function,
        /// but only accepts date-related formats; time-related formats
        /// give undefined results. Date must be valid. Unlike strftime()
        /// (which uses the locale encoding), works on a UTF-8 format
        /// string and stores a UTF-8 result.
        /// </summary>
        /// <remarks>
        /// This function does not provide any conversion specifiers in
        /// addition to those implemented by the platform's C library.
        /// For example, don't expect that using g_date_strftime() would
        /// make the \%F provided by the C99 strftime() work on Windows
        /// where the C library only complies to C89.
        /// </remarks>
        /// <param name="s">
        /// destination buffer
        /// </param>
        /// <param name="slen">
        /// buffer size
        /// </param>
        /// <param name="format">
        /// format string
        /// </param>
        /// <param name="date">
        /// valid #GDate
        /// </param>
        /// <returns>
        /// number of characters written to the buffer, or 0 the buffer was too small
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt64 g_date_strftime(
            [System.Runtime.InteropServices.In()] System.IntPtr s,
            [System.Runtime.InteropServices.In()] System.UInt64 slen,
            [System.Runtime.InteropServices.In()] System.IntPtr format,
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Generates a printed representation of the date, in a
        /// [locale][setlocale]-specific way.
        /// Works just like the platform's C library strftime() function,
        /// but only accepts date-related formats; time-related formats
        /// give undefined results. Date must be valid. Unlike strftime()
        /// (which uses the locale encoding), works on a UTF-8 format
        /// string and stores a UTF-8 result.
        /// </summary>
        /// <remarks>
        /// This function does not provide any conversion specifiers in
        /// addition to those implemented by the platform's C library.
        /// For example, don't expect that using g_date_strftime() would
        /// make the \%F provided by the C99 strftime() work on Windows
        /// where the C library only complies to C89.
        /// </remarks>
        /// <param name="s">
        /// destination buffer
        /// </param>
        /// <param name="slen">
        /// buffer size
        /// </param>
        /// <param name="format">
        /// format string
        /// </param>
        /// <param name="date">
        /// valid #GDate
        /// </param>
        /// <returns>
        /// number of characters written to the buffer, or 0 the buffer was too small
        /// </returns>
        public static System.UInt64 Strftime(
            System.String s,
            System.UInt64 slen,
            System.String format,
            GISharp.GLib.Date date)
        {
            return default(System.UInt64);
        }

        /// <summary>
        /// Returns %TRUE if the day of the month is valid (a day is valid if it's
        /// between 1 and 31 inclusive).
        /// </summary>
        /// <param name="day">
        /// day to check
        /// </param>
        /// <returns>
        /// %TRUE if the day is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid_day(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateDay day);

        /// <summary>
        /// Returns %TRUE if the day of the month is valid (a day is valid if it's
        /// between 1 and 31 inclusive).
        /// </summary>
        /// <param name="day">
        /// day to check
        /// </param>
        /// <returns>
        /// %TRUE if the day is valid
        /// </returns>
        public static System.Boolean ValidDay(
            GISharp.GLib.DateDay day)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns %TRUE if the day-month-year triplet forms a valid, existing day
        /// in the range of days #GDate understands (Year 1 or later, no more than
        /// a few thousand years in the future).
        /// </summary>
        /// <param name="day">
        /// day
        /// </param>
        /// <param name="month">
        /// month
        /// </param>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// %TRUE if the date is a valid one
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid_dmy(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateDay day,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateMonth month,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Returns %TRUE if the day-month-year triplet forms a valid, existing day
        /// in the range of days #GDate understands (Year 1 or later, no more than
        /// a few thousand years in the future).
        /// </summary>
        /// <param name="day">
        /// day
        /// </param>
        /// <param name="month">
        /// month
        /// </param>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// %TRUE if the date is a valid one
        /// </returns>
        public static System.Boolean ValidDmy(
            GISharp.GLib.DateDay day,
            GISharp.GLib.DateMonth month,
            GISharp.GLib.DateYear year)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns %TRUE if the Julian day is valid. Anything greater than zero
        /// is basically a valid Julian, though there is a 32-bit limit.
        /// </summary>
        /// <param name="julianDate">
        /// Julian day to check
        /// </param>
        /// <returns>
        /// %TRUE if the Julian day is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid_julian(
            [System.Runtime.InteropServices.In()] System.UInt32 julianDate);

        /// <summary>
        /// Returns %TRUE if the Julian day is valid. Anything greater than zero
        /// is basically a valid Julian, though there is a 32-bit limit.
        /// </summary>
        /// <param name="julianDate">
        /// Julian day to check
        /// </param>
        /// <returns>
        /// %TRUE if the Julian day is valid
        /// </returns>
        public static System.Boolean ValidJulian(
            System.UInt32 julianDate)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns %TRUE if the month value is valid. The 12 #GDateMonth
        /// enumeration values are the only valid months.
        /// </summary>
        /// <param name="month">
        /// month
        /// </param>
        /// <returns>
        /// %TRUE if the month is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid_month(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateMonth month);

        /// <summary>
        /// Returns %TRUE if the month value is valid. The 12 #GDateMonth
        /// enumeration values are the only valid months.
        /// </summary>
        /// <param name="month">
        /// month
        /// </param>
        /// <returns>
        /// %TRUE if the month is valid
        /// </returns>
        public static System.Boolean ValidMonth(
            GISharp.GLib.DateMonth month)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
        /// values are the only valid weekdays.
        /// </summary>
        /// <param name="weekday">
        /// weekday
        /// </param>
        /// <returns>
        /// %TRUE if the weekday is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid_weekday(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateWeekday weekday);

        /// <summary>
        /// Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
        /// values are the only valid weekdays.
        /// </summary>
        /// <param name="weekday">
        /// weekday
        /// </param>
        /// <returns>
        /// %TRUE if the weekday is valid
        /// </returns>
        public static System.Boolean ValidWeekday(
            GISharp.GLib.DateWeekday weekday)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns %TRUE if the year is valid. Any year greater than 0 is valid,
        /// though there is a 16-bit limit to what #GDate will understand.
        /// </summary>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// %TRUE if the year is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid_year(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Returns %TRUE if the year is valid. Any year greater than 0 is valid,
        /// though there is a 16-bit limit to what #GDate will understand.
        /// </summary>
        /// <param name="year">
        /// year
        /// </param>
        /// <returns>
        /// %TRUE if the year is valid
        /// </returns>
        public static System.Boolean ValidYear(
            GISharp.GLib.DateYear year)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Increments a date some number of days.
        /// To move forward by weeks, add weeks*7 days.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to increment
        /// </param>
        /// <param name="nDays">
        /// number of days to move the date forward
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_add_days(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nDays);

        /// <summary>
        /// Increments a date some number of days.
        /// To move forward by weeks, add weeks*7 days.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to increment
        /// </param>
        /// <param name="nDays">
        /// number of days to move the date forward
        /// </param>
        public void AddDays(
            System.UInt32 nDays)
        {
        }

        /// <summary>
        /// Increments a date by some number of months.
        /// If the day of the month is greater than 28,
        /// this routine may change the day of the month
        /// (because the destination month may not have
        /// the current day in it). The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to increment
        /// </param>
        /// <param name="nMonths">
        /// number of months to move forward
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_add_months(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nMonths);

        /// <summary>
        /// Increments a date by some number of months.
        /// If the day of the month is greater than 28,
        /// this routine may change the day of the month
        /// (because the destination month may not have
        /// the current day in it). The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to increment
        /// </param>
        /// <param name="nMonths">
        /// number of months to move forward
        /// </param>
        public void AddMonths(
            System.UInt32 nMonths)
        {
        }

        /// <summary>
        /// Increments a date by some number of years.
        /// If the date is February 29, and the destination
        /// year is not a leap year, the date will be changed
        /// to February 28. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to increment
        /// </param>
        /// <param name="nYears">
        /// number of years to move forward
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_add_years(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nYears);

        /// <summary>
        /// Increments a date by some number of years.
        /// If the date is February 29, and the destination
        /// year is not a leap year, the date will be changed
        /// to February 28. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to increment
        /// </param>
        /// <param name="nYears">
        /// number of years to move forward
        /// </param>
        public void AddYears(
            System.UInt32 nYears)
        {
        }

        /// <summary>
        /// If @date is prior to @min_date, sets @date equal to @min_date.
        /// If @date falls after @max_date, sets @date equal to @max_date.
        /// Otherwise, @date is unchanged.
        /// Either of @min_date and @max_date may be %NULL.
        /// All non-%NULL dates must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to clamp
        /// </param>
        /// <param name="minDate">
        /// minimum accepted value for @date
        /// </param>
        /// <param name="maxDate">
        /// maximum accepted value for @date
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_clamp(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.IntPtr minDate,
            [System.Runtime.InteropServices.In()] System.IntPtr maxDate);

        /// <summary>
        /// If @date is prior to @min_date, sets @date equal to @min_date.
        /// If @date falls after @max_date, sets @date equal to @max_date.
        /// Otherwise, @date is unchanged.
        /// Either of @min_date and @max_date may be %NULL.
        /// All non-%NULL dates must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to clamp
        /// </param>
        /// <param name="minDate">
        /// minimum accepted value for @date
        /// </param>
        /// <param name="maxDate">
        /// maximum accepted value for @date
        /// </param>
        public void Clamp(
            GISharp.GLib.Date minDate,
            GISharp.GLib.Date maxDate)
        {
        }

        /// <summary>
        /// Initializes one or more #GDate structs to a sane but invalid
        /// state. The cleared dates will not represent an existing date, but will
        /// not contain garbage. Useful to init a date declared on the stack.
        /// Validity can be tested with g_date_valid().
        /// </summary>
        /// <param name="date">
        /// pointer to one or more dates to clear
        /// </param>
        /// <param name="nDates">
        /// number of dates to clear
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_clear(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nDates);

        /// <summary>
        /// Initializes one or more #GDate structs to a sane but invalid
        /// state. The cleared dates will not represent an existing date, but will
        /// not contain garbage. Useful to init a date declared on the stack.
        /// Validity can be tested with g_date_valid().
        /// </summary>
        /// <param name="date">
        /// pointer to one or more dates to clear
        /// </param>
        /// <param name="nDates">
        /// number of dates to clear
        /// </param>
        public void Clear(
            System.UInt32 nDates)
        {
        }

        /// <summary>
        /// qsort()-style comparison function for dates.
        /// Both dates must be valid.
        /// </summary>
        /// <param name="lhs">
        /// first date to compare
        /// </param>
        /// <param name="rhs">
        /// second date to compare
        /// </param>
        /// <returns>
        /// 0 for equal, less than zero if @lhs is less than @rhs,
        ///     greater than zero if @lhs is greater than @rhs
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_date_compare(
            [System.Runtime.InteropServices.In()] System.IntPtr lhs,
            [System.Runtime.InteropServices.In()] System.IntPtr rhs);

        /// <summary>
        /// qsort()-style comparison function for dates.
        /// Both dates must be valid.
        /// </summary>
        /// <param name="lhs">
        /// first date to compare
        /// </param>
        /// <param name="rhs">
        /// second date to compare
        /// </param>
        /// <returns>
        /// 0 for equal, less than zero if @lhs is less than @rhs,
        ///     greater than zero if @lhs is greater than @rhs
        /// </returns>
        public System.Int32 CompareTo(
            GISharp.GLib.Date rhs)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Computes the number of days between two dates.
        /// If @date2 is prior to @date1, the returned value is negative.
        /// Both dates must be valid.
        /// </summary>
        /// <param name="date1">
        /// the first date
        /// </param>
        /// <param name="date2">
        /// the second date
        /// </param>
        /// <returns>
        /// the number of days between @date1 and @date2
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_date_days_between(
            [System.Runtime.InteropServices.In()] System.IntPtr date1,
            [System.Runtime.InteropServices.In()] System.IntPtr date2);

        /// <summary>
        /// Computes the number of days between two dates.
        /// If @date2 is prior to @date1, the returned value is negative.
        /// Both dates must be valid.
        /// </summary>
        /// <param name="date1">
        /// the first date
        /// </param>
        /// <param name="date2">
        /// the second date
        /// </param>
        /// <returns>
        /// the number of days between @date1 and @date2
        /// </returns>
        public System.Int32 DaysBetween(
            GISharp.GLib.Date date2)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Frees a #GDate returned from g_date_new().
        /// </summary>
        /// <param name="date">
        /// a #GDate to free
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_free(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Frees a #GDate returned from g_date_new().
        /// </summary>
        /// <param name="date">
        /// a #GDate to free
        /// </param>
        protected override void Free()
        {
        }

        /// <summary>
        /// Returns the day of the month. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to extract the day of the month from
        /// </param>
        /// <returns>
        /// day of the month
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.DateDay g_date_get_day(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the day of the year, where Jan 1 is the first day of the
        /// year. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to extract day of year from
        /// </param>
        /// <returns>
        /// day of the year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_date_get_day_of_year(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the week of the year, where weeks are interpreted according
        /// to ISO 8601.
        /// </summary>
        /// <param name="date">
        /// a valid #GDate
        /// </param>
        /// <returns>
        /// ISO 8601 week number of the year.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.UInt32 g_date_get_iso8601_week_of_year(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the Julian day or "serial number" of the #GDate. The
        /// Julian day is simply the number of days since January 1, Year 1; i.e.,
        /// January 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,
        /// etc. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to extract the Julian day from
        /// </param>
        /// <returns>
        /// Julian day
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_date_get_julian(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the week of the year, where weeks are understood to start on
        /// Monday. If the date is before the first Monday of the year, return
        /// 0. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// week of the year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_date_get_monday_week_of_year(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the month of the year. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to get the month from
        /// </param>
        /// <returns>
        /// month of the year as a #GDateMonth
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.DateMonth g_date_get_month(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the week of the year during which this date falls, if weeks
        /// are understood to being on Sunday. The date must be valid. Can return
        /// 0 if the day is before the first Sunday of the year.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// week number
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_date_get_sunday_week_of_year(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the day of the week for a #GDate. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// day of the week as a #GDateWeekday.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.DateWeekday g_date_get_weekday(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns the year of a #GDate. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <returns>
        /// year in which the date falls
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.DateYear g_date_get_year(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns %TRUE if the date is on the first of a month.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to check
        /// </param>
        /// <returns>
        /// %TRUE if the date is the first of the month
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_is_first_of_month(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns %TRUE if the date is the last day of the month.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to check
        /// </param>
        /// <returns>
        /// %TRUE if the date is the last day of the month
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_is_last_of_month(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Checks if @date1 is less than or equal to @date2,
        /// and swap the values if this is not the case.
        /// </summary>
        /// <param name="date1">
        /// the first date
        /// </param>
        /// <param name="date2">
        /// the second date
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_order(
            [System.Runtime.InteropServices.In()] System.IntPtr date1,
            [System.Runtime.InteropServices.In()] System.IntPtr date2);

        /// <summary>
        /// Checks if @date1 is less than or equal to @date2,
        /// and swap the values if this is not the case.
        /// </summary>
        /// <param name="date1">
        /// the first date
        /// </param>
        /// <param name="date2">
        /// the second date
        /// </param>
        public void Order(
            GISharp.GLib.Date date2)
        {
        }

        /// <summary>
        /// Sets the day of the month for a #GDate. If the resulting
        /// day-month-year triplet is invalid, the date will be invalid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="day">
        /// day to set
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_set_day(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateDay day);

        /// <summary>
        /// Sets the value of a #GDate from a day, month, and year.
        /// The day-month-year triplet must be valid; if you aren't
        /// sure it is, call g_date_valid_dmy() to check before you
        /// set it.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="day">
        /// day
        /// </param>
        /// <param name="month">
        /// month
        /// </param>
        /// <param name="y">
        /// year
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_set_dmy(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateDay day,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateMonth month,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear y);

        /// <summary>
        /// Sets the value of a #GDate from a day, month, and year.
        /// The day-month-year triplet must be valid; if you aren't
        /// sure it is, call g_date_valid_dmy() to check before you
        /// set it.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="day">
        /// day
        /// </param>
        /// <param name="month">
        /// month
        /// </param>
        /// <param name="y">
        /// year
        /// </param>
        public void SetDmy(
            GISharp.GLib.DateDay day,
            GISharp.GLib.DateMonth month,
            GISharp.GLib.DateYear y)
        {
        }

        /// <summary>
        /// Sets the value of a #GDate from a Julian day number.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="julianDate">
        /// Julian day number (days since January 1, Year 1)
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_set_julian(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 julianDate);

        /// <summary>
        /// Sets the month of the year for a #GDate.  If the resulting
        /// day-month-year triplet is invalid, the date will be invalid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="month">
        /// month to set
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_set_month(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateMonth month);

        /// <summary>
        /// Parses a user-inputted string @str, and try to figure out what date it
        /// represents, taking the [current locale][setlocale] into account. If the
        /// string is successfully parsed, the date will be valid after the call.
        /// Otherwise, it will be invalid. You should check using g_date_valid()
        /// to see whether the parsing succeeded.
        /// </summary>
        /// <remarks>
        /// This function is not appropriate for file formats and the like; it
        /// isn't very precise, and its exact behavior varies with the locale.
        /// It's intended to be a heuristic routine that guesses what the user
        /// means by a given string (and it does work pretty well in that
        /// capacity).
        /// </remarks>
        /// <param name="date">
        /// a #GDate to fill in
        /// </param>
        /// <param name="str">
        /// string to parse
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_set_parse(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.IntPtr str);

        /// <summary>
        /// Parses a user-inputted string @str, and try to figure out what date it
        /// represents, taking the [current locale][setlocale] into account. If the
        /// string is successfully parsed, the date will be valid after the call.
        /// Otherwise, it will be invalid. You should check using g_date_valid()
        /// to see whether the parsing succeeded.
        /// </summary>
        /// <remarks>
        /// This function is not appropriate for file formats and the like; it
        /// isn't very precise, and its exact behavior varies with the locale.
        /// It's intended to be a heuristic routine that guesses what the user
        /// means by a given string (and it does work pretty well in that
        /// capacity).
        /// </remarks>
        /// <param name="date">
        /// a #GDate to fill in
        /// </param>
        /// <param name="str">
        /// string to parse
        /// </param>
        public void SetParse(
            System.String str)
        {
        }

        /// <summary>
        /// Sets the value of a date from a #GTimeVal value.  Note that the
        /// @tv_usec member is ignored, because #GDate can't make use of the
        /// additional precision.
        /// </summary>
        /// <remarks>
        /// The time to date conversion is done using the user's current timezone.
        /// </remarks>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="timeval">
        /// #GTimeVal value to set
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.10")]
        static extern void g_date_set_time_val(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal timeval);

        /// <summary>
        /// Sets the value of a date from a #GTimeVal value.  Note that the
        /// @tv_usec member is ignored, because #GDate can't make use of the
        /// additional precision.
        /// </summary>
        /// <remarks>
        /// The time to date conversion is done using the user's current timezone.
        /// </remarks>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="timeval">
        /// #GTimeVal value to set
        /// </param>
        [GISharp.Core.Since("2.10")]
        public void SetTimeVal(
            GISharp.GLib.TimeVal timeval)
        {
        }

        /// <summary>
        /// Sets the year for a #GDate. If the resulting day-month-year
        /// triplet is invalid, the date will be invalid.
        /// </summary>
        /// <param name="date">
        /// a #GDate
        /// </param>
        /// <param name="year">
        /// year to set
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_set_year(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DateYear year);

        /// <summary>
        /// Moves a date some number of days into the past.
        /// To move by weeks, just move by weeks*7 days.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to decrement
        /// </param>
        /// <param name="nDays">
        /// number of days to move
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_subtract_days(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nDays);

        /// <summary>
        /// Moves a date some number of days into the past.
        /// To move by weeks, just move by weeks*7 days.
        /// The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to decrement
        /// </param>
        /// <param name="nDays">
        /// number of days to move
        /// </param>
        public void SubtractDays(
            System.UInt32 nDays)
        {
        }

        /// <summary>
        /// Moves a date some number of months into the past.
        /// If the current day of the month doesn't exist in
        /// the destination month, the day of the month
        /// may change. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to decrement
        /// </param>
        /// <param name="nMonths">
        /// number of months to move
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_subtract_months(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nMonths);

        /// <summary>
        /// Moves a date some number of months into the past.
        /// If the current day of the month doesn't exist in
        /// the destination month, the day of the month
        /// may change. The date must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to decrement
        /// </param>
        /// <param name="nMonths">
        /// number of months to move
        /// </param>
        public void SubtractMonths(
            System.UInt32 nMonths)
        {
        }

        /// <summary>
        /// Moves a date some number of years into the past.
        /// If the current day doesn't exist in the destination
        /// year (i.e. it's February 29 and you move to a non-leap-year)
        /// then the day is changed to February 29. The date
        /// must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to decrement
        /// </param>
        /// <param name="nYears">
        /// number of years to move
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_subtract_years(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.UInt32 nYears);

        /// <summary>
        /// Moves a date some number of years into the past.
        /// If the current day doesn't exist in the destination
        /// year (i.e. it's February 29 and you move to a non-leap-year)
        /// then the day is changed to February 29. The date
        /// must be valid.
        /// </summary>
        /// <param name="date">
        /// a #GDate to decrement
        /// </param>
        /// <param name="nYears">
        /// number of years to move
        /// </param>
        public void SubtractYears(
            System.UInt32 nYears)
        {
        }

        /// <summary>
        /// Fills in the date-related bits of a struct tm using the @date value.
        /// Initializes the non-date parts with something sane but meaningless.
        /// </summary>
        /// <param name="date">
        /// a #GDate to set the struct tm from
        /// </param>
        /// <param name="tm">
        /// struct tm to fill
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_date_to_struct_tm(
            [System.Runtime.InteropServices.In()] System.IntPtr date,
            [System.Runtime.InteropServices.In()] System.IntPtr tm);

        /// <summary>
        /// Fills in the date-related bits of a struct tm using the @date value.
        /// Initializes the non-date parts with something sane but meaningless.
        /// </summary>
        /// <param name="date">
        /// a #GDate to set the struct tm from
        /// </param>
        /// <param name="tm">
        /// struct tm to fill
        /// </param>
        public void ToStructTm(
            System.IntPtr tm)
        {
        }

        /// <summary>
        /// Returns %TRUE if the #GDate represents an existing day. The date must not
        /// contain garbage; it should have been initialized with g_date_clear()
        /// if it wasn't allocated by one of the g_date_new() variants.
        /// </summary>
        /// <param name="date">
        /// a #GDate to check
        /// </param>
        /// <returns>
        /// Whether the date is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_date_valid(
            [System.Runtime.InteropServices.In()] System.IntPtr date);

        /// <summary>
        /// Returns %TRUE if the #GDate represents an existing day. The date must not
        /// contain garbage; it should have been initialized with g_date_clear()
        /// if it wasn't allocated by one of the g_date_new() variants.
        /// </summary>
        /// <param name="date">
        /// a #GDate to check
        /// </param>
        /// <returns>
        /// Whether the date is valid
        /// </returns>
        public System.Boolean Valid()
        {
            return default(System.Boolean);
        }

        public static bool operator <(GISharp.GLib.Date one, GISharp.GLib.Date two)
        {
            return one.CompareTo(two) < 0;
        }

        public static bool operator <=(GISharp.GLib.Date one, GISharp.GLib.Date two)
        {
            return one.CompareTo(two) <= 0;
        }

        public static bool operator >=(GISharp.GLib.Date one, GISharp.GLib.Date two)
        {
            return one.CompareTo(two) >= 0;
        }

        public static bool operator >(GISharp.GLib.Date one, GISharp.GLib.Date two)
        {
            return one.CompareTo(two) > 0;
        }
    }

    /// <summary>
    /// This enumeration isn't used in the API, but may be useful if you need
    /// to mark a number as a day, month, or year.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"DateDMY\" c:type=\"GDateDMY\" gs:managed-name=\"DateDMY\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">This enumeration isn't used in the API, but may be useful if you need\nto mark a number as a day, month, or year.</doc>\n  <member name=\"day\" value=\"0\" c:identifier=\"G_DATE_DAY\" gs:managed-name=\"Day\">\n    <doc xml:space=\"preserve\">a day</doc>\n  </member>\n  <member name=\"month\" value=\"1\" c:identifier=\"G_DATE_MONTH\" gs:managed-name=\"Month\">\n    <doc xml:space=\"preserve\">a month</doc>\n  </member>\n  <member name=\"year\" value=\"2\" c:identifier=\"G_DATE_YEAR\" gs:managed-name=\"Year\">\n    <doc xml:space=\"preserve\">a year</doc>\n  </member>\n</enumeration>")]
    public enum DateDMY
    {
        /// <summary>
        /// a day
        /// </summary>
        Day = 0,
        /// <summary>
        /// a month
        /// </summary>
        Month = 1,
        /// <summary>
        /// a year
        /// </summary>
        Year = 2
    }

    /// <summary>
    /// Enumeration representing a month; values are #G_DATE_JANUARY,
    /// #G_DATE_FEBRUARY, etc. #G_DATE_BAD_MONTH is the invalid value.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"DateMonth\" c:type=\"GDateMonth\" gs:managed-name=\"DateMonth\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Enumeration representing a month; values are #G_DATE_JANUARY,\n#G_DATE_FEBRUARY, etc. #G_DATE_BAD_MONTH is the invalid value.</doc>\n  <member name=\"bad_month\" value=\"0\" c:identifier=\"G_DATE_BAD_MONTH\" gs:managed-name=\"BadMonth\">\n    <doc xml:space=\"preserve\">invalid value</doc>\n  </member>\n  <member name=\"january\" value=\"1\" c:identifier=\"G_DATE_JANUARY\" gs:managed-name=\"January\">\n    <doc xml:space=\"preserve\">January</doc>\n  </member>\n  <member name=\"february\" value=\"2\" c:identifier=\"G_DATE_FEBRUARY\" gs:managed-name=\"February\">\n    <doc xml:space=\"preserve\">February</doc>\n  </member>\n  <member name=\"march\" value=\"3\" c:identifier=\"G_DATE_MARCH\" gs:managed-name=\"March\">\n    <doc xml:space=\"preserve\">March</doc>\n  </member>\n  <member name=\"april\" value=\"4\" c:identifier=\"G_DATE_APRIL\" gs:managed-name=\"April\">\n    <doc xml:space=\"preserve\">April</doc>\n  </member>\n  <member name=\"may\" value=\"5\" c:identifier=\"G_DATE_MAY\" gs:managed-name=\"May\">\n    <doc xml:space=\"preserve\">May</doc>\n  </member>\n  <member name=\"june\" value=\"6\" c:identifier=\"G_DATE_JUNE\" gs:managed-name=\"June\">\n    <doc xml:space=\"preserve\">June</doc>\n  </member>\n  <member name=\"july\" value=\"7\" c:identifier=\"G_DATE_JULY\" gs:managed-name=\"July\">\n    <doc xml:space=\"preserve\">July</doc>\n  </member>\n  <member name=\"august\" value=\"8\" c:identifier=\"G_DATE_AUGUST\" gs:managed-name=\"August\">\n    <doc xml:space=\"preserve\">August</doc>\n  </member>\n  <member name=\"september\" value=\"9\" c:identifier=\"G_DATE_SEPTEMBER\" gs:managed-name=\"September\">\n    <doc xml:space=\"preserve\">September</doc>\n  </member>\n  <member name=\"october\" value=\"10\" c:identifier=\"G_DATE_OCTOBER\" gs:managed-name=\"October\">\n    <doc xml:space=\"preserve\">October</doc>\n  </member>\n  <member name=\"november\" value=\"11\" c:identifier=\"G_DATE_NOVEMBER\" gs:managed-name=\"November\">\n    <doc xml:space=\"preserve\">November</doc>\n  </member>\n  <member name=\"december\" value=\"12\" c:identifier=\"G_DATE_DECEMBER\" gs:managed-name=\"December\">\n    <doc xml:space=\"preserve\">December</doc>\n  </member>\n</enumeration>")]
    public enum DateMonth
    {
        /// <summary>
        /// invalid value
        /// </summary>
        BadMonth = 0,
        /// <summary>
        /// January
        /// </summary>
        January = 1,
        /// <summary>
        /// February
        /// </summary>
        February = 2,
        /// <summary>
        /// March
        /// </summary>
        March = 3,
        /// <summary>
        /// April
        /// </summary>
        April = 4,
        /// <summary>
        /// May
        /// </summary>
        May = 5,
        /// <summary>
        /// June
        /// </summary>
        June = 6,
        /// <summary>
        /// July
        /// </summary>
        July = 7,
        /// <summary>
        /// August
        /// </summary>
        August = 8,
        /// <summary>
        /// September
        /// </summary>
        September = 9,
        /// <summary>
        /// October
        /// </summary>
        October = 10,
        /// <summary>
        /// November
        /// </summary>
        November = 11,
        /// <summary>
        /// December
        /// </summary>
        December = 12
    }

    /// <summary>
    /// `GDateTime` is an opaque structure whose members
    /// cannot be accessed directly.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"DateTime\" c:type=\"GDateTime\" version=\"2.26\" glib:type-name=\"GDateTime\" glib:get-type=\"g_date_time_get_type\" c:symbol-prefix=\"date_time\" gs:managed-name=\"DateTime\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">`GDateTime` is an opaque structure whose members\ncannot be accessed directly.</doc>\n  <constructor name=\"new\" c:identifier=\"g_date_time_new\" version=\"2.26\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GDateTime corresponding to the given date and time in\nthe time zone @tz.\n\nThe @year must be between 1 and 9999, @month between 1 and 12 and @day\nbetween 1 and 28, 29, 30 or 31 depending on the month and the year.\n\n@hour must be between 0 and 23 and @minute must be between 0 and 59.\n\n@seconds must be at least 0.0 and must be strictly less than 60.0.\nIt will be rounded down to the nearest microsecond.\n\nIf the given time is not representable in the given time zone (for\nexample, 02:30 on March 14th 2010 in Toronto, due to daylight savings\ntime) then the time will be rounded up to the nearest existing time\n(in this case, 03:00).  If this matters to you then you should verify\nthe return value for containing the same as the numbers you gave.\n\nIn the case that the given time is ambiguous in the given time zone\n(for example, 01:30 on November 7th 2010 in Toronto, due to daylight\nsavings time) then the time falling within standard (ie:\nnon-daylight) time is taken.\n\nIt not considered a programmer error for the values to this function\nto be out of range, but in the case that they are, the function will\nreturn %NULL.\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the year component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the month component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the day component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hour\" transfer-ownership=\"none\" gs:managed-name=\"hour\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the hour component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minute\" transfer-ownership=\"none\" gs:managed-name=\"minute\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the minute component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds past the minute</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </parameter>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the year component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the month component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the day component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hour\" transfer-ownership=\"none\" gs:managed-name=\"hour\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the hour component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minute\" transfer-ownership=\"none\" gs:managed-name=\"minute\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the minute component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds past the minute</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <function name=\"from_timeval_local\" c:identifier=\"g_date_time_new_from_timeval_local\" version=\"2.26\" gs:managed-name=\"FromTimevalLocal\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to the given #GTimeVal @tv in the\nlocal time zone.\n\nThe time contained in a #GTimeVal is always stored in the form of\nseconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the\nlocal time offset.\n\nThis call can fail (returning %NULL) if @tv represents a time outside\nof the supported range of #GDateTime.\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"tv\" transfer-ownership=\"none\" gs:managed-name=\"tv\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"const GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tv\" transfer-ownership=\"none\" gs:managed-name=\"tv\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"const GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"from_timeval_utc\" c:identifier=\"g_date_time_new_from_timeval_utc\" version=\"2.26\" gs:managed-name=\"FromTimevalUtc\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.\n\nThe time contained in a #GTimeVal is always stored in the form of\nseconds elapsed since 1970-01-01 00:00:00 UTC.\n\nThis call can fail (returning %NULL) if @tv represents a time outside\nof the supported range of #GDateTime.\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"tv\" transfer-ownership=\"none\" gs:managed-name=\"tv\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"const GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tv\" transfer-ownership=\"none\" gs:managed-name=\"tv\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"const GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"from_unix_local\" c:identifier=\"g_date_time_new_from_unix_local\" version=\"2.26\" gs:managed-name=\"FromUnixLocal\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to the given Unix time @t in the\nlocal time zone.\n\nUnix time is the number of seconds that have elapsed since 1970-01-01\n00:00:00 UTC, regardless of the local time offset.\n\nThis call can fail (returning %NULL) if @t represents a time outside\nof the supported range of #GDateTime.\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"t\" transfer-ownership=\"none\" gs:managed-name=\"t\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the Unix time</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"t\" transfer-ownership=\"none\" gs:managed-name=\"t\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the Unix time</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"from_unix_utc\" c:identifier=\"g_date_time_new_from_unix_utc\" version=\"2.26\" gs:managed-name=\"FromUnixUtc\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to the given Unix time @t in UTC.\n\nUnix time is the number of seconds that have elapsed since 1970-01-01\n00:00:00 UTC.\n\nThis call can fail (returning %NULL) if @t represents a time outside\nof the supported range of #GDateTime.\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"t\" transfer-ownership=\"none\" gs:managed-name=\"t\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the Unix time</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"t\" transfer-ownership=\"none\" gs:managed-name=\"t\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the Unix time</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"local\" c:identifier=\"g_date_time_new_local\" version=\"2.26\" gs:managed-name=\"Local\">\n    <doc xml:space=\"preserve\">Creates a new #GDateTime corresponding to the given date and time in\nthe local time zone.\n\nThis call is equivalent to calling g_date_time_new() with the time\nzone returned by g_time_zone_new_local().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the year component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the month component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the day component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hour\" transfer-ownership=\"none\" gs:managed-name=\"hour\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the hour component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minute\" transfer-ownership=\"none\" gs:managed-name=\"minute\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the minute component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds past the minute</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the year component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the month component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the day component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hour\" transfer-ownership=\"none\" gs:managed-name=\"hour\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the hour component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minute\" transfer-ownership=\"none\" gs:managed-name=\"minute\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the minute component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds past the minute</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"now\" c:identifier=\"g_date_time_new_now\" version=\"2.26\" gs:managed-name=\"Now\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to this exact instant in the given\ntime zone @tz.  The time is as accurate as the system allows, to a\nmaximum accuracy of 1 microsecond.\n\nThis function will always succeed unless the system clock is set to\ntruly insane values (or unless GLib is still being used after the\nyear 9999).\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"now_local\" c:identifier=\"g_date_time_new_now_local\" version=\"2.26\" gs:managed-name=\"NowLocal\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to this exact instant in the local\ntime zone.\n\nThis is equivalent to calling g_date_time_new_now() with the time\nzone returned by g_time_zone_new_local().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n  </function>\n  <function name=\"now_utc\" c:identifier=\"g_date_time_new_now_utc\" version=\"2.26\" gs:managed-name=\"NowUtc\">\n    <doc xml:space=\"preserve\">Creates a #GDateTime corresponding to this exact instant in UTC.\n\nThis is equivalent to calling g_date_time_new_now() with the time\nzone returned by g_time_zone_new_utc().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n  </function>\n  <function name=\"utc\" c:identifier=\"g_date_time_new_utc\" version=\"2.26\" gs:managed-name=\"Utc\">\n    <doc xml:space=\"preserve\">Creates a new #GDateTime corresponding to the given date and time in\nUTC.\n\nThis call is equivalent to calling g_date_time_new() with the time\nzone returned by g_time_zone_new_utc().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the year component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the month component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the day component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hour\" transfer-ownership=\"none\" gs:managed-name=\"hour\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the hour component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minute\" transfer-ownership=\"none\" gs:managed-name=\"minute\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the minute component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds past the minute</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" transfer-ownership=\"none\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the year component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" transfer-ownership=\"none\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the month component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" transfer-ownership=\"none\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the day component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hour\" transfer-ownership=\"none\" gs:managed-name=\"hour\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the hour component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minute\" transfer-ownership=\"none\" gs:managed-name=\"minute\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the minute component of the date</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds past the minute</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <method name=\"add\" c:identifier=\"g_date_time_add\" version=\"2.26\" gs:managed-name=\"Add\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified timespan to the copy.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"timespan\" transfer-ownership=\"none\" gs:managed-name=\"timespan\" gs:managed-type=\"TimeSpan\" gs:unmanaged-type=\"TimeSpan\">\n        <doc xml:space=\"preserve\">a #GTimeSpan</doc>\n        <type name=\"TimeSpan\" c:type=\"GTimeSpan\" gs:managed-name=\"TimeSpan\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"timespan\" transfer-ownership=\"none\" gs:managed-name=\"timespan\" gs:managed-type=\"TimeSpan\" gs:unmanaged-type=\"TimeSpan\">\n        <doc xml:space=\"preserve\">a #GTimeSpan</doc>\n        <type name=\"TimeSpan\" c:type=\"GTimeSpan\" gs:managed-name=\"TimeSpan\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_days\" c:identifier=\"g_date_time_add_days\" version=\"2.26\" gs:managed-name=\"AddDays\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified number of days to the\ncopy. Add negative values to subtract days.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"days\" transfer-ownership=\"none\" gs:managed-name=\"days\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of days</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"days\" transfer-ownership=\"none\" gs:managed-name=\"days\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of days</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_full\" c:identifier=\"g_date_time_add_full\" version=\"2.26\" gs:managed-name=\"AddFull\">\n    <doc xml:space=\"preserve\">Creates a new #GDateTime adding the specified values to the current date and\ntime in @datetime. Add negative values to subtract.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime that should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"years\" transfer-ownership=\"none\" gs:managed-name=\"years\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of years to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"months\" transfer-ownership=\"none\" gs:managed-name=\"months\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of months to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"days\" transfer-ownership=\"none\" gs:managed-name=\"days\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of days to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hours\" transfer-ownership=\"none\" gs:managed-name=\"hours\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of hours to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minutes\" transfer-ownership=\"none\" gs:managed-name=\"minutes\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of minutes to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds to add</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"years\" transfer-ownership=\"none\" gs:managed-name=\"years\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of years to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"months\" transfer-ownership=\"none\" gs:managed-name=\"months\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of months to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"days\" transfer-ownership=\"none\" gs:managed-name=\"days\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of days to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"hours\" transfer-ownership=\"none\" gs:managed-name=\"hours\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of hours to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"minutes\" transfer-ownership=\"none\" gs:managed-name=\"minutes\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of minutes to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds to add</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_hours\" c:identifier=\"g_date_time_add_hours\" version=\"2.26\" gs:managed-name=\"AddHours\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified number of hours.\nAdd negative values to subtract hours.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"hours\" transfer-ownership=\"none\" gs:managed-name=\"hours\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of hours to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"hours\" transfer-ownership=\"none\" gs:managed-name=\"hours\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of hours to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_minutes\" c:identifier=\"g_date_time_add_minutes\" version=\"2.26\" gs:managed-name=\"AddMinutes\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime adding the specified number of minutes.\nAdd negative values to subtract minutes.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"minutes\" transfer-ownership=\"none\" gs:managed-name=\"minutes\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of minutes to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"minutes\" transfer-ownership=\"none\" gs:managed-name=\"minutes\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of minutes to add</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_months\" c:identifier=\"g_date_time_add_months\" version=\"2.26\" gs:managed-name=\"AddMonths\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified number of months to the\ncopy. Add negative values to subtract months.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"months\" transfer-ownership=\"none\" gs:managed-name=\"months\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of months</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"months\" transfer-ownership=\"none\" gs:managed-name=\"months\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of months</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_seconds\" c:identifier=\"g_date_time_add_seconds\" version=\"2.26\" gs:managed-name=\"AddSeconds\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified number of seconds.\nAdd negative values to subtract seconds.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds to add</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"seconds\" transfer-ownership=\"none\" gs:managed-name=\"seconds\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">the number of seconds to add</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_weeks\" c:identifier=\"g_date_time_add_weeks\" version=\"2.26\" gs:managed-name=\"AddWeeks\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified number of weeks to the\ncopy. Add negative values to subtract weeks.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"weeks\" transfer-ownership=\"none\" gs:managed-name=\"weeks\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of weeks</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"weeks\" transfer-ownership=\"none\" gs:managed-name=\"weeks\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of weeks</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_years\" c:identifier=\"g_date_time_add_years\" version=\"2.26\" gs:managed-name=\"AddYears\">\n    <doc xml:space=\"preserve\">Creates a copy of @datetime and adds the specified number of years to the\ncopy. Add negative values to subtract years.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime which should be freed with\n  g_date_time_unref().</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"years\" transfer-ownership=\"none\" gs:managed-name=\"years\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of years</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"years\" transfer-ownership=\"none\" gs:managed-name=\"years\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the number of years</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"difference\" c:identifier=\"g_date_time_difference\" version=\"2.26\" gs:managed-name=\"Difference\">\n    <doc xml:space=\"preserve\">Calculates the difference in time between @end and @begin.  The\n#GTimeSpan that is returned is effectively @end - @begin (ie:\npositive if the first parameter is larger).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"TimeSpan\" gs:unmanaged-type=\"TimeSpan\">\n      <doc xml:space=\"preserve\">the difference between the two #GDateTime, as a time\n  span expressed in microseconds.</doc>\n      <type name=\"TimeSpan\" c:type=\"GTimeSpan\" gs:managed-name=\"TimeSpan\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"format\" c:identifier=\"g_date_time_format\" version=\"2.26\" gs:managed-name=\"Format\">\n    <doc xml:space=\"preserve\">Creates a newly allocated string representing the requested @format.\n\nThe format strings understood by this function are a subset of the\nstrftime() format language as specified by C99.  The \\%D, \\%U and \\%W\nconversions are not supported, nor is the 'E' modifier.  The GNU\nextensions \\%k, \\%l, \\%s and \\%P are supported, however, as are the\n'0', '_' and '-' modifiers.\n\nIn contrast to strftime(), this function always produces a UTF-8\nstring, regardless of the current locale.  Note that the rendering of\nmany formats is locale-dependent and may not match the strftime()\noutput exactly.\n\nThe following format specifiers are supported:\n\n- \\%a: the abbreviated weekday name according to the current locale\n- \\%A: the full weekday name according to the current locale\n- \\%b: the abbreviated month name according to the current locale\n- \\%B: the full month name according to the current locale\n- \\%c: the  preferred date and time rpresentation for the current locale\n- \\%C: the century number (year/100) as a 2-digit integer (00-99)\n- \\%d: the day of the month as a decimal number (range 01 to 31)\n- \\%e: the day of the month as a decimal number (range  1 to 31)\n- \\%F: equivalent to `%Y-%m-%d` (the ISO 8601 date format)\n- \\%g: the last two digits of the ISO 8601 week-based year as a\n  decimal number (00-99). This works well with \\%V and \\%u.\n- \\%G: the ISO 8601 week-based year as a decimal number. This works\n  well with \\%V and \\%u.\n- \\%h: equivalent to \\%b\n- \\%H: the hour as a decimal number using a 24-hour clock (range 00 to 23)\n- \\%I: the hour as a decimal number using a 12-hour clock (range 01 to 12)\n- \\%j: the day of the year as a decimal number (range 001 to 366)\n- \\%k: the hour (24-hour clock) as a decimal number (range 0 to 23);\n  single digits are preceded by a blank\n- \\%l: the hour (12-hour clock) as a decimal number (range 1 to 12);\n  single digits are preceded by a blank\n- \\%m: the month as a decimal number (range 01 to 12)\n- \\%M: the minute as a decimal number (range 00 to 59)\n- \\%p: either \"AM\" or \"PM\" according to the given time value, or the\n  corresponding  strings for the current locale.  Noon is treated as\n  \"PM\" and midnight as \"AM\".\n- \\%P: like \\%p but lowercase: \"am\" or \"pm\" or a corresponding string for\n  the current locale\n- \\%r: the time in a.m. or p.m. notation\n- \\%R: the time in 24-hour notation (\\%H:\\%M)\n- \\%s: the number of seconds since the Epoch, that is, since 1970-01-01\n  00:00:00 UTC\n- \\%S: the second as a decimal number (range 00 to 60)\n- \\%t: a tab character\n- \\%T: the time in 24-hour notation with seconds (\\%H:\\%M:\\%S)\n- \\%u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,\n   Monday being 1. This works well with \\%G and \\%V.\n- \\%V: the ISO 8601 standard week number of the current year as a decimal\n  number, range 01 to 53, where week 1 is the first week that has at\n  least 4 days in the new year. See g_date_time_get_week_of_year().\n  This works well with \\%G and \\%u.\n- \\%w: the day of the week as a decimal, range 0 to 6, Sunday being 0.\n  This is not the ISO 8601 standard format -- use \\%u instead.\n- \\%x: the preferred date representation for the current locale without\n  the time\n- \\%X: the preferred time representation for the current locale without\n  the date\n- \\%y: the year as a decimal number without the century\n- \\%Y: the year as a decimal number including the century\n- \\%z: the time zone as an offset from UTC (+hhmm)\n- \\%:z: the time zone as an offset from UTC (+hh:mm).\n  This is a gnulib strftime() extension. Since: 2.38\n- \\%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a\n  gnulib strftime() extension. Since: 2.38\n- \\%:::z: the time zone as an offset from UTC, with : to necessary\n  precision (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38\n- \\%Z: the time zone or name or abbreviation\n- \\%\\%: a literal \\% character\n\nSome conversion specifications can be modified by preceding the\nconversion specifier by one or more modifier characters. The\nfollowing modifiers are supported for many of the numeric\nconversions:\n\n- O: Use alternative numeric symbols, if the current locale supports those.\n- _: Pad a numeric result with spaces. This overrides the default padding\n  for the specifier.\n- -: Do not pad a numeric result. This overrides the default padding\n  for the specifier.\n- 0: Pad a numeric result with zeros. This overrides the default padding\n  for the specifier.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated string formatted to the requested format\n    or %NULL in the case that there was an error. The string\n    should be freed with g_free().</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid UTF-8 string, containing the format for the\n         #GDateTime</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid UTF-8 string, containing the format for the\n         #GDateTime</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_day_of_month\" c:identifier=\"g_date_time_get_day_of_month\" version=\"2.26\" gs:managed-name=\"get_DayOfMonth\" gs:property=\"DayOfMonth\">\n    <doc xml:space=\"preserve\">Retrieves the day of the month represented by @datetime in the gregorian\ncalendar.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the day of the month</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_day_of_week\" c:identifier=\"g_date_time_get_day_of_week\" version=\"2.26\" gs:managed-name=\"get_DayOfWeek\" gs:property=\"DayOfWeek\">\n    <doc xml:space=\"preserve\">Retrieves the ISO 8601 day of the week on which @datetime falls (1 is\nMonday, 2 is Tuesday... 7 is Sunday).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the day of the week</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_day_of_year\" c:identifier=\"g_date_time_get_day_of_year\" version=\"2.26\" gs:managed-name=\"get_DayOfYear\" gs:property=\"DayOfYear\">\n    <doc xml:space=\"preserve\">Retrieves the day of the year represented by @datetime in the Gregorian\ncalendar.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the day of the year</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_hour\" c:identifier=\"g_date_time_get_hour\" version=\"2.26\" gs:managed-name=\"get_Hour\" gs:property=\"Hour\">\n    <doc xml:space=\"preserve\">Retrieves the hour of the day represented by @datetime</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the hour of the day</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_microsecond\" c:identifier=\"g_date_time_get_microsecond\" version=\"2.26\" gs:managed-name=\"get_Microsecond\" gs:property=\"Microsecond\">\n    <doc xml:space=\"preserve\">Retrieves the microsecond of the date represented by @datetime</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the microsecond of the second</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_minute\" c:identifier=\"g_date_time_get_minute\" version=\"2.26\" gs:managed-name=\"get_Minute\" gs:property=\"Minute\">\n    <doc xml:space=\"preserve\">Retrieves the minute of the hour represented by @datetime</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the minute of the hour</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_month\" c:identifier=\"g_date_time_get_month\" version=\"2.26\" gs:managed-name=\"get_Month\" gs:property=\"Month\">\n    <doc xml:space=\"preserve\">Retrieves the month of the year represented by @datetime in the Gregorian\ncalendar.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the month represented by @datetime</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_second\" c:identifier=\"g_date_time_get_second\" version=\"2.26\" gs:managed-name=\"get_Second\" gs:property=\"Second\">\n    <doc xml:space=\"preserve\">Retrieves the second of the minute represented by @datetime</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the second represented by @datetime</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_seconds\" c:identifier=\"g_date_time_get_seconds\" version=\"2.26\" gs:managed-name=\"get_Seconds\" gs:property=\"Seconds\">\n    <doc xml:space=\"preserve\">Retrieves the number of seconds since the start of the last minute,\nincluding the fractional part.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n      <doc xml:space=\"preserve\">the number of seconds</doc>\n      <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_timezone_abbreviation\" c:identifier=\"g_date_time_get_timezone_abbreviation\" version=\"2.26\" gs:managed-name=\"get_TimezoneAbbreviation\" gs:property=\"TimezoneAbbreviation\">\n    <doc xml:space=\"preserve\">Determines the time zone abbreviation to be used at the time and in\nthe time zone of @datetime.\n\nFor example, in Toronto this is currently \"EST\" during the winter\nmonths and \"EDT\" during the summer months when daylight savings\ntime is in effect.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the time zone abbreviation. The returned\n         string is owned by the #GDateTime and it should not be\n         modified or freed</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_utc_offset\" c:identifier=\"g_date_time_get_utc_offset\" version=\"2.26\" gs:managed-name=\"get_UtcOffset\" gs:property=\"UtcOffset\">\n    <doc xml:space=\"preserve\">Determines the offset to UTC in effect at the time and in the time\nzone of @datetime.\n\nThe offset is the number of microseconds that you add to UTC time to\narrive at local time for the time zone (ie: negative numbers for time\nzones west of GMT, positive numbers for east).\n\nIf @datetime represents UTC time, then the offset is always zero.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"TimeSpan\" gs:unmanaged-type=\"TimeSpan\">\n      <doc xml:space=\"preserve\">the number of microseconds that should be added to UTC to\n         get the local time</doc>\n      <type name=\"TimeSpan\" c:type=\"GTimeSpan\" gs:managed-name=\"TimeSpan\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_week_numbering_year\" c:identifier=\"g_date_time_get_week_numbering_year\" version=\"2.26\" gs:managed-name=\"get_WeekNumberingYear\" gs:property=\"WeekNumberingYear\">\n    <doc xml:space=\"preserve\">Returns the ISO 8601 week-numbering year in which the week containing\n@datetime falls.\n\nThis function, taken together with g_date_time_get_week_of_year() and\ng_date_time_get_day_of_week() can be used to determine the full ISO\nweek date on which @datetime falls.\n\nThis is usually equal to the normal Gregorian year (as returned by\ng_date_time_get_year()), except as detailed below:\n\nFor Thursday, the week-numbering year is always equal to the usual\ncalendar year.  For other days, the number is such that every day\nwithin a complete week (Monday to Sunday) is contained within the\nsame week-numbering year.\n\nFor Monday, Tuesday and Wednesday occurring near the end of the year,\nthis may mean that the week-numbering year is one greater than the\ncalendar year (so that these days have the same week-numbering year\nas the Thursday occurring early in the next year).\n\nFor Friday, Saturaday and Sunday occurring near the start of the year,\nthis may mean that the week-numbering year is one less than the\ncalendar year (so that these days have the same week-numbering year\nas the Thursday occurring late in the previous year).\n\nAn equivalent description is that the week-numbering year is equal to\nthe calendar year containing the majority of the days in the current\nweek (Monday to Sunday).\n\nNote that January 1 0001 in the proleptic Gregorian calendar is a\nMonday, so this function never returns 0.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the ISO 8601 week-numbering year for @datetime</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_week_of_year\" c:identifier=\"g_date_time_get_week_of_year\" version=\"2.26\" gs:managed-name=\"get_WeekOfYear\" gs:property=\"WeekOfYear\">\n    <doc xml:space=\"preserve\">Returns the ISO 8601 week number for the week containing @datetime.\nThe ISO 8601 week number is the same for every day of the week (from\nModay through Sunday).  That can produce some unusual results\n(described below).\n\nThe first week of the year is week 1.  This is the week that contains\nthe first Thursday of the year.  Equivalently, this is the first week\nthat has more than 4 of its days falling within the calendar year.\n\nThe value 0 is never returned by this function.  Days contained\nwithin a year but occurring before the first ISO 8601 week of that\nyear are considered as being contained in the last week of the\nprevious year.  Similarly, the final days of a calendar year may be\nconsidered as being part of the first ISO 8601 week of the next year\nif 4 or more days of that week are contained within the new year.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the ISO 8601 week number for @datetime.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_year\" c:identifier=\"g_date_time_get_year\" version=\"2.26\" gs:managed-name=\"get_Year\" gs:property=\"Year\">\n    <doc xml:space=\"preserve\">Retrieves the year represented by @datetime in the Gregorian calendar.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the year represented by @datetime</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_ymd\" c:identifier=\"g_date_time_get_ymd\" version=\"2.26\" gs:managed-name=\"GetYmd\">\n    <doc xml:space=\"preserve\">Retrieves the Gregorian day, month, and year of a given #GDateTime.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime.</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"year\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the return location for the gregorian year, or %NULL.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the return location for the month of the year, or %NULL.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the return location for the day of the month, or %NULL.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"year\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"year\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the return location for the gregorian year, or %NULL.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"month\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"month\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the return location for the month of the year, or %NULL.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"day\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"day\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the return location for the day of the month, or %NULL.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"is_daylight_savings\" c:identifier=\"g_date_time_is_daylight_savings\" version=\"2.26\" gs:managed-name=\"get_IsDaylightSavings\" gs:property=\"IsDaylightSavings\">\n    <doc xml:space=\"preserve\">Determines if daylight savings time is in effect at the time and in\nthe time zone of @datetime.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if daylight savings time is in effect</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"ref\" c:identifier=\"g_date_time_ref\" version=\"2.26\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Atomically increments the reference count of @datetime by one.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GDateTime with the reference count increased</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"to_local\" c:identifier=\"g_date_time_to_local\" version=\"2.26\" gs:managed-name=\"ToLocal\">\n    <doc xml:space=\"preserve\">Creates a new #GDateTime corresponding to the same instant in time as\n@datetime, but in the local time zone.\n\nThis call is equivalent to calling g_date_time_to_timezone() with the\ntime zone returned by g_time_zone_new_local().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"to_timeval\" c:identifier=\"g_date_time_to_timeval\" version=\"2.26\" gs:managed-name=\"ToTimeval\">\n    <doc xml:space=\"preserve\">Stores the instant in time that @datetime represents into @tv.\n\nThe time contained in a #GTimeVal is always stored in the form of\nseconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time\nzone associated with @datetime.\n\nOn systems where 'long' is 32bit (ie: all 32bit systems and all\nWindows systems), a #GTimeVal is incapable of storing the entire\nrange of values that #GDateTime is capable of expressing.  On those\nsystems, this function returns %FALSE to indicate that the time is\nout of range.\n\nOn systems where 'long' is 64bit, this function never fails.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if successful, else %FALSE</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"tv\" transfer-ownership=\"none\" gs:managed-name=\"tv\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal to modify</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tv\" transfer-ownership=\"none\" gs:managed-name=\"tv\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal to modify</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"to_timezone\" c:identifier=\"g_date_time_to_timezone\" version=\"2.26\" gs:managed-name=\"ToTimezone\">\n    <doc xml:space=\"preserve\">Create a new #GDateTime corresponding to the same instant in time as\n@datetime, but in the time zone @tz.\n\nThis call can fail in the case that the time goes out of bounds.  For\nexample, converting 0001-01-01 00:00:00 UTC to a time zone west of\nGreenwich will fail (due to the year 0 being out of range).\n\nYou should release the return value by calling g_date_time_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GDateTime, or %NULL</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n      <parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the new #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the new #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"to_unix\" c:identifier=\"g_date_time_to_unix\" version=\"2.26\" gs:managed-name=\"ToUnix\">\n    <doc xml:space=\"preserve\">Gives the Unix time corresponding to @datetime, rounding down to the\nnearest second.\n\nUnix time is the number of seconds that have elapsed since 1970-01-01\n00:00:00 UTC, regardless of the time zone associated with @datetime.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n      <doc xml:space=\"preserve\">the Unix time corresponding to @datetime</doc>\n      <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"to_utc\" c:identifier=\"g_date_time_to_utc\" version=\"2.26\" gs:managed-name=\"ToUtc\">\n    <doc xml:space=\"preserve\">Creates a new #GDateTime corresponding to the same instant in time as\n@datetime, but in UTC.\n\nThis call is equivalent to calling g_date_time_to_timezone() with the\ntime zone returned by g_time_zone_new_utc().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly created #GDateTime</doc>\n      <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref\" c:identifier=\"g_date_time_unref\" version=\"2.26\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Atomically decrements the reference count of @datetime by one.\n\nWhen the reference count reaches zero, the resources allocated by\n@datetime are freed</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"DateTime\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"DateTime\" c:type=\"GDateTime*\" gs:managed-name=\"DateTime\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"compare\" c:identifier=\"g_date_time_compare\" version=\"2.26\" gs:managed-name=\"Compare\">\n    <doc xml:space=\"preserve\">A comparison function for #GDateTimes that is suitable\nas a #GCompareFunc. Both #GDateTimes must be non-%NULL.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">-1, 0 or 1 if @dt1 is less than, equal to or greater\n  than @dt2.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"dt1\" transfer-ownership=\"none\" gs:managed-name=\"dt1\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">first #GDateTime to compare</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"dt2\" transfer-ownership=\"none\" gs:managed-name=\"dt2\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">second #GDateTime to compare</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"dt1\" transfer-ownership=\"none\" gs:managed-name=\"dt1\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">first #GDateTime to compare</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"dt2\" transfer-ownership=\"none\" gs:managed-name=\"dt2\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">second #GDateTime to compare</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"equal\" c:identifier=\"g_date_time_equal\" version=\"2.26\" gs:managed-name=\"Equal\">\n    <doc xml:space=\"preserve\">Checks to see if @dt1 and @dt2 are equal.\n\nEqual here means that they represent the same moment after converting\nthem to the same time zone.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @dt1 and @dt2 are equal</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"dt1\" transfer-ownership=\"none\" gs:managed-name=\"dt1\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"dt2\" transfer-ownership=\"none\" gs:managed-name=\"dt2\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"dt1\" transfer-ownership=\"none\" gs:managed-name=\"dt1\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"dt2\" transfer-ownership=\"none\" gs:managed-name=\"dt2\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"hash\" c:identifier=\"g_date_time_hash\" version=\"2.26\" gs:managed-name=\"Hash\">\n    <doc xml:space=\"preserve\">Hashes @datetime into a #guint, suitable for use within #GHashTable.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">a #guint containing the hash</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"datetime\" transfer-ownership=\"none\" gs:managed-name=\"datetime\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GDateTime</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    [GISharp.Core.Since("2.26")]
    public partial class DateTime : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.DateTime>
    {
        /// <summary>
        /// Retrieves the day of the month represented by @datetime in the gregorian
        /// calendar.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the day of the month
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 DayOfMonth
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
        /// Monday, 2 is Tuesday... 7 is Sunday).
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the day of the week
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 DayOfWeek
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the day of the year represented by @datetime in the Gregorian
        /// calendar.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the day of the year
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 DayOfYear
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the hour of the day represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the hour of the day
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 Hour
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the microsecond of the date represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the microsecond of the second
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 Microsecond
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the minute of the hour represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the minute of the hour
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 Minute
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the month of the year represented by @datetime in the Gregorian
        /// calendar.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the month represented by @datetime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 Month
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the second of the minute represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the second represented by @datetime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 Second
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the number of seconds since the start of the last minute,
        /// including the fractional part.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the number of seconds
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Double Seconds
        {
            get
            {
                return default(System.Double);
            }
        }

        /// <summary>
        /// Determines the time zone abbreviation to be used at the time and in
        /// the time zone of @datetime.
        /// </summary>
        /// <remarks>
        /// For example, in Toronto this is currently "EST" during the winter
        /// months and "EDT" during the summer months when daylight savings
        /// time is in effect.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the time zone abbreviation. The returned
        ///          string is owned by the #GDateTime and it should not be
        ///          modified or freed
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.String TimezoneAbbreviation
        {
            get
            {
                return default(System.String);
            }
        }

        /// <summary>
        /// Determines the offset to UTC in effect at the time and in the time
        /// zone of @datetime.
        /// </summary>
        /// <remarks>
        /// The offset is the number of microseconds that you add to UTC time to
        /// arrive at local time for the time zone (ie: negative numbers for time
        /// zones west of GMT, positive numbers for east).
        /// 
        /// If @datetime represents UTC time, then the offset is always zero.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the number of microseconds that should be added to UTC to
        ///          get the local time
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.TimeSpan UtcOffset
        {
            get
            {
                return default(GISharp.GLib.TimeSpan);
            }
        }

        /// <summary>
        /// Returns the ISO 8601 week-numbering year in which the week containing
        /// @datetime falls.
        /// </summary>
        /// <remarks>
        /// This function, taken together with g_date_time_get_week_of_year() and
        /// g_date_time_get_day_of_week() can be used to determine the full ISO
        /// week date on which @datetime falls.
        /// 
        /// This is usually equal to the normal Gregorian year (as returned by
        /// g_date_time_get_year()), except as detailed below:
        /// 
        /// For Thursday, the week-numbering year is always equal to the usual
        /// calendar year.  For other days, the number is such that every day
        /// within a complete week (Monday to Sunday) is contained within the
        /// same week-numbering year.
        /// 
        /// For Monday, Tuesday and Wednesday occurring near the end of the year,
        /// this may mean that the week-numbering year is one greater than the
        /// calendar year (so that these days have the same week-numbering year
        /// as the Thursday occurring early in the next year).
        /// 
        /// For Friday, Saturaday and Sunday occurring near the start of the year,
        /// this may mean that the week-numbering year is one less than the
        /// calendar year (so that these days have the same week-numbering year
        /// as the Thursday occurring late in the previous year).
        /// 
        /// An equivalent description is that the week-numbering year is equal to
        /// the calendar year containing the majority of the days in the current
        /// week (Monday to Sunday).
        /// 
        /// Note that January 1 0001 in the proleptic Gregorian calendar is a
        /// Monday, so this function never returns 0.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the ISO 8601 week-numbering year for @datetime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 WeekNumberingYear
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Returns the ISO 8601 week number for the week containing @datetime.
        /// The ISO 8601 week number is the same for every day of the week (from
        /// Moday through Sunday).  That can produce some unusual results
        /// (described below).
        /// </summary>
        /// <remarks>
        /// The first week of the year is week 1.  This is the week that contains
        /// the first Thursday of the year.  Equivalently, this is the first week
        /// that has more than 4 of its days falling within the calendar year.
        /// 
        /// The value 0 is never returned by this function.  Days contained
        /// within a year but occurring before the first ISO 8601 week of that
        /// year are considered as being contained in the last week of the
        /// previous year.  Similarly, the final days of a calendar year may be
        /// considered as being part of the first ISO 8601 week of the next year
        /// if 4 or more days of that week are contained within the new year.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the ISO 8601 week number for @datetime.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 WeekOfYear
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Retrieves the year represented by @datetime in the Gregorian calendar.
        /// </summary>
        /// <param name="datetime">
        /// A #GDateTime
        /// </param>
        /// <returns>
        /// the year represented by @datetime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 Year
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Determines if daylight savings time is in effect at the time and in
        /// the time zone of @datetime.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// %TRUE if daylight savings time is in effect
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Boolean IsDaylightSavings
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public DateTime(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GDateTime corresponding to the given date and time in
        /// the time zone @tz.
        /// </summary>
        /// <remarks>
        /// The @year must be between 1 and 9999, @month between 1 and 12 and @day
        /// between 1 and 28, 29, 30 or 31 depending on the month and the year.
        /// 
        /// @hour must be between 0 and 23 and @minute must be between 0 and 59.
        /// 
        /// @seconds must be at least 0.0 and must be strictly less than 60.0.
        /// It will be rounded down to the nearest microsecond.
        /// 
        /// If the given time is not representable in the given time zone (for
        /// example, 02:30 on March 14th 2010 in Toronto, due to daylight savings
        /// time) then the time will be rounded up to the nearest existing time
        /// (in this case, 03:00).  If this matters to you then you should verify
        /// the return value for containing the same as the numbers you gave.
        /// 
        /// In the case that the given time is ambiguous in the given time zone
        /// (for example, 01:30 on November 7th 2010 in Toronto, due to daylight
        /// savings time) then the time falling within standard (ie:
        /// non-daylight) time is taken.
        /// 
        /// It not considered a programmer error for the values to this function
        /// to be out of range, but in the case that they are, the function will
        /// return %NULL.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="year">
        /// the year component of the date
        /// </param>
        /// <param name="month">
        /// the month component of the date
        /// </param>
        /// <param name="day">
        /// the day component of the date
        /// </param>
        /// <param name="hour">
        /// the hour component of the date
        /// </param>
        /// <param name="minute">
        /// the minute component of the date
        /// </param>
        /// <param name="seconds">
        /// the number of seconds past the minute
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public DateTime(
            GISharp.GLib.TimeZone tz,
            System.Int32 year,
            System.Int32 month,
            System.Int32 day,
            System.Int32 hour,
            System.Int32 minute,
            System.Double seconds) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GDateTime corresponding to the given date and time in
        /// the time zone @tz.
        /// </summary>
        /// <remarks>
        /// The @year must be between 1 and 9999, @month between 1 and 12 and @day
        /// between 1 and 28, 29, 30 or 31 depending on the month and the year.
        /// 
        /// @hour must be between 0 and 23 and @minute must be between 0 and 59.
        /// 
        /// @seconds must be at least 0.0 and must be strictly less than 60.0.
        /// It will be rounded down to the nearest microsecond.
        /// 
        /// If the given time is not representable in the given time zone (for
        /// example, 02:30 on March 14th 2010 in Toronto, due to daylight savings
        /// time) then the time will be rounded up to the nearest existing time
        /// (in this case, 03:00).  If this matters to you then you should verify
        /// the return value for containing the same as the numbers you gave.
        /// 
        /// In the case that the given time is ambiguous in the given time zone
        /// (for example, 01:30 on November 7th 2010 in Toronto, due to daylight
        /// savings time) then the time falling within standard (ie:
        /// non-daylight) time is taken.
        /// 
        /// It not considered a programmer error for the values to this function
        /// to be out of range, but in the case that they are, the function will
        /// return %NULL.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="year">
        /// the year component of the date
        /// </param>
        /// <param name="month">
        /// the month component of the date
        /// </param>
        /// <param name="day">
        /// the day component of the date
        /// </param>
        /// <param name="hour">
        /// the hour component of the date
        /// </param>
        /// <param name="minute">
        /// the minute component of the date
        /// </param>
        /// <param name="seconds">
        /// the number of seconds past the minute
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new(
            [System.Runtime.InteropServices.In()] System.IntPtr tz,
            [System.Runtime.InteropServices.In()] System.Int32 year,
            [System.Runtime.InteropServices.In()] System.Int32 month,
            [System.Runtime.InteropServices.In()] System.Int32 day,
            [System.Runtime.InteropServices.In()] System.Int32 hour,
            [System.Runtime.InteropServices.In()] System.Int32 minute,
            [System.Runtime.InteropServices.In()] System.Double seconds);

        /// <summary>
        /// Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
        /// local time zone.
        /// </summary>
        /// <remarks>
        /// The time contained in a #GTimeVal is always stored in the form of
        /// seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
        /// local time offset.
        /// 
        /// This call can fail (returning %NULL) if @tv represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tv">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_from_timeval_local(
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal tv);

        /// <summary>
        /// Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
        /// local time zone.
        /// </summary>
        /// <remarks>
        /// The time contained in a #GTimeVal is always stored in the form of
        /// seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
        /// local time offset.
        /// 
        /// This call can fail (returning %NULL) if @tv represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tv">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime FromTimevalLocal(
            GISharp.GLib.TimeVal tv)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.
        /// </summary>
        /// <remarks>
        /// The time contained in a #GTimeVal is always stored in the form of
        /// seconds elapsed since 1970-01-01 00:00:00 UTC.
        /// 
        /// This call can fail (returning %NULL) if @tv represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tv">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_from_timeval_utc(
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal tv);

        /// <summary>
        /// Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.
        /// </summary>
        /// <remarks>
        /// The time contained in a #GTimeVal is always stored in the form of
        /// seconds elapsed since 1970-01-01 00:00:00 UTC.
        /// 
        /// This call can fail (returning %NULL) if @tv represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tv">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime FromTimevalUtc(
            GISharp.GLib.TimeVal tv)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a #GDateTime corresponding to the given Unix time @t in the
        /// local time zone.
        /// </summary>
        /// <remarks>
        /// Unix time is the number of seconds that have elapsed since 1970-01-01
        /// 00:00:00 UTC, regardless of the local time offset.
        /// 
        /// This call can fail (returning %NULL) if @t represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="t">
        /// the Unix time
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_from_unix_local(
            [System.Runtime.InteropServices.In()] System.Int64 t);

        /// <summary>
        /// Creates a #GDateTime corresponding to the given Unix time @t in the
        /// local time zone.
        /// </summary>
        /// <remarks>
        /// Unix time is the number of seconds that have elapsed since 1970-01-01
        /// 00:00:00 UTC, regardless of the local time offset.
        /// 
        /// This call can fail (returning %NULL) if @t represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="t">
        /// the Unix time
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime FromUnixLocal(
            System.Int64 t)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a #GDateTime corresponding to the given Unix time @t in UTC.
        /// </summary>
        /// <remarks>
        /// Unix time is the number of seconds that have elapsed since 1970-01-01
        /// 00:00:00 UTC.
        /// 
        /// This call can fail (returning %NULL) if @t represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="t">
        /// the Unix time
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_from_unix_utc(
            [System.Runtime.InteropServices.In()] System.Int64 t);

        /// <summary>
        /// Creates a #GDateTime corresponding to the given Unix time @t in UTC.
        /// </summary>
        /// <remarks>
        /// Unix time is the number of seconds that have elapsed since 1970-01-01
        /// 00:00:00 UTC.
        /// 
        /// This call can fail (returning %NULL) if @t represents a time outside
        /// of the supported range of #GDateTime.
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="t">
        /// the Unix time
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime FromUnixUtc(
            System.Int64 t)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a new #GDateTime corresponding to the given date and time in
        /// the local time zone.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_new() with the time
        /// zone returned by g_time_zone_new_local().
        /// </remarks>
        /// <param name="year">
        /// the year component of the date
        /// </param>
        /// <param name="month">
        /// the month component of the date
        /// </param>
        /// <param name="day">
        /// the day component of the date
        /// </param>
        /// <param name="hour">
        /// the hour component of the date
        /// </param>
        /// <param name="minute">
        /// the minute component of the date
        /// </param>
        /// <param name="seconds">
        /// the number of seconds past the minute
        /// </param>
        /// <returns>
        /// a #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_local(
            [System.Runtime.InteropServices.In()] System.Int32 year,
            [System.Runtime.InteropServices.In()] System.Int32 month,
            [System.Runtime.InteropServices.In()] System.Int32 day,
            [System.Runtime.InteropServices.In()] System.Int32 hour,
            [System.Runtime.InteropServices.In()] System.Int32 minute,
            [System.Runtime.InteropServices.In()] System.Double seconds);

        /// <summary>
        /// Creates a new #GDateTime corresponding to the given date and time in
        /// the local time zone.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_new() with the time
        /// zone returned by g_time_zone_new_local().
        /// </remarks>
        /// <param name="year">
        /// the year component of the date
        /// </param>
        /// <param name="month">
        /// the month component of the date
        /// </param>
        /// <param name="day">
        /// the day component of the date
        /// </param>
        /// <param name="hour">
        /// the hour component of the date
        /// </param>
        /// <param name="minute">
        /// the minute component of the date
        /// </param>
        /// <param name="seconds">
        /// the number of seconds past the minute
        /// </param>
        /// <returns>
        /// a #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime Local(
            System.Int32 year,
            System.Int32 month,
            System.Int32 day,
            System.Int32 hour,
            System.Int32 minute,
            System.Double seconds)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a #GDateTime corresponding to this exact instant in the given
        /// time zone @tz.  The time is as accurate as the system allows, to a
        /// maximum accuracy of 1 microsecond.
        /// </summary>
        /// <remarks>
        /// This function will always succeed unless the system clock is set to
        /// truly insane values (or unless GLib is still being used after the
        /// year 9999).
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_now(
            [System.Runtime.InteropServices.In()] System.IntPtr tz);

        /// <summary>
        /// Creates a #GDateTime corresponding to this exact instant in the given
        /// time zone @tz.  The time is as accurate as the system allows, to a
        /// maximum accuracy of 1 microsecond.
        /// </summary>
        /// <remarks>
        /// This function will always succeed unless the system clock is set to
        /// truly insane values (or unless GLib is still being used after the
        /// year 9999).
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime Now(
            GISharp.GLib.TimeZone tz)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a #GDateTime corresponding to this exact instant in the local
        /// time zone.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_date_time_new_now() with the time
        /// zone returned by g_time_zone_new_local().
        /// </remarks>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_now_local();

        /// <summary>
        /// Creates a #GDateTime corresponding to this exact instant in the local
        /// time zone.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_date_time_new_now() with the time
        /// zone returned by g_time_zone_new_local().
        /// </remarks>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime NowLocal()
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a #GDateTime corresponding to this exact instant in UTC.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_date_time_new_now() with the time
        /// zone returned by g_time_zone_new_utc().
        /// </remarks>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_now_utc();

        /// <summary>
        /// Creates a #GDateTime corresponding to this exact instant in UTC.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_date_time_new_now() with the time
        /// zone returned by g_time_zone_new_utc().
        /// </remarks>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime NowUtc()
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a new #GDateTime corresponding to the given date and time in
        /// UTC.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_new() with the time
        /// zone returned by g_time_zone_new_utc().
        /// </remarks>
        /// <param name="year">
        /// the year component of the date
        /// </param>
        /// <param name="month">
        /// the month component of the date
        /// </param>
        /// <param name="day">
        /// the day component of the date
        /// </param>
        /// <param name="hour">
        /// the hour component of the date
        /// </param>
        /// <param name="minute">
        /// the minute component of the date
        /// </param>
        /// <param name="seconds">
        /// the number of seconds past the minute
        /// </param>
        /// <returns>
        /// a #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_new_utc(
            [System.Runtime.InteropServices.In()] System.Int32 year,
            [System.Runtime.InteropServices.In()] System.Int32 month,
            [System.Runtime.InteropServices.In()] System.Int32 day,
            [System.Runtime.InteropServices.In()] System.Int32 hour,
            [System.Runtime.InteropServices.In()] System.Int32 minute,
            [System.Runtime.InteropServices.In()] System.Double seconds);

        /// <summary>
        /// Creates a new #GDateTime corresponding to the given date and time in
        /// UTC.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_new() with the time
        /// zone returned by g_time_zone_new_utc().
        /// </remarks>
        /// <param name="year">
        /// the year component of the date
        /// </param>
        /// <param name="month">
        /// the month component of the date
        /// </param>
        /// <param name="day">
        /// the day component of the date
        /// </param>
        /// <param name="hour">
        /// the hour component of the date
        /// </param>
        /// <param name="minute">
        /// the minute component of the date
        /// </param>
        /// <param name="seconds">
        /// the number of seconds past the minute
        /// </param>
        /// <returns>
        /// a #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.DateTime Utc(
            System.Int32 year,
            System.Int32 month,
            System.Int32 day,
            System.Int32 hour,
            System.Int32 minute,
            System.Double seconds)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// A comparison function for #GDateTimes that is suitable
        /// as a #GCompareFunc. Both #GDateTimes must be non-%NULL.
        /// </summary>
        /// <param name="dt1">
        /// first #GDateTime to compare
        /// </param>
        /// <param name="dt2">
        /// second #GDateTime to compare
        /// </param>
        /// <returns>
        /// -1, 0 or 1 if @dt1 is less than, equal to or greater
        ///   than @dt2.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_compare(
            [System.Runtime.InteropServices.In()] System.IntPtr dt1,
            [System.Runtime.InteropServices.In()] System.IntPtr dt2);

        /// <summary>
        /// A comparison function for #GDateTimes that is suitable
        /// as a #GCompareFunc. Both #GDateTimes must be non-%NULL.
        /// </summary>
        /// <param name="dt1">
        /// first #GDateTime to compare
        /// </param>
        /// <param name="dt2">
        /// second #GDateTime to compare
        /// </param>
        /// <returns>
        /// -1, 0 or 1 if @dt1 is less than, equal to or greater
        ///   than @dt2.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static System.Int32 Compare(
            System.IntPtr dt1,
            System.IntPtr dt2)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Checks to see if @dt1 and @dt2 are equal.
        /// </summary>
        /// <remarks>
        /// Equal here means that they represent the same moment after converting
        /// them to the same time zone.
        /// </remarks>
        /// <param name="dt1">
        /// a #GDateTime
        /// </param>
        /// <param name="dt2">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// %TRUE if @dt1 and @dt2 are equal
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Boolean g_date_time_equal(
            [System.Runtime.InteropServices.In()] System.IntPtr dt1,
            [System.Runtime.InteropServices.In()] System.IntPtr dt2);

        /// <summary>
        /// Checks to see if @dt1 and @dt2 are equal.
        /// </summary>
        /// <remarks>
        /// Equal here means that they represent the same moment after converting
        /// them to the same time zone.
        /// </remarks>
        /// <param name="dt1">
        /// a #GDateTime
        /// </param>
        /// <param name="dt2">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// %TRUE if @dt1 and @dt2 are equal
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static System.Boolean Equal(
            System.IntPtr dt1,
            System.IntPtr dt2)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Hashes @datetime into a #guint, suitable for use within #GHashTable.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// a #guint containing the hash
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.UInt32 g_date_time_hash(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Hashes @datetime into a #guint, suitable for use within #GHashTable.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// a #guint containing the hash
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static System.UInt32 Hash(
            System.IntPtr datetime)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified timespan to the copy.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="timespan">
        /// a #GTimeSpan
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeSpan timespan);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified timespan to the copy.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="timespan">
        /// a #GTimeSpan
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime Add(
            GISharp.GLib.TimeSpan timespan)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of days to the
        /// copy. Add negative values to subtract days.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="days">
        /// the number of days
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_days(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 days);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of days to the
        /// copy. Add negative values to subtract days.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="days">
        /// the number of days
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddDays(
            System.Int32 days)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a new #GDateTime adding the specified values to the current date and
        /// time in @datetime. Add negative values to subtract.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="years">
        /// the number of years to add
        /// </param>
        /// <param name="months">
        /// the number of months to add
        /// </param>
        /// <param name="days">
        /// the number of days to add
        /// </param>
        /// <param name="hours">
        /// the number of hours to add
        /// </param>
        /// <param name="minutes">
        /// the number of minutes to add
        /// </param>
        /// <param name="seconds">
        /// the number of seconds to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime that should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_full(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 years,
            [System.Runtime.InteropServices.In()] System.Int32 months,
            [System.Runtime.InteropServices.In()] System.Int32 days,
            [System.Runtime.InteropServices.In()] System.Int32 hours,
            [System.Runtime.InteropServices.In()] System.Int32 minutes,
            [System.Runtime.InteropServices.In()] System.Double seconds);

        /// <summary>
        /// Creates a new #GDateTime adding the specified values to the current date and
        /// time in @datetime. Add negative values to subtract.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="years">
        /// the number of years to add
        /// </param>
        /// <param name="months">
        /// the number of months to add
        /// </param>
        /// <param name="days">
        /// the number of days to add
        /// </param>
        /// <param name="hours">
        /// the number of hours to add
        /// </param>
        /// <param name="minutes">
        /// the number of minutes to add
        /// </param>
        /// <param name="seconds">
        /// the number of seconds to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime that should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddFull(
            System.Int32 years,
            System.Int32 months,
            System.Int32 days,
            System.Int32 hours,
            System.Int32 minutes,
            System.Double seconds)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of hours.
        /// Add negative values to subtract hours.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="hours">
        /// the number of hours to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_hours(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 hours);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of hours.
        /// Add negative values to subtract hours.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="hours">
        /// the number of hours to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddHours(
            System.Int32 hours)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime adding the specified number of minutes.
        /// Add negative values to subtract minutes.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="minutes">
        /// the number of minutes to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_minutes(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 minutes);

        /// <summary>
        /// Creates a copy of @datetime adding the specified number of minutes.
        /// Add negative values to subtract minutes.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="minutes">
        /// the number of minutes to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddMinutes(
            System.Int32 minutes)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of months to the
        /// copy. Add negative values to subtract months.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="months">
        /// the number of months
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_months(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 months);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of months to the
        /// copy. Add negative values to subtract months.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="months">
        /// the number of months
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddMonths(
            System.Int32 months)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of seconds.
        /// Add negative values to subtract seconds.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="seconds">
        /// the number of seconds to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_seconds(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Double seconds);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of seconds.
        /// Add negative values to subtract seconds.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="seconds">
        /// the number of seconds to add
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddSeconds(
            System.Double seconds)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of weeks to the
        /// copy. Add negative values to subtract weeks.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="weeks">
        /// the number of weeks
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_weeks(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 weeks);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of weeks to the
        /// copy. Add negative values to subtract weeks.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="weeks">
        /// the number of weeks
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddWeeks(
            System.Int32 weeks)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of years to the
        /// copy. Add negative values to subtract years.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="years">
        /// the number of years
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_add_years(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.Int32 years);

        /// <summary>
        /// Creates a copy of @datetime and adds the specified number of years to the
        /// copy. Add negative values to subtract years.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="years">
        /// the number of years
        /// </param>
        /// <returns>
        /// the newly created #GDateTime which should be freed with
        ///   g_date_time_unref().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime AddYears(
            System.Int32 years)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Calculates the difference in time between @end and @begin.  The
        /// #GTimeSpan that is returned is effectively @end - @begin (ie:
        /// positive if the first parameter is larger).
        /// </summary>
        /// <param name="end">
        /// a #GDateTime
        /// </param>
        /// <param name="begin">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the difference between the two #GDateTime, as a time
        ///   span expressed in microseconds.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern GISharp.GLib.TimeSpan g_date_time_difference(
            [System.Runtime.InteropServices.In()] System.IntPtr end,
            [System.Runtime.InteropServices.In()] System.IntPtr begin);

        /// <summary>
        /// Calculates the difference in time between @end and @begin.  The
        /// #GTimeSpan that is returned is effectively @end - @begin (ie:
        /// positive if the first parameter is larger).
        /// </summary>
        /// <param name="end">
        /// a #GDateTime
        /// </param>
        /// <param name="begin">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the difference between the two #GDateTime, as a time
        ///   span expressed in microseconds.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.TimeSpan Difference(
            GISharp.GLib.DateTime begin)
        {
            return default(GISharp.GLib.TimeSpan);
        }

        /// <summary>
        /// Creates a newly allocated string representing the requested @format.
        /// </summary>
        /// <remarks>
        /// The format strings understood by this function are a subset of the
        /// strftime() format language as specified by C99.  The \%D, \%U and \%W
        /// conversions are not supported, nor is the 'E' modifier.  The GNU
        /// extensions \%k, \%l, \%s and \%P are supported, however, as are the
        /// '0', '_' and '-' modifiers.
        /// 
        /// In contrast to strftime(), this function always produces a UTF-8
        /// string, regardless of the current locale.  Note that the rendering of
        /// many formats is locale-dependent and may not match the strftime()
        /// output exactly.
        /// 
        /// The following format specifiers are supported:
        /// 
        /// - \%a: the abbreviated weekday name according to the current locale
        /// - \%A: the full weekday name according to the current locale
        /// - \%b: the abbreviated month name according to the current locale
        /// - \%B: the full month name according to the current locale
        /// - \%c: the  preferred date and time rpresentation for the current locale
        /// - \%C: the century number (year/100) as a 2-digit integer (00-99)
        /// - \%d: the day of the month as a decimal number (range 01 to 31)
        /// - \%e: the day of the month as a decimal number (range  1 to 31)
        /// - \%F: equivalent to `%Y-%m-%d` (the ISO 8601 date format)
        /// - \%g: the last two digits of the ISO 8601 week-based year as a
        ///   decimal number (00-99). This works well with \%V and \%u.
        /// - \%G: the ISO 8601 week-based year as a decimal number. This works
        ///   well with \%V and \%u.
        /// - \%h: equivalent to \%b
        /// - \%H: the hour as a decimal number using a 24-hour clock (range 00 to 23)
        /// - \%I: the hour as a decimal number using a 12-hour clock (range 01 to 12)
        /// - \%j: the day of the year as a decimal number (range 001 to 366)
        /// - \%k: the hour (24-hour clock) as a decimal number (range 0 to 23);
        ///   single digits are preceded by a blank
        /// - \%l: the hour (12-hour clock) as a decimal number (range 1 to 12);
        ///   single digits are preceded by a blank
        /// - \%m: the month as a decimal number (range 01 to 12)
        /// - \%M: the minute as a decimal number (range 00 to 59)
        /// - \%p: either "AM" or "PM" according to the given time value, or the
        ///   corresponding  strings for the current locale.  Noon is treated as
        ///   "PM" and midnight as "AM".
        /// - \%P: like \%p but lowercase: "am" or "pm" or a corresponding string for
        ///   the current locale
        /// - \%r: the time in a.m. or p.m. notation
        /// - \%R: the time in 24-hour notation (\%H:\%M)
        /// - \%s: the number of seconds since the Epoch, that is, since 1970-01-01
        ///   00:00:00 UTC
        /// - \%S: the second as a decimal number (range 00 to 60)
        /// - \%t: a tab character
        /// - \%T: the time in 24-hour notation with seconds (\%H:\%M:\%S)
        /// - \%u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
        ///    Monday being 1. This works well with \%G and \%V.
        /// - \%V: the ISO 8601 standard week number of the current year as a decimal
        ///   number, range 01 to 53, where week 1 is the first week that has at
        ///   least 4 days in the new year. See g_date_time_get_week_of_year().
        ///   This works well with \%G and \%u.
        /// - \%w: the day of the week as a decimal, range 0 to 6, Sunday being 0.
        ///   This is not the ISO 8601 standard format -- use \%u instead.
        /// - \%x: the preferred date representation for the current locale without
        ///   the time
        /// - \%X: the preferred time representation for the current locale without
        ///   the date
        /// - \%y: the year as a decimal number without the century
        /// - \%Y: the year as a decimal number including the century
        /// - \%z: the time zone as an offset from UTC (+hhmm)
        /// - \%:z: the time zone as an offset from UTC (+hh:mm).
        ///   This is a gnulib strftime() extension. Since: 2.38
        /// - \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a
        ///   gnulib strftime() extension. Since: 2.38
        /// - \%:::z: the time zone as an offset from UTC, with : to necessary
        ///   precision (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38
        /// - \%Z: the time zone or name or abbreviation
        /// - \%\%: a literal \% character
        /// 
        /// Some conversion specifications can be modified by preceding the
        /// conversion specifier by one or more modifier characters. The
        /// following modifiers are supported for many of the numeric
        /// conversions:
        /// 
        /// - O: Use alternative numeric symbols, if the current locale supports those.
        /// - _: Pad a numeric result with spaces. This overrides the default padding
        ///   for the specifier.
        /// - -: Do not pad a numeric result. This overrides the default padding
        ///   for the specifier.
        /// - 0: Pad a numeric result with zeros. This overrides the default padding
        ///   for the specifier.
        /// </remarks>
        /// <param name="datetime">
        /// A #GDateTime
        /// </param>
        /// <param name="format">
        /// a valid UTF-8 string, containing the format for the
        ///          #GDateTime
        /// </param>
        /// <returns>
        /// a newly allocated string formatted to the requested format
        ///     or %NULL in the case that there was an error. The string
        ///     should be freed with g_free().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_format(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.IntPtr format);

        /// <summary>
        /// Creates a newly allocated string representing the requested @format.
        /// </summary>
        /// <remarks>
        /// The format strings understood by this function are a subset of the
        /// strftime() format language as specified by C99.  The \%D, \%U and \%W
        /// conversions are not supported, nor is the 'E' modifier.  The GNU
        /// extensions \%k, \%l, \%s and \%P are supported, however, as are the
        /// '0', '_' and '-' modifiers.
        /// 
        /// In contrast to strftime(), this function always produces a UTF-8
        /// string, regardless of the current locale.  Note that the rendering of
        /// many formats is locale-dependent and may not match the strftime()
        /// output exactly.
        /// 
        /// The following format specifiers are supported:
        /// 
        /// - \%a: the abbreviated weekday name according to the current locale
        /// - \%A: the full weekday name according to the current locale
        /// - \%b: the abbreviated month name according to the current locale
        /// - \%B: the full month name according to the current locale
        /// - \%c: the  preferred date and time rpresentation for the current locale
        /// - \%C: the century number (year/100) as a 2-digit integer (00-99)
        /// - \%d: the day of the month as a decimal number (range 01 to 31)
        /// - \%e: the day of the month as a decimal number (range  1 to 31)
        /// - \%F: equivalent to `%Y-%m-%d` (the ISO 8601 date format)
        /// - \%g: the last two digits of the ISO 8601 week-based year as a
        ///   decimal number (00-99). This works well with \%V and \%u.
        /// - \%G: the ISO 8601 week-based year as a decimal number. This works
        ///   well with \%V and \%u.
        /// - \%h: equivalent to \%b
        /// - \%H: the hour as a decimal number using a 24-hour clock (range 00 to 23)
        /// - \%I: the hour as a decimal number using a 12-hour clock (range 01 to 12)
        /// - \%j: the day of the year as a decimal number (range 001 to 366)
        /// - \%k: the hour (24-hour clock) as a decimal number (range 0 to 23);
        ///   single digits are preceded by a blank
        /// - \%l: the hour (12-hour clock) as a decimal number (range 1 to 12);
        ///   single digits are preceded by a blank
        /// - \%m: the month as a decimal number (range 01 to 12)
        /// - \%M: the minute as a decimal number (range 00 to 59)
        /// - \%p: either "AM" or "PM" according to the given time value, or the
        ///   corresponding  strings for the current locale.  Noon is treated as
        ///   "PM" and midnight as "AM".
        /// - \%P: like \%p but lowercase: "am" or "pm" or a corresponding string for
        ///   the current locale
        /// - \%r: the time in a.m. or p.m. notation
        /// - \%R: the time in 24-hour notation (\%H:\%M)
        /// - \%s: the number of seconds since the Epoch, that is, since 1970-01-01
        ///   00:00:00 UTC
        /// - \%S: the second as a decimal number (range 00 to 60)
        /// - \%t: a tab character
        /// - \%T: the time in 24-hour notation with seconds (\%H:\%M:\%S)
        /// - \%u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
        ///    Monday being 1. This works well with \%G and \%V.
        /// - \%V: the ISO 8601 standard week number of the current year as a decimal
        ///   number, range 01 to 53, where week 1 is the first week that has at
        ///   least 4 days in the new year. See g_date_time_get_week_of_year().
        ///   This works well with \%G and \%u.
        /// - \%w: the day of the week as a decimal, range 0 to 6, Sunday being 0.
        ///   This is not the ISO 8601 standard format -- use \%u instead.
        /// - \%x: the preferred date representation for the current locale without
        ///   the time
        /// - \%X: the preferred time representation for the current locale without
        ///   the date
        /// - \%y: the year as a decimal number without the century
        /// - \%Y: the year as a decimal number including the century
        /// - \%z: the time zone as an offset from UTC (+hhmm)
        /// - \%:z: the time zone as an offset from UTC (+hh:mm).
        ///   This is a gnulib strftime() extension. Since: 2.38
        /// - \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a
        ///   gnulib strftime() extension. Since: 2.38
        /// - \%:::z: the time zone as an offset from UTC, with : to necessary
        ///   precision (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38
        /// - \%Z: the time zone or name or abbreviation
        /// - \%\%: a literal \% character
        /// 
        /// Some conversion specifications can be modified by preceding the
        /// conversion specifier by one or more modifier characters. The
        /// following modifiers are supported for many of the numeric
        /// conversions:
        /// 
        /// - O: Use alternative numeric symbols, if the current locale supports those.
        /// - _: Pad a numeric result with spaces. This overrides the default padding
        ///   for the specifier.
        /// - -: Do not pad a numeric result. This overrides the default padding
        ///   for the specifier.
        /// - 0: Pad a numeric result with zeros. This overrides the default padding
        ///   for the specifier.
        /// </remarks>
        /// <param name="datetime">
        /// A #GDateTime
        /// </param>
        /// <param name="format">
        /// a valid UTF-8 string, containing the format for the
        ///          #GDateTime
        /// </param>
        /// <returns>
        /// a newly allocated string formatted to the requested format
        ///     or %NULL in the case that there was an error. The string
        ///     should be freed with g_free().
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.String Format(
            System.String format)
        {
            return default(System.String);
        }

        /// <summary>
        /// Retrieves the day of the month represented by @datetime in the gregorian
        /// calendar.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the day of the month
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_day_of_month(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
        /// Monday, 2 is Tuesday... 7 is Sunday).
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the day of the week
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_day_of_week(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the day of the year represented by @datetime in the Gregorian
        /// calendar.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the day of the year
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_day_of_year(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the hour of the day represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the hour of the day
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_hour(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the microsecond of the date represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the microsecond of the second
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_microsecond(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the minute of the hour represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the minute of the hour
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_minute(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the month of the year represented by @datetime in the Gregorian
        /// calendar.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the month represented by @datetime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_month(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the second of the minute represented by @datetime
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the second represented by @datetime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_second(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the number of seconds since the start of the last minute,
        /// including the fractional part.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the number of seconds
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Double g_date_time_get_seconds(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Determines the time zone abbreviation to be used at the time and in
        /// the time zone of @datetime.
        /// </summary>
        /// <remarks>
        /// For example, in Toronto this is currently "EST" during the winter
        /// months and "EDT" during the summer months when daylight savings
        /// time is in effect.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the time zone abbreviation. The returned
        ///          string is owned by the #GDateTime and it should not be
        ///          modified or freed
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_get_timezone_abbreviation(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Determines the offset to UTC in effect at the time and in the time
        /// zone of @datetime.
        /// </summary>
        /// <remarks>
        /// The offset is the number of microseconds that you add to UTC time to
        /// arrive at local time for the time zone (ie: negative numbers for time
        /// zones west of GMT, positive numbers for east).
        /// 
        /// If @datetime represents UTC time, then the offset is always zero.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the number of microseconds that should be added to UTC to
        ///          get the local time
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern GISharp.GLib.TimeSpan g_date_time_get_utc_offset(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Returns the ISO 8601 week-numbering year in which the week containing
        /// @datetime falls.
        /// </summary>
        /// <remarks>
        /// This function, taken together with g_date_time_get_week_of_year() and
        /// g_date_time_get_day_of_week() can be used to determine the full ISO
        /// week date on which @datetime falls.
        /// 
        /// This is usually equal to the normal Gregorian year (as returned by
        /// g_date_time_get_year()), except as detailed below:
        /// 
        /// For Thursday, the week-numbering year is always equal to the usual
        /// calendar year.  For other days, the number is such that every day
        /// within a complete week (Monday to Sunday) is contained within the
        /// same week-numbering year.
        /// 
        /// For Monday, Tuesday and Wednesday occurring near the end of the year,
        /// this may mean that the week-numbering year is one greater than the
        /// calendar year (so that these days have the same week-numbering year
        /// as the Thursday occurring early in the next year).
        /// 
        /// For Friday, Saturaday and Sunday occurring near the start of the year,
        /// this may mean that the week-numbering year is one less than the
        /// calendar year (so that these days have the same week-numbering year
        /// as the Thursday occurring late in the previous year).
        /// 
        /// An equivalent description is that the week-numbering year is equal to
        /// the calendar year containing the majority of the days in the current
        /// week (Monday to Sunday).
        /// 
        /// Note that January 1 0001 in the proleptic Gregorian calendar is a
        /// Monday, so this function never returns 0.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the ISO 8601 week-numbering year for @datetime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_week_numbering_year(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Returns the ISO 8601 week number for the week containing @datetime.
        /// The ISO 8601 week number is the same for every day of the week (from
        /// Moday through Sunday).  That can produce some unusual results
        /// (described below).
        /// </summary>
        /// <remarks>
        /// The first week of the year is week 1.  This is the week that contains
        /// the first Thursday of the year.  Equivalently, this is the first week
        /// that has more than 4 of its days falling within the calendar year.
        /// 
        /// The value 0 is never returned by this function.  Days contained
        /// within a year but occurring before the first ISO 8601 week of that
        /// year are considered as being contained in the last week of the
        /// previous year.  Similarly, the final days of a calendar year may be
        /// considered as being part of the first ISO 8601 week of the next year
        /// if 4 or more days of that week are contained within the new year.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the ISO 8601 week number for @datetime.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_week_of_year(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the year represented by @datetime in the Gregorian calendar.
        /// </summary>
        /// <param name="datetime">
        /// A #GDateTime
        /// </param>
        /// <returns>
        /// the year represented by @datetime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_date_time_get_year(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Retrieves the Gregorian day, month, and year of a given #GDateTime.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime.
        /// </param>
        /// <param name="year">
        /// the return location for the gregorian year, or %NULL.
        /// </param>
        /// <param name="month">
        /// the return location for the month of the year, or %NULL.
        /// </param>
        /// <param name="day">
        /// the return location for the day of the month, or %NULL.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_date_time_get_ymd(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.Out()] out System.Int32 year,
            [System.Runtime.InteropServices.Out()] out System.Int32 month,
            [System.Runtime.InteropServices.Out()] out System.Int32 day);

        /// <summary>
        /// Retrieves the Gregorian day, month, and year of a given #GDateTime.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime.
        /// </param>
        /// <param name="year">
        /// the return location for the gregorian year, or %NULL.
        /// </param>
        /// <param name="month">
        /// the return location for the month of the year, or %NULL.
        /// </param>
        /// <param name="day">
        /// the return location for the day of the month, or %NULL.
        /// </param>
        [GISharp.Core.Since("2.26")]
        public void GetYmd(
            out System.Int32 year,
            out System.Int32 month,
            out System.Int32 day)
        {
            year = default(System.Int32);
            month = default(System.Int32);
            day = default(System.Int32);
        }

        /// <summary>
        /// Determines if daylight savings time is in effect at the time and in
        /// the time zone of @datetime.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// %TRUE if daylight savings time is in effect
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Boolean g_date_time_is_daylight_savings(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Atomically increments the reference count of @datetime by one.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the #GDateTime with the reference count increased
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Atomically increments the reference count of @datetime by one.
        /// </summary>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the #GDateTime with the reference count increased
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Creates a new #GDateTime corresponding to the same instant in time as
        /// @datetime, but in the local time zone.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_to_timezone() with the
        /// time zone returned by g_time_zone_new_local().
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the newly created #GDateTime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_to_local(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Creates a new #GDateTime corresponding to the same instant in time as
        /// @datetime, but in the local time zone.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_to_timezone() with the
        /// time zone returned by g_time_zone_new_local().
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the newly created #GDateTime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime ToLocal()
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Stores the instant in time that @datetime represents into @tv.
        /// </summary>
        /// <remarks>
        /// The time contained in a #GTimeVal is always stored in the form of
        /// seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
        /// zone associated with @datetime.
        /// 
        /// On systems where 'long' is 32bit (ie: all 32bit systems and all
        /// Windows systems), a #GTimeVal is incapable of storing the entire
        /// range of values that #GDateTime is capable of expressing.  On those
        /// systems, this function returns %FALSE to indicate that the time is
        /// out of range.
        /// 
        /// On systems where 'long' is 64bit, this function never fails.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="tv">
        /// a #GTimeVal to modify
        /// </param>
        /// <returns>
        /// %TRUE if successful, else %FALSE
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Boolean g_date_time_to_timeval(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal tv);

        /// <summary>
        /// Stores the instant in time that @datetime represents into @tv.
        /// </summary>
        /// <remarks>
        /// The time contained in a #GTimeVal is always stored in the form of
        /// seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
        /// zone associated with @datetime.
        /// 
        /// On systems where 'long' is 32bit (ie: all 32bit systems and all
        /// Windows systems), a #GTimeVal is incapable of storing the entire
        /// range of values that #GDateTime is capable of expressing.  On those
        /// systems, this function returns %FALSE to indicate that the time is
        /// out of range.
        /// 
        /// On systems where 'long' is 64bit, this function never fails.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="tv">
        /// a #GTimeVal to modify
        /// </param>
        /// <returns>
        /// %TRUE if successful, else %FALSE
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Boolean ToTimeval(
            GISharp.GLib.TimeVal tv)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Create a new #GDateTime corresponding to the same instant in time as
        /// @datetime, but in the time zone @tz.
        /// </summary>
        /// <remarks>
        /// This call can fail in the case that the time goes out of bounds.  For
        /// example, converting 0001-01-01 00:00:00 UTC to a time zone west of
        /// Greenwich will fail (due to the year 0 being out of range).
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="tz">
        /// the new #GTimeZone
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_to_timezone(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime,
            [System.Runtime.InteropServices.In()] System.IntPtr tz);

        /// <summary>
        /// Create a new #GDateTime corresponding to the same instant in time as
        /// @datetime, but in the time zone @tz.
        /// </summary>
        /// <remarks>
        /// This call can fail in the case that the time goes out of bounds.  For
        /// example, converting 0001-01-01 00:00:00 UTC to a time zone west of
        /// Greenwich will fail (due to the year 0 being out of range).
        /// 
        /// You should release the return value by calling g_date_time_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <param name="tz">
        /// the new #GTimeZone
        /// </param>
        /// <returns>
        /// a new #GDateTime, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime ToTimezone(
            GISharp.GLib.TimeZone tz)
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Gives the Unix time corresponding to @datetime, rounding down to the
        /// nearest second.
        /// </summary>
        /// <remarks>
        /// Unix time is the number of seconds that have elapsed since 1970-01-01
        /// 00:00:00 UTC, regardless of the time zone associated with @datetime.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the Unix time corresponding to @datetime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int64 g_date_time_to_unix(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Gives the Unix time corresponding to @datetime, rounding down to the
        /// nearest second.
        /// </summary>
        /// <remarks>
        /// Unix time is the number of seconds that have elapsed since 1970-01-01
        /// 00:00:00 UTC, regardless of the time zone associated with @datetime.
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the Unix time corresponding to @datetime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int64 ToUnix()
        {
            return default(System.Int64);
        }

        /// <summary>
        /// Creates a new #GDateTime corresponding to the same instant in time as
        /// @datetime, but in UTC.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_to_timezone() with the
        /// time zone returned by g_time_zone_new_utc().
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the newly created #GDateTime
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_date_time_to_utc(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Creates a new #GDateTime corresponding to the same instant in time as
        /// @datetime, but in UTC.
        /// </summary>
        /// <remarks>
        /// This call is equivalent to calling g_date_time_to_timezone() with the
        /// time zone returned by g_time_zone_new_utc().
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        /// <returns>
        /// the newly created #GDateTime
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public GISharp.GLib.DateTime ToUtc()
        {
            return default(GISharp.GLib.DateTime);
        }

        /// <summary>
        /// Atomically decrements the reference count of @datetime by one.
        /// </summary>
        /// <remarks>
        /// When the reference count reaches zero, the resources allocated by
        /// @datetime are freed
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_date_time_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr datetime);

        /// <summary>
        /// Atomically decrements the reference count of @datetime by one.
        /// </summary>
        /// <remarks>
        /// When the reference count reaches zero, the resources allocated by
        /// @datetime are freed
        /// </remarks>
        /// <param name="datetime">
        /// a #GDateTime
        /// </param>
        [GISharp.Core.Since("2.26")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// Enumeration representing a day of the week; #G_DATE_MONDAY,
    /// #G_DATE_TUESDAY, etc. #G_DATE_BAD_WEEKDAY is an invalid weekday.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"DateWeekday\" c:type=\"GDateWeekday\" gs:managed-name=\"DateWeekday\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Enumeration representing a day of the week; #G_DATE_MONDAY,\n#G_DATE_TUESDAY, etc. #G_DATE_BAD_WEEKDAY is an invalid weekday.</doc>\n  <member name=\"bad_weekday\" value=\"0\" c:identifier=\"G_DATE_BAD_WEEKDAY\" gs:managed-name=\"BadWeekday\">\n    <doc xml:space=\"preserve\">invalid value</doc>\n  </member>\n  <member name=\"monday\" value=\"1\" c:identifier=\"G_DATE_MONDAY\" gs:managed-name=\"Monday\">\n    <doc xml:space=\"preserve\">Monday</doc>\n  </member>\n  <member name=\"tuesday\" value=\"2\" c:identifier=\"G_DATE_TUESDAY\" gs:managed-name=\"Tuesday\">\n    <doc xml:space=\"preserve\">Tuesday</doc>\n  </member>\n  <member name=\"wednesday\" value=\"3\" c:identifier=\"G_DATE_WEDNESDAY\" gs:managed-name=\"Wednesday\">\n    <doc xml:space=\"preserve\">Wednesday</doc>\n  </member>\n  <member name=\"thursday\" value=\"4\" c:identifier=\"G_DATE_THURSDAY\" gs:managed-name=\"Thursday\">\n    <doc xml:space=\"preserve\">Thursday</doc>\n  </member>\n  <member name=\"friday\" value=\"5\" c:identifier=\"G_DATE_FRIDAY\" gs:managed-name=\"Friday\">\n    <doc xml:space=\"preserve\">Friday</doc>\n  </member>\n  <member name=\"saturday\" value=\"6\" c:identifier=\"G_DATE_SATURDAY\" gs:managed-name=\"Saturday\">\n    <doc xml:space=\"preserve\">Saturday</doc>\n  </member>\n  <member name=\"sunday\" value=\"7\" c:identifier=\"G_DATE_SUNDAY\" gs:managed-name=\"Sunday\">\n    <doc xml:space=\"preserve\">Sunday</doc>\n  </member>\n</enumeration>")]
    public enum DateWeekday
    {
        /// <summary>
        /// invalid value
        /// </summary>
        BadWeekday = 0,
        /// <summary>
        /// Monday
        /// </summary>
        Monday = 1,
        /// <summary>
        /// Tuesday
        /// </summary>
        Tuesday = 2,
        /// <summary>
        /// Wednesday
        /// </summary>
        Wednesday = 3,
        /// <summary>
        /// Thursday
        /// </summary>
        Thursday = 4,
        /// <summary>
        /// Friday
        /// </summary>
        Friday = 5,
        /// <summary>
        /// Saturday
        /// </summary>
        Saturday = 6,
        /// <summary>
        /// Sunday
        /// </summary>
        Sunday = 7
    }

    /// <summary>
    /// Specifies the type of function which is called when a data element
    /// is destroyed. It is passed the pointer to the data element and
    /// should free any memory and resources allocated for it.
    /// </summary>
    /// <param name="data">
    /// the data element.
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function which is called when a data element\nis destroyed. It is passed the pointer to the data element and\nshould free any memory and resources allocated for it.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void DestroyNotifyNative(
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// Specifies the type of function which is called when a data element
    /// is destroyed. It is passed the pointer to the data element and
    /// should free any memory and resources allocated for it.
    /// </summary>
    /// <param name="data">
    /// the data element.
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function which is called when a data element\nis destroyed. It is passed the pointer to the data element and\nshould free any memory and resources allocated for it.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data element.</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate void DestroyNotify(
        System.IntPtr data);

    /// <summary>
    /// The type of functions that are used to 'duplicate' an object.
    /// What this means depends on the context, it could just be
    /// incrementing the reference count, if @data is a ref-counted
    /// object.
    /// </summary>
    /// <param name="data">
    /// the data to duplicate
    /// </param>
    /// <param name="userData">
    /// user data that was specified in g_datalist_id_dup_data()
    /// </param>
    /// <returns>
    /// a duplicate of data
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"DuplicateFunc\" c:type=\"GDuplicateFunc\" introspectable=\"0\" gs:managed-name=\"DuplicateFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The type of functions that are used to 'duplicate' an object.\nWhat this means depends on the context, it could just be\nincrementing the reference count, if @data is a ref-counted\nobject.</doc>\n  <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">a duplicate of data</doc>\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data to duplicate</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data that was specified in g_datalist_id_dup_data()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data to duplicate</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.IntPtr DuplicateFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr data,
        [System.Runtime.InteropServices.In()] System.IntPtr userData);

    /// <summary>
    /// The type of functions that are used to 'duplicate' an object.
    /// What this means depends on the context, it could just be
    /// incrementing the reference count, if @data is a ref-counted
    /// object.
    /// </summary>
    /// <param name="data">
    /// the data to duplicate
    /// </param>
    /// <param name="userData">
    /// user data that was specified in g_datalist_id_dup_data()
    /// </param>
    /// <returns>
    /// a duplicate of data
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"DuplicateFunc\" c:type=\"GDuplicateFunc\" introspectable=\"0\" gs:managed-name=\"DuplicateFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The type of functions that are used to 'duplicate' an object.\nWhat this means depends on the context, it could just be\nincrementing the reference count, if @data is a ref-counted\nobject.</doc>\n  <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">a duplicate of data</doc>\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data to duplicate</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data that was specified in g_datalist_id_dup_data()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data to duplicate</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate System.IntPtr DuplicateFunc(
        System.IntPtr data);

    /// <summary>
    /// The `GError` structure contains information about
    /// an error that has occurred.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Error\" c:type=\"GError\" glib:type-name=\"GError\" glib:get-type=\"g_error_get_type\" c:symbol-prefix=\"error\" gs:managed-name=\"Error\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The `GError` structure contains information about\nan error that has occurred.</doc>\n  <constructor name=\"new_literal\" c:identifier=\"g_error_new_literal\" gs:managed-name=\"NewLiteral\">\n    <doc xml:space=\"preserve\">Creates a new #GError; unlike g_error_new(), @message is\nnot a printf()-style format string. Use this function if\n@message contains text you don't have control over,\nthat could include printf() escape sequences.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GError</doc>\n      <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_valist\" c:identifier=\"g_error_new_valist\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"NewValist\">\n    <doc xml:space=\"preserve\">Creates a new #GError with the given @domain and @code,\nand a message formatted with @format.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GError</doc>\n      <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">printf()-style format for error message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"args\" transfer-ownership=\"none\" gs:managed-name=\"args\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">#va_list of parameters for the message format</doc>\n        <type name=\"va_list\" c:type=\"va_list\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">printf()-style format for error message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"args\" transfer-ownership=\"none\" gs:managed-name=\"args\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">#va_list of parameters for the message format</doc>\n        <type name=\"va_list\" c:type=\"va_list\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"copy\" c:identifier=\"g_error_copy\" gs:managed-name=\"Copy\" gs:special-func=\"copy\">\n    <doc xml:space=\"preserve\">Makes a copy of @error.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GError</doc>\n      <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"error\" transfer-ownership=\"none\" gs:managed-name=\"error\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GError</doc>\n        <type name=\"Error\" c:type=\"const GError*\" gs:managed-name=\"Error\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free\" c:identifier=\"g_error_free\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees a #GError and associated resources.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"error\" transfer-ownership=\"none\" gs:managed-name=\"error\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GError</doc>\n        <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"matches\" c:identifier=\"g_error_matches\" gs:managed-name=\"Matches\">\n    <doc xml:space=\"preserve\">Returns %TRUE if @error matches @domain and @code, %FALSE\notherwise. In particular, when @error is %NULL, %FALSE will\nbe returned.\n\nIf @domain contains a `FAILED` (or otherwise generic) error code,\nyou should generally not check for it explicitly, but should\ninstead treat any not-explicitly-recognized error code as being\nequilalent to the `FAILED` code. This way, if the domain is\nextended in the future to provide a more specific error code for\na certain case, your code will still work.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">whether @error has @domain and @code</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"error\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"error\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GError or %NULL</doc>\n        <type name=\"Error\" c:type=\"const GError*\" gs:managed-name=\"Error\" />\n      </instance-parameter>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">an error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">an error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <function name=\"set_error_literal\" c:identifier=\"g_set_error_literal\" version=\"2.18\" gs:managed-name=\"SetErrorLiteral\">\n    <doc xml:space=\"preserve\">Does nothing if @err is %NULL; if @err is non-%NULL, then *@err\nmust be %NULL. A new #GError is created and assigned to *@err.\nUnlike g_set_error(), @message is not a printf()-style format string.\nUse this function if @message contains text you don't have control over,\nthat could include printf() escape sequences.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"err\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"err\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a return location for a #GError, or %NULL</doc>\n        <type name=\"Error\" c:type=\"GError**\" gs:managed-name=\"Error\" />\n      </parameter>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"err\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"err\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a return location for a #GError, or %NULL</doc>\n        <type name=\"Error\" c:type=\"GError**\" gs:managed-name=\"Error\" />\n      </parameter>\n      <parameter name=\"domain\" transfer-ownership=\"none\" gs:managed-name=\"domain\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n        <doc xml:space=\"preserve\">error domain</doc>\n        <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n      </parameter>\n      <parameter name=\"code\" transfer-ownership=\"none\" gs:managed-name=\"code\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">error code</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"propagate_error\" c:identifier=\"g_propagate_error\" gs:managed-name=\"PropagateError\">\n    <doc xml:space=\"preserve\">If @dest is %NULL, free @src; otherwise, moves @src into *@dest.\nThe error variable @dest points to must be %NULL.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"dest\" transfer-ownership=\"none\" gs:managed-name=\"dest\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error return location</doc>\n        <type name=\"Error\" c:type=\"GError**\" gs:managed-name=\"Error\" />\n      </parameter>\n      <parameter name=\"src\" transfer-ownership=\"none\" gs:managed-name=\"src\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error to move into the return location</doc>\n        <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"dest\" transfer-ownership=\"none\" gs:managed-name=\"dest\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error return location</doc>\n        <type name=\"Error\" c:type=\"GError**\" gs:managed-name=\"Error\" />\n      </parameter>\n      <parameter name=\"src\" transfer-ownership=\"none\" gs:managed-name=\"src\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">error to move into the return location</doc>\n        <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"clear_error\" c:identifier=\"g_clear_error\" throws=\"1\" gs:managed-name=\"ClearError\">\n    <doc xml:space=\"preserve\">If @err is %NULL, does nothing. If @err is non-%NULL,\ncalls g_error_free() on *@err and sets *@err to %NULL.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n  </function>\n</record>")]
    public partial class Error : GISharp.Core.OwnedOpaque<GISharp.GLib.Error>
    {
        public Error(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GError; unlike g_error_new(), @message is
        /// not a printf()-style format string. Use this function if
        /// @message contains text you don't have control over,
        /// that could include printf() escape sequences.
        /// </summary>
        /// <param name="domain">
        /// error domain
        /// </param>
        /// <param name="code">
        /// error code
        /// </param>
        /// <param name="message">
        /// error message
        /// </param>
        /// <returns>
        /// a new #GError
        /// </returns>
        public Error(
            GISharp.GLib.Quark domain,
            System.Int32 code,
            System.String message) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GError with the given @domain and @code,
        /// and a message formatted with @format.
        /// </summary>
        /// <param name="domain">
        /// error domain
        /// </param>
        /// <param name="code">
        /// error code
        /// </param>
        /// <param name="format">
        /// printf()-style format for error message
        /// </param>
        /// <param name="args">
        /// #va_list of parameters for the message format
        /// </param>
        /// <returns>
        /// a new #GError
        /// </returns>
        [GISharp.Core.Since("2.22")]
        public Error(
            GISharp.GLib.Quark domain,
            System.Int32 code,
            System.String format,
            System.Object[] args) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GError; unlike g_error_new(), @message is
        /// not a printf()-style format string. Use this function if
        /// @message contains text you don't have control over,
        /// that could include printf() escape sequences.
        /// </summary>
        /// <param name="domain">
        /// error domain
        /// </param>
        /// <param name="code">
        /// error code
        /// </param>
        /// <param name="message">
        /// error message
        /// </param>
        /// <returns>
        /// a new #GError
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_error_new_literal(
            [System.Runtime.InteropServices.In()] GISharp.GLib.Quark domain,
            [System.Runtime.InteropServices.In()] System.Int32 code,
            [System.Runtime.InteropServices.In()] System.IntPtr message);

        /// <summary>
        /// Creates a new #GError with the given @domain and @code,
        /// and a message formatted with @format.
        /// </summary>
        /// <param name="domain">
        /// error domain
        /// </param>
        /// <param name="code">
        /// error code
        /// </param>
        /// <param name="format">
        /// printf()-style format for error message
        /// </param>
        /// <param name="args">
        /// #va_list of parameters for the message format
        /// </param>
        /// <returns>
        /// a new #GError
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern System.IntPtr g_error_new_valist(
            [System.Runtime.InteropServices.In()] GISharp.GLib.Quark domain,
            [System.Runtime.InteropServices.In()] System.Int32 code,
            [System.Runtime.InteropServices.In()] System.IntPtr format,
            [System.Runtime.InteropServices.In()] System.IntPtr args);

        /// <summary>
        /// Does nothing if @err is %NULL; if @err is non-%NULL, then *@err
        /// must be %NULL. A new #GError is created and assigned to *@err.
        /// Unlike g_set_error(), @message is not a printf()-style format string.
        /// Use this function if @message contains text you don't have control over,
        /// that could include printf() escape sequences.
        /// </summary>
        /// <param name="err">
        /// a return location for a #GError, or %NULL
        /// </param>
        /// <param name="domain">
        /// error domain
        /// </param>
        /// <param name="code">
        /// error code
        /// </param>
        /// <param name="message">
        /// error message
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.18")]
        static extern void g_set_error_literal(
            [System.Runtime.InteropServices.In()] System.IntPtr err,
            [System.Runtime.InteropServices.In()] GISharp.GLib.Quark domain,
            [System.Runtime.InteropServices.In()] System.Int32 code,
            [System.Runtime.InteropServices.In()] System.IntPtr message);

        /// <summary>
        /// Does nothing if @err is %NULL; if @err is non-%NULL, then *@err
        /// must be %NULL. A new #GError is created and assigned to *@err.
        /// Unlike g_set_error(), @message is not a printf()-style format string.
        /// Use this function if @message contains text you don't have control over,
        /// that could include printf() escape sequences.
        /// </summary>
        /// <param name="err">
        /// a return location for a #GError, or %NULL
        /// </param>
        /// <param name="domain">
        /// error domain
        /// </param>
        /// <param name="code">
        /// error code
        /// </param>
        /// <param name="message">
        /// error message
        /// </param>
        [GISharp.Core.Since("2.18")]
        public static void SetErrorLiteral(
            GISharp.GLib.Error err,
            GISharp.GLib.Quark domain,
            System.Int32 code,
            System.String message)
        {
        }

        /// <summary>
        /// If @dest is %NULL, free @src; otherwise, moves @src into *@dest.
        /// The error variable @dest points to must be %NULL.
        /// </summary>
        /// <param name="dest">
        /// error return location
        /// </param>
        /// <param name="src">
        /// error to move into the return location
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_propagate_error(
            [System.Runtime.InteropServices.In()] System.IntPtr dest,
            [System.Runtime.InteropServices.In()] System.IntPtr src);

        /// <summary>
        /// If @dest is %NULL, free @src; otherwise, moves @src into *@dest.
        /// The error variable @dest points to must be %NULL.
        /// </summary>
        /// <param name="dest">
        /// error return location
        /// </param>
        /// <param name="src">
        /// error to move into the return location
        /// </param>
        public static void PropagateError(
            GISharp.GLib.Error dest,
            GISharp.GLib.Error src)
        {
        }

        /// <summary>
        /// If @err is %NULL, does nothing. If @err is non-%NULL,
        /// calls g_error_free() on *@err and sets *@err to %NULL.
        /// </summary>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_clear_error();

        /// <summary>
        /// If @err is %NULL, does nothing. If @err is non-%NULL,
        /// calls g_error_free() on *@err and sets *@err to %NULL.
        /// </summary>
        public static void ClearError()
        {
        }

        /// <summary>
        /// Makes a copy of @error.
        /// </summary>
        /// <param name="error">
        /// a #GError
        /// </param>
        /// <returns>
        /// a new #GError
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_error_copy(
            [System.Runtime.InteropServices.In()] System.IntPtr error);

        /// <summary>
        /// Makes a copy of @error.
        /// </summary>
        /// <param name="error">
        /// a #GError
        /// </param>
        /// <returns>
        /// a new #GError
        /// </returns>
        public override GISharp.GLib.Error Copy()
        {
            return default(GISharp.GLib.Error);
        }

        /// <summary>
        /// Frees a #GError and associated resources.
        /// </summary>
        /// <param name="error">
        /// a #GError
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_error_free(
            [System.Runtime.InteropServices.In()] System.IntPtr error);

        /// <summary>
        /// Frees a #GError and associated resources.
        /// </summary>
        /// <param name="error">
        /// a #GError
        /// </param>
        protected override void Free()
        {
        }

        /// <summary>
        /// Returns %TRUE if @error matches @domain and @code, %FALSE
        /// otherwise. In particular, when @error is %NULL, %FALSE will
        /// be returned.
        /// </summary>
        /// <remarks>
        /// If @domain contains a `FAILED` (or otherwise generic) error code,
        /// you should generally not check for it explicitly, but should
        /// instead treat any not-explicitly-recognized error code as being
        /// equilalent to the `FAILED` code. This way, if the domain is
        /// extended in the future to provide a more specific error code for
        /// a certain case, your code will still work.
        /// </remarks>
        /// <param name="error">
        /// a #GError or %NULL
        /// </param>
        /// <param name="domain">
        /// an error domain
        /// </param>
        /// <param name="code">
        /// an error code
        /// </param>
        /// <returns>
        /// whether @error has @domain and @code
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_error_matches(
            [System.Runtime.InteropServices.In()] System.IntPtr error,
            [System.Runtime.InteropServices.In()] GISharp.GLib.Quark domain,
            [System.Runtime.InteropServices.In()] System.Int32 code);

        /// <summary>
        /// Returns %TRUE if @error matches @domain and @code, %FALSE
        /// otherwise. In particular, when @error is %NULL, %FALSE will
        /// be returned.
        /// </summary>
        /// <remarks>
        /// If @domain contains a `FAILED` (or otherwise generic) error code,
        /// you should generally not check for it explicitly, but should
        /// instead treat any not-explicitly-recognized error code as being
        /// equilalent to the `FAILED` code. This way, if the domain is
        /// extended in the future to provide a more specific error code for
        /// a certain case, your code will still work.
        /// </remarks>
        /// <param name="error">
        /// a #GError or %NULL
        /// </param>
        /// <param name="domain">
        /// an error domain
        /// </param>
        /// <param name="code">
        /// an error code
        /// </param>
        /// <returns>
        /// whether @error has @domain and @code
        /// </returns>
        public System.Boolean Matches(
            GISharp.GLib.Quark domain,
            System.Int32 code)
        {
            return default(System.Boolean);
        }
    }

    /// <summary>
    /// The possible errors, used in the @v_error field
    /// of #GTokenValue, when the token is a %G_TOKEN_ERROR.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"ErrorType\" c:type=\"GErrorType\" gs:managed-name=\"ErrorType\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The possible errors, used in the @v_error field\nof #GTokenValue, when the token is a %G_TOKEN_ERROR.</doc>\n  <member name=\"unknown\" value=\"0\" c:identifier=\"G_ERR_UNKNOWN\" gs:managed-name=\"Unknown\">\n    <doc xml:space=\"preserve\">unknown error</doc>\n  </member>\n  <member name=\"unexp_eof\" value=\"1\" c:identifier=\"G_ERR_UNEXP_EOF\" gs:managed-name=\"UnexpEof\">\n    <doc xml:space=\"preserve\">unexpected end of file</doc>\n  </member>\n  <member name=\"unexp_eof_in_string\" value=\"2\" c:identifier=\"G_ERR_UNEXP_EOF_IN_STRING\" gs:managed-name=\"UnexpEofInString\">\n    <doc xml:space=\"preserve\">unterminated string constant</doc>\n  </member>\n  <member name=\"unexp_eof_in_comment\" value=\"3\" c:identifier=\"G_ERR_UNEXP_EOF_IN_COMMENT\" gs:managed-name=\"UnexpEofInComment\">\n    <doc xml:space=\"preserve\">unterminated comment</doc>\n  </member>\n  <member name=\"non_digit_in_const\" value=\"4\" c:identifier=\"G_ERR_NON_DIGIT_IN_CONST\" gs:managed-name=\"NonDigitInConst\">\n    <doc xml:space=\"preserve\">non-digit character in a number</doc>\n  </member>\n  <member name=\"digit_radix\" value=\"5\" c:identifier=\"G_ERR_DIGIT_RADIX\" gs:managed-name=\"DigitRadix\">\n    <doc xml:space=\"preserve\">digit beyond radix in a number</doc>\n  </member>\n  <member name=\"float_radix\" value=\"6\" c:identifier=\"G_ERR_FLOAT_RADIX\" gs:managed-name=\"FloatRadix\">\n    <doc xml:space=\"preserve\">non-decimal floating point number</doc>\n  </member>\n  <member name=\"float_malformed\" value=\"7\" c:identifier=\"G_ERR_FLOAT_MALFORMED\" gs:managed-name=\"FloatMalformed\">\n    <doc xml:space=\"preserve\">malformed floating point number</doc>\n  </member>\n</enumeration>")]
    public enum ErrorType
    {
        /// <summary>
        /// unknown error
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// unexpected end of file
        /// </summary>
        UnexpEof = 1,
        /// <summary>
        /// unterminated string constant
        /// </summary>
        UnexpEofInString = 2,
        /// <summary>
        /// unterminated comment
        /// </summary>
        UnexpEofInComment = 3,
        /// <summary>
        /// non-digit character in a number
        /// </summary>
        NonDigitInConst = 4,
        /// <summary>
        /// digit beyond radix in a number
        /// </summary>
        DigitRadix = 5,
        /// <summary>
        /// non-decimal floating point number
        /// </summary>
        FloatRadix = 6,
        /// <summary>
        /// malformed floating point number
        /// </summary>
        FloatMalformed = 7
    }

    /// <summary>
    /// Declares a type of function which takes an arbitrary
    /// data pointer argument and has no return value. It is
    /// not currently used in GLib or GTK+.
    /// </summary>
    /// <param name="data">
    /// a data pointer
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"FreeFunc\" c:type=\"GFreeFunc\" gs:managed-name=\"FreeFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Declares a type of function which takes an arbitrary\ndata pointer argument and has no return value. It is\nnot currently used in GLib or GTK+.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a data pointer</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a data pointer</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void FreeFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// Declares a type of function which takes an arbitrary
    /// data pointer argument and has no return value. It is
    /// not currently used in GLib or GTK+.
    /// </summary>
    /// <param name="data">
    /// a data pointer
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"FreeFunc\" c:type=\"GFreeFunc\" gs:managed-name=\"FreeFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Declares a type of function which takes an arbitrary\ndata pointer argument and has no return value. It is\nnot currently used in GLib or GTK+.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a data pointer</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a data pointer</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate void FreeFunc(
        System.IntPtr data);

    /// <summary>
    /// A GHashTableIter structure represents an iterator that can be used
    /// to iterate over the elements of a #GHashTable. GHashTableIter
    /// structures are typically allocated on the stack and then initialized
    /// with g_hash_table_iter_init().
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"HashTableIter\" c:type=\"GHashTableIter\" gs:managed-name=\"HashTableIter\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A GHashTableIter structure represents an iterator that can be used\nto iterate over the elements of a #GHashTable. GHashTableIter\nstructures are typically allocated on the stack and then initialized\nwith g_hash_table_iter_init().</doc>\n  <field name=\"dummy1\" readable=\"0\" private=\"1\" gs:managed-name=\"Dummy1\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </field>\n  <field name=\"dummy2\" readable=\"0\" private=\"1\" gs:managed-name=\"Dummy2\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </field>\n  <field name=\"dummy3\" readable=\"0\" private=\"1\" gs:managed-name=\"Dummy3\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </field>\n  <field name=\"dummy4\" readable=\"0\" private=\"1\" gs:managed-name=\"Dummy4\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <type name=\"gint\" c:type=\"int\" gs:managed-name=\"Gint\" />\n  </field>\n  <field name=\"dummy5\" readable=\"0\" private=\"1\" gs:managed-name=\"Dummy5\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </field>\n  <field name=\"dummy6\" readable=\"0\" private=\"1\" gs:managed-name=\"Dummy6\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n  </field>\n  <method name=\"get_hash_table\" c:identifier=\"g_hash_table_iter_get_hash_table\" version=\"2.16\" introspectable=\"0\" gs:managed-name=\"get_HashTable\" gs:property=\"HashTable\">\n    <doc xml:space=\"preserve\">Returns the #GHashTable associated with @iter.</doc>\n    <return-value gs:managed-type=\"GLib.HashTable`2[System.IntPtr,System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GHashTable associated with @iter.</doc>\n      <type name=\"GLib.HashTable\" c:type=\"GHashTable*\" gs:managed-name=\"GLib.HashTable\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"HashTableIter\" gs:unmanaged-type=\"HashTableIter\">\n        <doc xml:space=\"preserve\">an initialized #GHashTableIter</doc>\n        <type name=\"HashTableIter\" c:type=\"GHashTableIter*\" gs:managed-name=\"HashTableIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"init\" c:identifier=\"g_hash_table_iter_init\" version=\"2.16\" gs:managed-name=\"Init\">\n    <doc xml:space=\"preserve\">Initializes a key/value pair iterator and associates it with\n@hash_table. Modifying the hash table after calling this function\ninvalidates the returned iterator.\n|[&lt;!-- language=\"C\" --&gt;\nGHashTableIter iter;\ngpointer key, value;\n\ng_hash_table_iter_init (&amp;iter, hash_table);\nwhile (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))\n  {\n    // do something with key and value\n  }\n]|</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"HashTableIter\" gs:unmanaged-type=\"HashTableIter\">\n        <doc xml:space=\"preserve\">an uninitialized #GHashTableIter</doc>\n        <type name=\"HashTableIter\" c:type=\"GHashTableIter*\" gs:managed-name=\"HashTableIter\" />\n      </instance-parameter>\n      <parameter name=\"hash_table\" transfer-ownership=\"none\" gs:managed-name=\"hashTable\" gs:managed-type=\"GLib.HashTable`2[System.IntPtr,System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GHashTable</doc>\n        <type name=\"GLib.HashTable\" c:type=\"GHashTable*\" gs:managed-name=\"GLib.HashTable\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"hash_table\" transfer-ownership=\"none\" gs:managed-name=\"hashTable\" gs:managed-type=\"GLib.HashTable`2[System.IntPtr,System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GHashTable</doc>\n        <type name=\"GLib.HashTable\" c:type=\"GHashTable*\" gs:managed-name=\"GLib.HashTable\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"next\" c:identifier=\"g_hash_table_iter_next\" version=\"2.16\" gs:managed-name=\"Next\">\n    <doc xml:space=\"preserve\">Advances @iter and retrieves the key and/or value that are now\npointed to as a result of this advancement. If %FALSE is returned,\n@key and @value are not set, and the iterator becomes invalid.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%FALSE if the end of the #GHashTable has been reached.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"HashTableIter\" gs:unmanaged-type=\"HashTableIter\">\n        <doc xml:space=\"preserve\">an initialized #GHashTableIter</doc>\n        <type name=\"HashTableIter\" c:type=\"GHashTableIter*\" gs:managed-name=\"HashTableIter\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a location to store the key, or %NULL</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a location to store the value, or %NULL</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a location to store the key, or %NULL</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a location to store the value, or %NULL</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove\" c:identifier=\"g_hash_table_iter_remove\" version=\"2.16\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes the key/value pair currently pointed to by the iterator\nfrom its associated #GHashTable. Can only be called after\ng_hash_table_iter_next() returned %TRUE, and cannot be called\nmore than once for the same key/value pair.\n\nIf the #GHashTable was created using g_hash_table_new_full(),\nthe key and value are freed using the supplied destroy functions,\notherwise you have to make sure that any dynamically allocated\nvalues are freed yourself.\n\nIt is safe to continue iterating the #GHashTable afterward:\n|[&lt;!-- language=\"C\" --&gt;\nwhile (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))\n  {\n    if (condition)\n      g_hash_table_iter_remove (&amp;iter);\n  }\n]|</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"HashTableIter\" gs:unmanaged-type=\"HashTableIter\">\n        <doc xml:space=\"preserve\">an initialized #GHashTableIter</doc>\n        <type name=\"HashTableIter\" c:type=\"GHashTableIter*\" gs:managed-name=\"HashTableIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"replace\" c:identifier=\"g_hash_table_iter_replace\" version=\"2.30\" gs:managed-name=\"Replace\">\n    <doc xml:space=\"preserve\">Replaces the value currently pointed to by the iterator\nfrom its associated #GHashTable. Can only be called after\ng_hash_table_iter_next() returned %TRUE.\n\nIf you supplied a @value_destroy_func when creating the\n#GHashTable, the old value is freed using that function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"HashTableIter\" gs:unmanaged-type=\"HashTableIter\">\n        <doc xml:space=\"preserve\">an initialized #GHashTableIter</doc>\n        <type name=\"HashTableIter\" c:type=\"GHashTableIter*\" gs:managed-name=\"HashTableIter\" />\n      </instance-parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value to replace with</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value to replace with</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"steal\" c:identifier=\"g_hash_table_iter_steal\" version=\"2.16\" gs:managed-name=\"Steal\">\n    <doc xml:space=\"preserve\">Removes the key/value pair currently pointed to by the\niterator from its associated #GHashTable, without calling\nthe key and value destroy functions. Can only be called\nafter g_hash_table_iter_next() returned %TRUE, and cannot\nbe called more than once for the same key/value pair.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"HashTableIter\" gs:unmanaged-type=\"HashTableIter\">\n        <doc xml:space=\"preserve\">an initialized #GHashTableIter</doc>\n        <type name=\"HashTableIter\" c:type=\"GHashTableIter*\" gs:managed-name=\"HashTableIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct HashTableIter
    {
        public System.IntPtr Dummy1;
        public System.IntPtr Dummy2;
        public System.IntPtr Dummy3;
        public System.Int32 Dummy4;
        public System.Boolean Dummy5;
        public System.IntPtr Dummy6;

        /// <summary>
        /// Returns the #GHashTable associated with @iter.
        /// </summary>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        /// <returns>
        /// the #GHashTable associated with @iter.
        /// </returns>
        [GISharp.Core.Since("2.16")]
        public GISharp.Core.HashTable<GISharp.Core.IWrappedNative, GISharp.Core.IWrappedNative> HashTable
        {
            get
            {
                return default(GISharp.Core.HashTable<GISharp.Core.IWrappedNative, GISharp.Core.IWrappedNative>);
            }
        }

        /// <summary>
        /// Returns the #GHashTable associated with @iter.
        /// </summary>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        /// <returns>
        /// the #GHashTable associated with @iter.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.16")]
        static extern System.IntPtr g_hash_table_iter_get_hash_table(
            [System.Runtime.InteropServices.In()] GISharp.GLib.HashTableIter iter);

        /// <summary>
        /// Initializes a key/value pair iterator and associates it with
        /// @hash_table. Modifying the hash table after calling this function
        /// invalidates the returned iterator.
        /// |[&lt;!-- language="C" --&gt;
        /// GHashTableIter iter;
        /// gpointer key, value;
        /// </summary>
        /// <remarks>
        /// g_hash_table_iter_init (&amp;iter, hash_table);
        /// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
        ///   {
        ///     // do something with key and value
        ///   }
        /// ]|
        /// </remarks>
        /// <param name="iter">
        /// an uninitialized #GHashTableIter
        /// </param>
        /// <param name="hashTable">
        /// a #GHashTable
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.16")]
        static extern void g_hash_table_iter_init(
            [System.Runtime.InteropServices.In()] GISharp.GLib.HashTableIter iter,
            [System.Runtime.InteropServices.In()] System.IntPtr hashTable);

        /// <summary>
        /// Initializes a key/value pair iterator and associates it with
        /// @hash_table. Modifying the hash table after calling this function
        /// invalidates the returned iterator.
        /// |[&lt;!-- language="C" --&gt;
        /// GHashTableIter iter;
        /// gpointer key, value;
        /// </summary>
        /// <remarks>
        /// g_hash_table_iter_init (&amp;iter, hash_table);
        /// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
        ///   {
        ///     // do something with key and value
        ///   }
        /// ]|
        /// </remarks>
        /// <param name="iter">
        /// an uninitialized #GHashTableIter
        /// </param>
        /// <param name="hashTable">
        /// a #GHashTable
        /// </param>
        [GISharp.Core.Since("2.16")]
        public void Init(
            GISharp.Core.HashTable<GISharp.Core.IWrappedNative, GISharp.Core.IWrappedNative> hashTable)
        {
        }

        /// <summary>
        /// Advances @iter and retrieves the key and/or value that are now
        /// pointed to as a result of this advancement. If %FALSE is returned,
        /// @key and @value are not set, and the iterator becomes invalid.
        /// </summary>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        /// <param name="key">
        /// a location to store the key, or %NULL
        /// </param>
        /// <param name="value">
        /// a location to store the value, or %NULL
        /// </param>
        /// <returns>
        /// %FALSE if the end of the #GHashTable has been reached.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.16")]
        static extern System.Boolean g_hash_table_iter_next(
            [System.Runtime.InteropServices.In()] GISharp.GLib.HashTableIter iter,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Advances @iter and retrieves the key and/or value that are now
        /// pointed to as a result of this advancement. If %FALSE is returned,
        /// @key and @value are not set, and the iterator becomes invalid.
        /// </summary>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        /// <param name="key">
        /// a location to store the key, or %NULL
        /// </param>
        /// <param name="value">
        /// a location to store the value, or %NULL
        /// </param>
        /// <returns>
        /// %FALSE if the end of the #GHashTable has been reached.
        /// </returns>
        [GISharp.Core.Since("2.16")]
        public System.Boolean Next(
            System.IntPtr key,
            System.IntPtr value)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes the key/value pair currently pointed to by the iterator
        /// from its associated #GHashTable. Can only be called after
        /// g_hash_table_iter_next() returned %TRUE, and cannot be called
        /// more than once for the same key/value pair.
        /// </summary>
        /// <remarks>
        /// If the #GHashTable was created using g_hash_table_new_full(),
        /// the key and value are freed using the supplied destroy functions,
        /// otherwise you have to make sure that any dynamically allocated
        /// values are freed yourself.
        /// 
        /// It is safe to continue iterating the #GHashTable afterward:
        /// |[&lt;!-- language="C" --&gt;
        /// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
        ///   {
        ///     if (condition)
        ///       g_hash_table_iter_remove (&amp;iter);
        ///   }
        /// ]|
        /// </remarks>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.16")]
        static extern void g_hash_table_iter_remove(
            [System.Runtime.InteropServices.In()] GISharp.GLib.HashTableIter iter);

        /// <summary>
        /// Removes the key/value pair currently pointed to by the iterator
        /// from its associated #GHashTable. Can only be called after
        /// g_hash_table_iter_next() returned %TRUE, and cannot be called
        /// more than once for the same key/value pair.
        /// </summary>
        /// <remarks>
        /// If the #GHashTable was created using g_hash_table_new_full(),
        /// the key and value are freed using the supplied destroy functions,
        /// otherwise you have to make sure that any dynamically allocated
        /// values are freed yourself.
        /// 
        /// It is safe to continue iterating the #GHashTable afterward:
        /// |[&lt;!-- language="C" --&gt;
        /// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
        ///   {
        ///     if (condition)
        ///       g_hash_table_iter_remove (&amp;iter);
        ///   }
        /// ]|
        /// </remarks>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        [GISharp.Core.Since("2.16")]
        public void Remove()
        {
        }

        /// <summary>
        /// Replaces the value currently pointed to by the iterator
        /// from its associated #GHashTable. Can only be called after
        /// g_hash_table_iter_next() returned %TRUE.
        /// </summary>
        /// <remarks>
        /// If you supplied a @value_destroy_func when creating the
        /// #GHashTable, the old value is freed using that function.
        /// </remarks>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        /// <param name="value">
        /// the value to replace with
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.30")]
        static extern void g_hash_table_iter_replace(
            [System.Runtime.InteropServices.In()] GISharp.GLib.HashTableIter iter,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Replaces the value currently pointed to by the iterator
        /// from its associated #GHashTable. Can only be called after
        /// g_hash_table_iter_next() returned %TRUE.
        /// </summary>
        /// <remarks>
        /// If you supplied a @value_destroy_func when creating the
        /// #GHashTable, the old value is freed using that function.
        /// </remarks>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        /// <param name="value">
        /// the value to replace with
        /// </param>
        [GISharp.Core.Since("2.30")]
        public void Replace(
            System.IntPtr value)
        {
        }

        /// <summary>
        /// Removes the key/value pair currently pointed to by the
        /// iterator from its associated #GHashTable, without calling
        /// the key and value destroy functions. Can only be called
        /// after g_hash_table_iter_next() returned %TRUE, and cannot
        /// be called more than once for the same key/value pair.
        /// </summary>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.16")]
        static extern void g_hash_table_iter_steal(
            [System.Runtime.InteropServices.In()] GISharp.GLib.HashTableIter iter);

        /// <summary>
        /// Removes the key/value pair currently pointed to by the
        /// iterator from its associated #GHashTable, without calling
        /// the key and value destroy functions. Can only be called
        /// after g_hash_table_iter_next() returned %TRUE, and cannot
        /// be called more than once for the same key/value pair.
        /// </summary>
        /// <param name="iter">
        /// an initialized #GHashTableIter
        /// </param>
        [GISharp.Core.Since("2.16")]
        public void Steal()
        {
        }
    }

    /// <summary>
    /// The GKeyFile struct contains only private data
    /// and should not be accessed directly.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"KeyFile\" c:type=\"GKeyFile\" glib:type-name=\"GKeyFile\" glib:get-type=\"g_key_file_get_type\" c:symbol-prefix=\"key_file\" gs:managed-name=\"KeyFile\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The GKeyFile struct contains only private data\nand should not be accessed directly.</doc>\n  <constructor name=\"new\" c:identifier=\"g_key_file_new\" version=\"2.6\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new empty #GKeyFile object. Use\ng_key_file_load_from_file(), g_key_file_load_from_data(),\ng_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to\nread an existing key file.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an empty #GKeyFile.</doc>\n      <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n    </return-value>\n  </constructor>\n  <method name=\"get_boolean\" c:identifier=\"g_key_file_get_boolean\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetBoolean\">\n    <doc xml:space=\"preserve\">Returns the value associated with @key under @group_name as a\nboolean.\n\nIf @key cannot be found then %FALSE is returned and @error is set\nto #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value\nassociated with @key cannot be interpreted as a boolean then %FALSE\nis returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">the value associated with the key as a boolean,\n   or %FALSE if the key was not found or could not be parsed.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_boolean_list\" c:identifier=\"g_key_file_get_boolean_list\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetBooleanList\">\n    <doc xml:space=\"preserve\">Returns the values associated with @key under @group_name as\nbooleans.\n\nIf @key cannot be found then %NULL is returned and @error is set to\n#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated\nwith @key cannot be interpreted as booleans then %NULL is returned\nand @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>\n    <return-value transfer-ownership=\"container\" gs:managed-type=\"System.Boolean[]\" gs:unmanaged-type=\"System.Boolean[]\">\n      <doc xml:space=\"preserve\">\n   the values associated with the key as a list of booleans, or %NULL if the\n   key was not found or could not be parsed. The returned list of booleans\n   should be freed with g_free() when no longer needed.</doc>\n      <array length=\"2\" zero-terminated=\"0\" c:type=\"gboolean*\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <type name=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the number of booleans returned</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_comment\" c:identifier=\"g_key_file_get_comment\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetComment\">\n    <doc xml:space=\"preserve\">Retrieves a comment above @key from @group_name.\nIf @key is %NULL then @comment will be read from above\n@group_name. If both @key and @group_name are %NULL, then\n@comment will be read from above the first group in the file.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a comment that should be freed with g_free()</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_double\" c:identifier=\"g_key_file_get_double\" version=\"2.12\" throws=\"1\" gs:managed-name=\"GetDouble\">\n    <doc xml:space=\"preserve\">Returns the value associated with @key under @group_name as a\ndouble. If @group_name is %NULL, the start_group is used.\n\nIf @key cannot be found then 0.0 is returned and @error is set to\n#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated\nwith @key cannot be interpreted as a double then 0.0 is returned\nand @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n      <doc xml:space=\"preserve\">the value associated with the key as a double, or\n    0.0 if the key was not found or could not be parsed.</doc>\n      <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_double_list\" c:identifier=\"g_key_file_get_double_list\" version=\"2.12\" throws=\"1\" gs:managed-name=\"GetDoubleList\">\n    <doc xml:space=\"preserve\">Returns the values associated with @key under @group_name as\ndoubles.\n\nIf @key cannot be found then %NULL is returned and @error is set to\n#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated\nwith @key cannot be interpreted as doubles then %NULL is returned\nand @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>\n    <return-value transfer-ownership=\"container\" gs:managed-type=\"System.Double[]\" gs:unmanaged-type=\"System.Double[]\">\n      <doc xml:space=\"preserve\">\n    the values associated with the key as a list of doubles, or %NULL if the\n    key was not found or could not be parsed. The returned list of doubles\n    should be freed with g_free() when no longer needed.</doc>\n      <array length=\"2\" zero-terminated=\"0\" c:type=\"gdouble*\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <type name=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the number of doubles returned</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_groups\" c:identifier=\"g_key_file_get_groups\" version=\"2.6\" gs:managed-name=\"GetGroups\">\n    <doc xml:space=\"preserve\">Returns all groups in the key file loaded with @key_file.\nThe array of returned groups will be %NULL-terminated, so\n@length may optionally be %NULL.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n      <doc xml:space=\"preserve\">a newly-allocated %NULL-terminated array of strings.\n  Use g_strfreev() to free it.</doc>\n      <array c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the number of returned groups, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the number of returned groups, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_int64\" c:identifier=\"g_key_file_get_int64\" version=\"2.26\" throws=\"1\" gs:managed-name=\"GetInt64\">\n    <doc xml:space=\"preserve\">Returns the value associated with @key under @group_name as a signed\n64-bit integer. This is similar to g_key_file_get_integer() but can return\n64-bit results without truncation.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n      <doc xml:space=\"preserve\">the value associated with the key as a signed 64-bit integer, or\n0 if the key was not found or could not be parsed.</doc>\n      <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_integer\" c:identifier=\"g_key_file_get_integer\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetInteger\">\n    <doc xml:space=\"preserve\">Returns the value associated with @key under @group_name as an\ninteger.\n\nIf @key cannot be found then 0 is returned and @error is set to\n#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated\nwith @key cannot be interpreted as an integer then 0 is returned\nand @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the value associated with the key as an integer, or\n    0 if the key was not found or could not be parsed.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_integer_list\" c:identifier=\"g_key_file_get_integer_list\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetIntegerList\">\n    <doc xml:space=\"preserve\">Returns the values associated with @key under @group_name as\nintegers.\n\nIf @key cannot be found then %NULL is returned and @error is set to\n#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated\nwith @key cannot be interpreted as integers then %NULL is returned\nand @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>\n    <return-value transfer-ownership=\"container\" gs:managed-type=\"System.Int32[]\" gs:unmanaged-type=\"System.Int32[]\">\n      <doc xml:space=\"preserve\">\n    the values associated with the key as a list of integers, or %NULL if\n    the key was not found or could not be parsed. The returned list of\n    integers should be freed with g_free() when no longer needed.</doc>\n      <array length=\"2\" zero-terminated=\"0\" c:type=\"gint*\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <type name=\"gint\" gs:managed-name=\"Gint\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the number of integers returned</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_keys\" c:identifier=\"g_key_file_get_keys\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetKeys\">\n    <doc xml:space=\"preserve\">Returns all keys for the group name @group_name.  The array of\nreturned keys will be %NULL-terminated, so @length may\noptionally be %NULL. In the event that the @group_name cannot\nbe found, %NULL is returned and @error is set to\n#G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n      <doc xml:space=\"preserve\">a newly-allocated %NULL-terminated array of strings.\n    Use g_strfreev() to free it.</doc>\n      <array c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the number of keys returned, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the number of keys returned, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_locale_string\" c:identifier=\"g_key_file_get_locale_string\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetLocaleString\">\n    <doc xml:space=\"preserve\">Returns the value associated with @key under @group_name\ntranslated in the given @locale if available.  If @locale is\n%NULL then the current locale is assumed.\n\nIf @key cannot be found then %NULL is returned and @error is set\nto #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated\nwith @key cannot be interpreted or no suitable translation can\nbe found then the untranslated value is returned.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated string or %NULL if the specified\n  key cannot be found.</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_locale_string_list\" c:identifier=\"g_key_file_get_locale_string_list\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetLocaleStringList\">\n    <doc xml:space=\"preserve\">Returns the values associated with @key under @group_name\ntranslated in the given @locale if available.  If @locale is\n%NULL then the current locale is assumed.\n\nIf @key cannot be found then %NULL is returned and @error is set\nto #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated\nwith @key cannot be interpreted or no suitable translations\ncan be found then the untranslated values are returned. The\nreturned array is %NULL-terminated, so @length may optionally\nbe %NULL.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated %NULL-terminated string array\n  or %NULL if the key isn't found. The string array should be freed\n  with g_strfreev().</doc>\n      <array length=\"3\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the number of returned strings or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_start_group\" c:identifier=\"g_key_file_get_start_group\" version=\"2.6\" gs:managed-name=\"get_StartGroup\" gs:property=\"StartGroup\">\n    <doc xml:space=\"preserve\">Returns the name of the start group of the file.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">The start group of the key file.</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_string\" c:identifier=\"g_key_file_get_string\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetString\">\n    <doc xml:space=\"preserve\">Returns the string value associated with @key under @group_name.\nUnlike g_key_file_get_value(), this function handles escape sequences\nlike \\s.\n\nIn the event the key cannot be found, %NULL is returned and\n@error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the\nevent that the @group_name cannot be found, %NULL is returned\nand @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated string or %NULL if the specified\n  key cannot be found.</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_string_list\" c:identifier=\"g_key_file_get_string_list\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetStringList\">\n    <doc xml:space=\"preserve\">Returns the values associated with @key under @group_name.\n\nIn the event the key cannot be found, %NULL is returned and\n@error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the\nevent that the @group_name cannot be found, %NULL is returned\nand @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">\n a %NULL-terminated string array or %NULL if the specified\n key cannot be found. The array should be freed with g_strfreev().</doc>\n      <array length=\"2\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the number of returned strings, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_uint64\" c:identifier=\"g_key_file_get_uint64\" version=\"2.26\" throws=\"1\" gs:managed-name=\"GetUint64\">\n    <doc xml:space=\"preserve\">Returns the value associated with @key under @group_name as an unsigned\n64-bit integer. This is similar to g_key_file_get_integer() but can return\nlarge positive results without truncation.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the value associated with the key as an unsigned 64-bit integer,\nor 0 if the key was not found or could not be parsed.</doc>\n      <type name=\"guint64\" c:type=\"guint64\" gs:managed-name=\"Guint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a non-%NULL key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_value\" c:identifier=\"g_key_file_get_value\" version=\"2.6\" throws=\"1\" gs:managed-name=\"GetValue\">\n    <doc xml:space=\"preserve\">Returns the raw value associated with @key under @group_name.\nUse g_key_file_get_string() to retrieve an unescaped UTF-8 string.\n\nIn the event the key cannot be found, %NULL is returned and\n@error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the\nevent that the @group_name cannot be found, %NULL is returned\nand @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated string or %NULL if the specified\n key cannot be found.</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"has_group\" c:identifier=\"g_key_file_has_group\" version=\"2.6\" gs:managed-name=\"HasGroup\">\n    <doc xml:space=\"preserve\">Looks whether the key file has the group @group_name.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @group_name is a part of @key_file, %FALSE\notherwise.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"has_key\" c:identifier=\"g_key_file_has_key\" version=\"2.6\" introspectable=\"0\" throws=\"1\" gs:managed-name=\"HasKey\">\n    <doc xml:space=\"preserve\">Looks whether the key file has the key @key in the group\n@group_name.\n\nNote that this function does not follow the rules for #GError strictly;\nthe return value both carries meaning and signals an error.  To use\nthis function, you must pass a #GError pointer in @error, and check\nwhether it is not %NULL to see if an error occurred.\n\nLanguage bindings should use g_key_file_get_value() to test whether\nor not a key exists.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @key is a part of @group_name, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"load_from_data\" c:identifier=\"g_key_file_load_from_data\" version=\"2.6\" throws=\"1\" gs:managed-name=\"LoadFromData\">\n    <doc xml:space=\"preserve\">Loads a key file from memory into an empty #GKeyFile structure.\nIf the object cannot be created then %error is set to a #GKeyFileError.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a key file could be loaded, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an empty #GKeyFile struct</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">key file loaded in memory</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of @data in bytes (or (gsize)-1 if data is nul-terminated)</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">key file loaded in memory</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of @data in bytes (or (gsize)-1 if data is nul-terminated)</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"load_from_data_dirs\" c:identifier=\"g_key_file_load_from_data_dirs\" version=\"2.6\" throws=\"1\" gs:managed-name=\"LoadFromDataDirs\">\n    <doc xml:space=\"preserve\">This function looks for a key file named @file in the paths\nreturned from g_get_user_data_dir() and g_get_system_data_dirs(),\nloads the file into @key_file and returns the file's full path in\n@full_path.  If the file could not be loaded then an %error is\nset to either a #GFileError or #GKeyFileError.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a key file could be loaded, %FALSE othewise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an empty #GKeyFile struct</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"file\" transfer-ownership=\"none\" gs:managed-name=\"file\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a relative path to a filename to open and parse</doc>\n        <type name=\"filename\" c:type=\"gchar*\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"full_path\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"fullPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">return location for a string containing the full path\n  of the file, or %NULL</doc>\n        <type name=\"filename\" c:type=\"gchar**\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"file\" transfer-ownership=\"none\" gs:managed-name=\"file\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a relative path to a filename to open and parse</doc>\n        <type name=\"filename\" c:type=\"gchar*\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"full_path\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"fullPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">return location for a string containing the full path\n  of the file, or %NULL</doc>\n        <type name=\"filename\" c:type=\"gchar**\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"load_from_dirs\" c:identifier=\"g_key_file_load_from_dirs\" version=\"2.14\" throws=\"1\" gs:managed-name=\"LoadFromDirs\">\n    <doc xml:space=\"preserve\">This function looks for a key file named @file in the paths\nspecified in @search_dirs, loads the file into @key_file and\nreturns the file's full path in @full_path.  If the file could not\nbe loaded then an %error is set to either a #GFileError or\n#GKeyFileError.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a key file could be loaded, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an empty #GKeyFile struct</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"file\" transfer-ownership=\"none\" gs:managed-name=\"file\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a relative path to a filename to open and parse</doc>\n        <type name=\"filename\" c:type=\"gchar*\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"search_dirs\" transfer-ownership=\"none\" gs:managed-name=\"searchDirs\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">%NULL-terminated array of directories to search</doc>\n        <array c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"filename\" gs:managed-name=\"Filename\" />\n        </array>\n      </parameter>\n      <parameter name=\"full_path\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"fullPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">return location for a string containing the full path\n  of the file, or %NULL</doc>\n        <type name=\"filename\" c:type=\"gchar**\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"file\" transfer-ownership=\"none\" gs:managed-name=\"file\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a relative path to a filename to open and parse</doc>\n        <type name=\"filename\" c:type=\"gchar*\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"search_dirs\" transfer-ownership=\"none\" gs:managed-name=\"searchDirs\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">%NULL-terminated array of directories to search</doc>\n        <array c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"filename\" gs:managed-name=\"Filename\" />\n        </array>\n      </parameter>\n      <parameter name=\"full_path\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"fullPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">return location for a string containing the full path\n  of the file, or %NULL</doc>\n        <type name=\"filename\" c:type=\"gchar**\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"load_from_file\" c:identifier=\"g_key_file_load_from_file\" version=\"2.6\" throws=\"1\" gs:managed-name=\"LoadFromFile\">\n    <doc xml:space=\"preserve\">Loads a key file into an empty #GKeyFile structure.\nIf the file could not be loaded then @error is set to\neither a #GFileError or #GKeyFileError.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a key file could be loaded, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an empty #GKeyFile struct</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"file\" transfer-ownership=\"none\" gs:managed-name=\"file\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the path of a filename to load, in the GLib filename encoding</doc>\n        <type name=\"filename\" c:type=\"gchar*\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"file\" transfer-ownership=\"none\" gs:managed-name=\"file\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the path of a filename to load, in the GLib filename encoding</doc>\n        <type name=\"filename\" c:type=\"gchar*\" gs:managed-name=\"Filename\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"KeyFileFlags\" gs:unmanaged-type=\"KeyFileFlags\">\n        <doc xml:space=\"preserve\">flags from #GKeyFileFlags</doc>\n        <type name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_key_file_ref\" version=\"2.32\" introspectable=\"0\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count of @key_file.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the same @key_file.</doc>\n      <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove_comment\" c:identifier=\"g_key_file_remove_comment\" version=\"2.6\" throws=\"1\" gs:managed-name=\"RemoveComment\">\n    <doc xml:space=\"preserve\">Removes a comment above @key from @group_name.\nIf @key is %NULL then @comment will be removed above @group_name.\nIf both @key and @group_name are %NULL, then @comment will\nbe removed above the first group in the file.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the comment was removed, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_group\" c:identifier=\"g_key_file_remove_group\" version=\"2.6\" throws=\"1\" gs:managed-name=\"RemoveGroup\">\n    <doc xml:space=\"preserve\">Removes the specified group, @group_name,\nfrom the key file.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the group was removed, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_key\" c:identifier=\"g_key_file_remove_key\" version=\"2.6\" throws=\"1\" gs:managed-name=\"RemoveKey\">\n    <doc xml:space=\"preserve\">Removes @key in @group_name from the key file.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the key was removed, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key name to remove</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key name to remove</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"save_to_file\" c:identifier=\"g_key_file_save_to_file\" version=\"2.40\" throws=\"1\" gs:managed-name=\"SaveToFile\">\n    <doc xml:space=\"preserve\">Writes the contents of @key_file to @filename using\ng_file_set_contents().\n\nThis function can fail for any of the reasons that\ng_file_set_contents() may fail.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if successful, else %FALSE with @error set</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"filename\" transfer-ownership=\"none\" gs:managed-name=\"filename\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the name of the file to write to</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"filename\" transfer-ownership=\"none\" gs:managed-name=\"filename\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the name of the file to write to</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_boolean\" c:identifier=\"g_key_file_set_boolean\" version=\"2.6\" gs:managed-name=\"SetBoolean\">\n    <doc xml:space=\"preserve\">Associates a new boolean value with @key under @group_name.\nIf @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE or %FALSE</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE or %FALSE</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_boolean_list\" c:identifier=\"g_key_file_set_boolean_list\" version=\"2.6\" gs:managed-name=\"SetBooleanList\">\n    <doc xml:space=\"preserve\">Associates a list of boolean values with @key under @group_name.\nIf @key cannot be found then it is created.\nIf @group_name is %NULL, the start_group is used.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.Boolean[]\" gs:unmanaged-type=\"System.Boolean[]\">\n        <doc xml:space=\"preserve\">an array of boolean values</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"gboolean\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n          <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">length of @list</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.Boolean[]\" gs:unmanaged-type=\"System.Boolean[]\">\n        <doc xml:space=\"preserve\">an array of boolean values</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"gboolean\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n          <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_comment\" c:identifier=\"g_key_file_set_comment\" version=\"2.6\" throws=\"1\" gs:managed-name=\"SetComment\">\n    <doc xml:space=\"preserve\">Places a comment above @key from @group_name.\nIf @key is %NULL then @comment will be written above @group_name.\nIf both @key and @group_name  are %NULL, then @comment will be\nwritten above the first group in the file.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the comment was written, %FALSE otherwise</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"comment\" transfer-ownership=\"none\" gs:managed-name=\"comment\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a comment</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"comment\" transfer-ownership=\"none\" gs:managed-name=\"comment\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a comment</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_double\" c:identifier=\"g_key_file_set_double\" version=\"2.12\" gs:managed-name=\"SetDouble\">\n    <doc xml:space=\"preserve\">Associates a new double value with @key under @group_name.\nIf @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">an double value</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">an double value</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_double_list\" c:identifier=\"g_key_file_set_double_list\" version=\"2.12\" gs:managed-name=\"SetDoubleList\">\n    <doc xml:space=\"preserve\">Associates a list of double values with @key under\n@group_name.  If @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.Double[]\" gs:unmanaged-type=\"System.Double[]\">\n        <doc xml:space=\"preserve\">an array of double values</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"gdouble\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n          <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">number of double values in @list</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.Double[]\" gs:unmanaged-type=\"System.Double[]\">\n        <doc xml:space=\"preserve\">an array of double values</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"gdouble\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n          <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_int64\" c:identifier=\"g_key_file_set_int64\" version=\"2.26\" gs:managed-name=\"SetInt64\">\n    <doc xml:space=\"preserve\">Associates a new integer value with @key under @group_name.\nIf @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">an integer value</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">an integer value</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_integer\" c:identifier=\"g_key_file_set_integer\" version=\"2.6\" gs:managed-name=\"SetInteger\">\n    <doc xml:space=\"preserve\">Associates a new integer value with @key under @group_name.\nIf @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an integer value</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an integer value</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_integer_list\" c:identifier=\"g_key_file_set_integer_list\" version=\"2.6\" gs:managed-name=\"SetIntegerList\">\n    <doc xml:space=\"preserve\">Associates a list of integer values with @key under @group_name.\nIf @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.Int32[]\" gs:unmanaged-type=\"System.Int32[]\">\n        <doc xml:space=\"preserve\">an array of integer values</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"gint\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n          <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">number of integer values in @list</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.Int32[]\" gs:unmanaged-type=\"System.Int32[]\">\n        <doc xml:space=\"preserve\">an array of integer values</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"gint\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n          <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_list_separator\" c:identifier=\"g_key_file_set_list_separator\" version=\"2.6\" gs:managed-name=\"SetListSeparator\">\n    <doc xml:space=\"preserve\">Sets the character which is used to separate\nvalues in lists. Typically ';' or ',' are used\nas separators. The default list separator is ';'.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"separator\" transfer-ownership=\"none\" gs:managed-name=\"separator\" gs:managed-type=\"System.SByte\" gs:unmanaged-type=\"System.SByte\">\n        <doc xml:space=\"preserve\">the separator</doc>\n        <type name=\"gchar\" c:type=\"gchar\" gs:managed-name=\"Gchar\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"separator\" transfer-ownership=\"none\" gs:managed-name=\"separator\" gs:managed-type=\"System.SByte\" gs:unmanaged-type=\"System.SByte\">\n        <doc xml:space=\"preserve\">the separator</doc>\n        <type name=\"gchar\" c:type=\"gchar\" gs:managed-name=\"Gchar\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_locale_string\" c:identifier=\"g_key_file_set_locale_string\" version=\"2.6\" gs:managed-name=\"SetLocaleString\">\n    <doc xml:space=\"preserve\">Associates a string value for @key and @locale under @group_name.\nIf the translation for @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_locale_string_list\" c:identifier=\"g_key_file_set_locale_string_list\" version=\"2.6\" gs:managed-name=\"SetLocaleStringList\">\n    <doc xml:space=\"preserve\">Associates a list of string values for @key and @locale under\n@group_name.  If the translation for @key cannot be found then\nit is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a %NULL-terminated array of locale string values</doc>\n        <array length=\"4\" zero-terminated=\"1\" c:type=\"gchar*\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" c:type=\"gchar\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of @list</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"locale\" transfer-ownership=\"none\" gs:managed-name=\"locale\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a locale identifier</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a %NULL-terminated array of locale string values</doc>\n        <array length=\"4\" zero-terminated=\"1\" c:type=\"gchar*\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" c:type=\"gchar\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_string\" c:identifier=\"g_key_file_set_string\" version=\"2.6\" gs:managed-name=\"SetString\">\n    <doc xml:space=\"preserve\">Associates a new string value with @key under @group_name.\nIf @key cannot be found then it is created.\nIf @group_name cannot be found then it is created.\nUnlike g_key_file_set_value(), this function handles characters\nthat need escaping, such as newlines.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_string_list\" c:identifier=\"g_key_file_set_string_list\" version=\"2.6\" gs:managed-name=\"SetStringList\">\n    <doc xml:space=\"preserve\">Associates a list of string values for @key under @group_name.\nIf @key cannot be found then it is created.\nIf @group_name cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of string values</doc>\n        <array length=\"3\" zero-terminated=\"1\" c:type=\"gchar*\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">number of string values in @list</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of string values</doc>\n        <array length=\"3\" zero-terminated=\"1\" c:type=\"gchar*\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_uint64\" c:identifier=\"g_key_file_set_uint64\" version=\"2.26\" gs:managed-name=\"SetUint64\">\n    <doc xml:space=\"preserve\">Associates a new integer value with @key under @group_name.\nIf @key cannot be found then it is created.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">an integer value</doc>\n        <type name=\"guint64\" c:type=\"guint64\" gs:managed-name=\"Guint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">an integer value</doc>\n        <type name=\"guint64\" c:type=\"guint64\" gs:managed-name=\"Guint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_value\" c:identifier=\"g_key_file_set_value\" version=\"2.6\" gs:managed-name=\"SetValue\">\n    <doc xml:space=\"preserve\">Associates a new value with @key under @group_name.\n\nIf @key cannot be found then it is created. If @group_name cannot\nbe found then it is created. To set an UTF-8 string which may contain\ncharacters that need escaping (such as newlines or spaces), use\ng_key_file_set_string().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"group_name\" transfer-ownership=\"none\" gs:managed-name=\"groupName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a group name</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a key</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"to_data\" c:identifier=\"g_key_file_to_data\" version=\"2.6\" throws=\"1\" gs:managed-name=\"ToData\">\n    <doc xml:space=\"preserve\">This function outputs @key_file as a string.\n\nNote that this function never reports an error,\nso it is safe to pass %NULL as @error.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated string holding\n  the contents of the #GKeyFile</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the length of the\n  returned string, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">return location for the length of the\n  returned string, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_key_file_unref\" version=\"2.32\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count of @key_file by 1. If the reference count\nreaches zero, frees the key file and all its allocated memory.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"key_file\" transfer-ownership=\"none\" gs:managed-name=\"keyFile\" gs:managed-type=\"KeyFile\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GKeyFile</doc>\n        <type name=\"KeyFile\" c:type=\"GKeyFile*\" gs:managed-name=\"KeyFile\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"error_quark\" c:identifier=\"g_key_file_error_quark\" gs:managed-name=\"ErrorQuark\">\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </return-value>\n  </function>\n  <constant name=\"DESKTOP_GROUP\" value=\"Desktop Entry\" c:type=\"G_KEY_FILE_DESKTOP_GROUP\" version=\"2.14\" gs:managed-name=\"DesktopGroup\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">The name of the main group of a desktop entry file, as defined in the\n[Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec).\nConsult the specification for more\ndetails about the meanings of the keys below.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_ACTIONS\" value=\"Actions\" c:type=\"G_KEY_FILE_DESKTOP_KEY_ACTIONS\" gs:managed-name=\"DesktopKeyActions\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_CATEGORIES\" value=\"Categories\" c:type=\"G_KEY_FILE_DESKTOP_KEY_CATEGORIES\" version=\"2.14\" gs:managed-name=\"DesktopKeyCategories\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list\nof strings giving the categories in which the desktop entry\nshould be shown in a menu.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_COMMENT\" value=\"Comment\" c:type=\"G_KEY_FILE_DESKTOP_KEY_COMMENT\" version=\"2.14\" gs:managed-name=\"DesktopKeyComment\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized\nstring giving the tooltip for the desktop entry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_DBUS_ACTIVATABLE\" value=\"DBusActivatable\" c:type=\"G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE\" gs:managed-name=\"DesktopKeyDbusActivatable\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_EXEC\" value=\"Exec\" c:type=\"G_KEY_FILE_DESKTOP_KEY_EXEC\" version=\"2.14\" gs:managed-name=\"DesktopKeyExec\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string\ngiving the command line to execute. It is only valid for desktop\nentries with the `Application` type.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_FULLNAME\" value=\"X-GNOME-FullName\" c:type=\"G_KEY_FILE_DESKTOP_KEY_FULLNAME\" gs:managed-name=\"DesktopKeyFullname\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_GENERIC_NAME\" value=\"GenericName\" c:type=\"G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME\" version=\"2.14\" gs:managed-name=\"DesktopKeyGenericName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized\nstring giving the generic name of the desktop entry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_GETTEXT_DOMAIN\" value=\"X-GNOME-Gettext-Domain\" c:type=\"G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN\" gs:managed-name=\"DesktopKeyGettextDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_HIDDEN\" value=\"Hidden\" c:type=\"G_KEY_FILE_DESKTOP_KEY_HIDDEN\" version=\"2.14\" gs:managed-name=\"DesktopKeyHidden\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean\nstating whether the desktop entry has been deleted by the user.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_ICON\" value=\"Icon\" c:type=\"G_KEY_FILE_DESKTOP_KEY_ICON\" version=\"2.14\" gs:managed-name=\"DesktopKeyIcon\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized\nstring giving the name of the icon to be displayed for the desktop\nentry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_KEYWORDS\" value=\"Keywords\" c:type=\"G_KEY_FILE_DESKTOP_KEY_KEYWORDS\" gs:managed-name=\"DesktopKeyKeywords\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_MIME_TYPE\" value=\"MimeType\" c:type=\"G_KEY_FILE_DESKTOP_KEY_MIME_TYPE\" version=\"2.14\" gs:managed-name=\"DesktopKeyMimeType\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list\nof strings giving the MIME types supported by this desktop entry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_NAME\" value=\"Name\" c:type=\"G_KEY_FILE_DESKTOP_KEY_NAME\" version=\"2.14\" gs:managed-name=\"DesktopKeyName\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized\nstring giving the specific name of the desktop entry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_NOT_SHOW_IN\" value=\"NotShowIn\" c:type=\"G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN\" version=\"2.14\" gs:managed-name=\"DesktopKeyNotShowIn\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of\nstrings identifying the environments that should not display the\ndesktop entry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_NO_DISPLAY\" value=\"NoDisplay\" c:type=\"G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY\" version=\"2.14\" gs:managed-name=\"DesktopKeyNoDisplay\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean\nstating whether the desktop entry should be shown in menus.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_ONLY_SHOW_IN\" value=\"OnlyShowIn\" c:type=\"G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN\" version=\"2.14\" gs:managed-name=\"DesktopKeyOnlyShowIn\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of\nstrings identifying the environments that should display the\ndesktop entry.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_PATH\" value=\"Path\" c:type=\"G_KEY_FILE_DESKTOP_KEY_PATH\" version=\"2.14\" gs:managed-name=\"DesktopKeyPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string\ncontaining the working directory to run the program in. It is only\nvalid for desktop entries with the `Application` type.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_STARTUP_NOTIFY\" value=\"StartupNotify\" c:type=\"G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY\" version=\"2.14\" gs:managed-name=\"DesktopKeyStartupNotify\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean\nstating whether the application supports the\n[Startup Notification Protocol Specification](http://www.freedesktop.org/Standards/startup-notification-spec).</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_STARTUP_WM_CLASS\" value=\"StartupWMClass\" c:type=\"G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS\" version=\"2.14\" gs:managed-name=\"DesktopKeyStartupWmClass\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is string\nidentifying the WM class or name hint of a window that the application\nwill create, which can be used to emulate Startup Notification with\nolder applications.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_TERMINAL\" value=\"Terminal\" c:type=\"G_KEY_FILE_DESKTOP_KEY_TERMINAL\" version=\"2.14\" gs:managed-name=\"DesktopKeyTerminal\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean\nstating whether the program should be run in a terminal window.\nIt is only valid for desktop entries with the\n`Application` type.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_TRY_EXEC\" value=\"TryExec\" c:type=\"G_KEY_FILE_DESKTOP_KEY_TRY_EXEC\" version=\"2.14\" gs:managed-name=\"DesktopKeyTryExec\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string\ngiving the file name of a binary on disk used to determine if the\nprogram is actually installed. It is only valid for desktop entries\nwith the `Application` type.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_TYPE\" value=\"Type\" c:type=\"G_KEY_FILE_DESKTOP_KEY_TYPE\" version=\"2.14\" gs:managed-name=\"DesktopKeyType\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string\ngiving the type of the desktop entry. Usually\n#G_KEY_FILE_DESKTOP_TYPE_APPLICATION,\n#G_KEY_FILE_DESKTOP_TYPE_LINK, or\n#G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_URL\" value=\"URL\" c:type=\"G_KEY_FILE_DESKTOP_KEY_URL\" version=\"2.14\" gs:managed-name=\"DesktopKeyUrl\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string\ngiving the URL to access. It is only valid for desktop entries\nwith the `Link` type.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_KEY_VERSION\" value=\"Version\" c:type=\"G_KEY_FILE_DESKTOP_KEY_VERSION\" version=\"2.14\" gs:managed-name=\"DesktopKeyVersion\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string\ngiving the version of the Desktop Entry Specification used for\nthe desktop entry file.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_TYPE_APPLICATION\" value=\"Application\" c:type=\"G_KEY_FILE_DESKTOP_TYPE_APPLICATION\" version=\"2.14\" gs:managed-name=\"DesktopTypeApplication\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop\nentries representing applications.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_TYPE_DIRECTORY\" value=\"Directory\" c:type=\"G_KEY_FILE_DESKTOP_TYPE_DIRECTORY\" version=\"2.14\" gs:managed-name=\"DesktopTypeDirectory\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop\nentries representing directories.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n  <constant name=\"DESKTOP_TYPE_LINK\" value=\"Link\" c:type=\"G_KEY_FILE_DESKTOP_TYPE_LINK\" version=\"2.14\" gs:managed-name=\"DesktopTypeLink\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop\nentries representing links to documents.</doc>\n    <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n  </constant>\n</record>")]
    public partial class KeyFile : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.KeyFile>
    {
        /// <summary>
        /// The name of the main group of a desktop entry file, as defined in the
        /// [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec).
        /// Consult the specification for more
        /// details about the meanings of the keys below.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopGroup = "Desktop Entry";
        public const System.String DesktopKeyActions = "Actions";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
        /// of strings giving the categories in which the desktop entry
        /// should be shown in a menu.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyCategories = "Categories";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
        /// string giving the tooltip for the desktop entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyComment = "Comment";
        public const System.String DesktopKeyDbusActivatable = "DBusActivatable";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
        /// giving the command line to execute. It is only valid for desktop
        /// entries with the `Application` type.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyExec = "Exec";
        public const System.String DesktopKeyFullname = "X-GNOME-FullName";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
        /// string giving the generic name of the desktop entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyGenericName = "GenericName";
        public const System.String DesktopKeyGettextDomain = "X-GNOME-Gettext-Domain";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
        /// stating whether the desktop entry has been deleted by the user.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyHidden = "Hidden";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
        /// string giving the name of the icon to be displayed for the desktop
        /// entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyIcon = "Icon";
        public const System.String DesktopKeyKeywords = "Keywords";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
        /// of strings giving the MIME types supported by this desktop entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyMimeType = "MimeType";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
        /// string giving the specific name of the desktop entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyName = "Name";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
        /// strings identifying the environments that should not display the
        /// desktop entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyNotShowIn = "NotShowIn";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
        /// stating whether the desktop entry should be shown in menus.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyNoDisplay = "NoDisplay";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
        /// strings identifying the environments that should display the
        /// desktop entry.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyOnlyShowIn = "OnlyShowIn";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
        /// containing the working directory to run the program in. It is only
        /// valid for desktop entries with the `Application` type.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyPath = "Path";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
        /// stating whether the application supports the
        /// [Startup Notification Protocol Specification](http://www.freedesktop.org/Standards/startup-notification-spec).
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyStartupNotify = "StartupNotify";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is string
        /// identifying the WM class or name hint of a window that the application
        /// will create, which can be used to emulate Startup Notification with
        /// older applications.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyStartupWmClass = "StartupWMClass";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
        /// stating whether the program should be run in a terminal window.
        /// It is only valid for desktop entries with the
        /// `Application` type.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyTerminal = "Terminal";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
        /// giving the file name of a binary on disk used to determine if the
        /// program is actually installed. It is only valid for desktop entries
        /// with the `Application` type.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyTryExec = "TryExec";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
        /// giving the type of the desktop entry. Usually
        /// #G_KEY_FILE_DESKTOP_TYPE_APPLICATION,
        /// #G_KEY_FILE_DESKTOP_TYPE_LINK, or
        /// #G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyType = "Type";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
        /// giving the URL to access. It is only valid for desktop entries
        /// with the `Link` type.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyUrl = "URL";

        /// <summary>
        /// A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
        /// giving the version of the Desktop Entry Specification used for
        /// the desktop entry file.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopKeyVersion = "Version";

        /// <summary>
        /// The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
        /// entries representing applications.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopTypeApplication = "Application";

        /// <summary>
        /// The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
        /// entries representing directories.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopTypeDirectory = "Directory";

        /// <summary>
        /// The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
        /// entries representing links to documents.
        /// </summary>
        [GISharp.Core.Since("2.14")]
        public const System.String DesktopTypeLink = "Link";

        /// <summary>
        /// Returns the name of the start group of the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <returns>
        /// The start group of the key file.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String StartGroup
        {
            get
            {
                return default(System.String);
            }
        }

        public KeyFile(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new empty #GKeyFile object. Use
        /// g_key_file_load_from_file(), g_key_file_load_from_data(),
        /// g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to
        /// read an existing key file.
        /// </summary>
        /// <returns>
        /// an empty #GKeyFile.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public KeyFile() : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new empty #GKeyFile object. Use
        /// g_key_file_load_from_file(), g_key_file_load_from_data(),
        /// g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to
        /// read an existing key file.
        /// </summary>
        /// <returns>
        /// an empty #GKeyFile.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_new();
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.Quark g_key_file_error_quark();

        public static GISharp.GLib.Quark ErrorQuark()
        {
            return default(GISharp.GLib.Quark);
        }

        /// <summary>
        /// Returns the value associated with @key under @group_name as a
        /// boolean.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %FALSE is returned and @error is set
        /// to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
        /// associated with @key cannot be interpreted as a boolean then %FALSE
        /// is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// the value associated with the key as a boolean,
        ///    or %FALSE if the key was not found or could not be parsed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_get_boolean(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the value associated with @key under @group_name as a
        /// boolean.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %FALSE is returned and @error is set
        /// to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
        /// associated with @key cannot be interpreted as a boolean then %FALSE
        /// is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// the value associated with the key as a boolean,
        ///    or %FALSE if the key was not found or could not be parsed.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean GetBoolean(
            System.String groupName,
            System.String key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns the values associated with @key under @group_name as
        /// booleans.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
        /// with @key cannot be interpreted as booleans then %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// the number of booleans returned
        /// </param>
        /// <returns>
        /// 
        ///    the values associated with the key as a list of booleans, or %NULL if the
        ///    key was not found or could not be parsed. The returned list of booleans
        ///    should be freed with g_free() when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 3)]
        static extern System.Boolean[] g_key_file_get_boolean_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns the values associated with @key under @group_name as
        /// booleans.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
        /// with @key cannot be interpreted as booleans then %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// the number of booleans returned
        /// </param>
        /// <returns>
        /// 
        ///    the values associated with the key as a list of booleans, or %NULL if the
        ///    key was not found or could not be parsed. The returned list of booleans
        ///    should be freed with g_free() when no longer needed.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean[] GetBooleanList(
            System.String groupName,
            System.String key)
        {
            return default(System.Boolean[]);
        }

        /// <summary>
        /// Retrieves a comment above @key from @group_name.
        /// If @key is %NULL then @comment will be read from above
        /// @group_name. If both @key and @group_name are %NULL, then
        /// @comment will be read from above the first group in the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name, or %NULL
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// a comment that should be freed with g_free()
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_comment(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Retrieves a comment above @key from @group_name.
        /// If @key is %NULL then @comment will be read from above
        /// @group_name. If both @key and @group_name are %NULL, then
        /// @comment will be read from above the first group in the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name, or %NULL
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// a comment that should be freed with g_free()
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String GetComment(
            System.String groupName,
            System.String key)
        {
            return default(System.String);
        }

        /// <summary>
        /// Returns the value associated with @key under @group_name as a
        /// double. If @group_name is %NULL, the start_group is used.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then 0.0 is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
        /// with @key cannot be interpreted as a double then 0.0 is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// the value associated with the key as a double, or
        ///     0.0 if the key was not found or could not be parsed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern System.Double g_key_file_get_double(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the value associated with @key under @group_name as a
        /// double. If @group_name is %NULL, the start_group is used.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then 0.0 is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
        /// with @key cannot be interpreted as a double then 0.0 is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// the value associated with the key as a double, or
        ///     0.0 if the key was not found or could not be parsed.
        /// </returns>
        [GISharp.Core.Since("2.12")]
        public System.Double GetDouble(
            System.String groupName,
            System.String key)
        {
            return default(System.Double);
        }

        /// <summary>
        /// Returns the values associated with @key under @group_name as
        /// doubles.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
        /// with @key cannot be interpreted as doubles then %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// the number of doubles returned
        /// </param>
        /// <returns>
        /// 
        ///     the values associated with the key as a list of doubles, or %NULL if the
        ///     key was not found or could not be parsed. The returned list of doubles
        ///     should be freed with g_free() when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 3)]
        static extern System.Double[] g_key_file_get_double_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns the values associated with @key under @group_name as
        /// doubles.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
        /// with @key cannot be interpreted as doubles then %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// the number of doubles returned
        /// </param>
        /// <returns>
        /// 
        ///     the values associated with the key as a list of doubles, or %NULL if the
        ///     key was not found or could not be parsed. The returned list of doubles
        ///     should be freed with g_free() when no longer needed.
        /// </returns>
        [GISharp.Core.Since("2.12")]
        public System.Double[] GetDoubleList(
            System.String groupName,
            System.String key)
        {
            return default(System.Double[]);
        }

        /// <summary>
        /// Returns all groups in the key file loaded with @key_file.
        /// The array of returned groups will be %NULL-terminated, so
        /// @length may optionally be %NULL.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="length">
        /// return location for the number of returned groups, or %NULL
        /// </param>
        /// <returns>
        /// a newly-allocated %NULL-terminated array of strings.
        ///   Use g_strfreev() to free it.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr[] g_key_file_get_groups(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns all groups in the key file loaded with @key_file.
        /// The array of returned groups will be %NULL-terminated, so
        /// @length may optionally be %NULL.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="length">
        /// return location for the number of returned groups, or %NULL
        /// </param>
        /// <returns>
        /// a newly-allocated %NULL-terminated array of strings.
        ///   Use g_strfreev() to free it.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String[] GetGroups(
            out System.UInt64 length)
        {
            length = default(System.UInt64);
            return default(System.String[]);
        }

        /// <summary>
        /// Returns the value associated with @key under @group_name as a signed
        /// 64-bit integer. This is similar to g_key_file_get_integer() but can return
        /// 64-bit results without truncation.
        /// </summary>
        /// <param name="keyFile">
        /// a non-%NULL #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a non-%NULL group name
        /// </param>
        /// <param name="key">
        /// a non-%NULL key
        /// </param>
        /// <returns>
        /// the value associated with the key as a signed 64-bit integer, or
        /// 0 if the key was not found or could not be parsed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int64 g_key_file_get_int64(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the value associated with @key under @group_name as a signed
        /// 64-bit integer. This is similar to g_key_file_get_integer() but can return
        /// 64-bit results without truncation.
        /// </summary>
        /// <param name="keyFile">
        /// a non-%NULL #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a non-%NULL group name
        /// </param>
        /// <param name="key">
        /// a non-%NULL key
        /// </param>
        /// <returns>
        /// the value associated with the key as a signed 64-bit integer, or
        /// 0 if the key was not found or could not be parsed.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int64 GetInt64(
            System.String groupName,
            System.String key)
        {
            return default(System.Int64);
        }

        /// <summary>
        /// Returns the value associated with @key under @group_name as an
        /// integer.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then 0 is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
        /// with @key cannot be interpreted as an integer then 0 is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// the value associated with the key as an integer, or
        ///     0 if the key was not found or could not be parsed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Int32 g_key_file_get_integer(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the value associated with @key under @group_name as an
        /// integer.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then 0 is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
        /// with @key cannot be interpreted as an integer then 0 is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// the value associated with the key as an integer, or
        ///     0 if the key was not found or could not be parsed.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Int32 GetInteger(
            System.String groupName,
            System.String key)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Returns the values associated with @key under @group_name as
        /// integers.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
        /// with @key cannot be interpreted as integers then %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// the number of integers returned
        /// </param>
        /// <returns>
        /// 
        ///     the values associated with the key as a list of integers, or %NULL if
        ///     the key was not found or could not be parsed. The returned list of
        ///     integers should be freed with g_free() when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 3)]
        static extern System.Int32[] g_key_file_get_integer_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns the values associated with @key under @group_name as
        /// integers.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
        /// with @key cannot be interpreted as integers then %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// the number of integers returned
        /// </param>
        /// <returns>
        /// 
        ///     the values associated with the key as a list of integers, or %NULL if
        ///     the key was not found or could not be parsed. The returned list of
        ///     integers should be freed with g_free() when no longer needed.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Int32[] GetIntegerList(
            System.String groupName,
            System.String key)
        {
            return default(System.Int32[]);
        }

        /// <summary>
        /// Returns all keys for the group name @group_name.  The array of
        /// returned keys will be %NULL-terminated, so @length may
        /// optionally be %NULL. In the event that the @group_name cannot
        /// be found, %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="length">
        /// return location for the number of keys returned, or %NULL
        /// </param>
        /// <returns>
        /// a newly-allocated %NULL-terminated array of strings.
        ///     Use g_strfreev() to free it.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr[] g_key_file_get_keys(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns all keys for the group name @group_name.  The array of
        /// returned keys will be %NULL-terminated, so @length may
        /// optionally be %NULL. In the event that the @group_name cannot
        /// be found, %NULL is returned and @error is set to
        /// #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="length">
        /// return location for the number of keys returned, or %NULL
        /// </param>
        /// <returns>
        /// a newly-allocated %NULL-terminated array of strings.
        ///     Use g_strfreev() to free it.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String[] GetKeys(
            System.String groupName,
            out System.UInt64 length)
        {
            length = default(System.UInt64);
            return default(System.String[]);
        }

        /// <summary>
        /// Returns the value associated with @key under @group_name
        /// translated in the given @locale if available.  If @locale is
        /// %NULL then the current locale is assumed.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set
        /// to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
        /// with @key cannot be interpreted or no suitable translation can
        /// be found then the untranslated value is returned.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier or %NULL
        /// </param>
        /// <returns>
        /// a newly allocated string or %NULL if the specified
        ///   key cannot be found.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_locale_string(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr locale);

        /// <summary>
        /// Returns the value associated with @key under @group_name
        /// translated in the given @locale if available.  If @locale is
        /// %NULL then the current locale is assumed.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set
        /// to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
        /// with @key cannot be interpreted or no suitable translation can
        /// be found then the untranslated value is returned.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier or %NULL
        /// </param>
        /// <returns>
        /// a newly allocated string or %NULL if the specified
        ///   key cannot be found.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String GetLocaleString(
            System.String groupName,
            System.String key,
            System.String locale)
        {
            return default(System.String);
        }

        /// <summary>
        /// Returns the values associated with @key under @group_name
        /// translated in the given @locale if available.  If @locale is
        /// %NULL then the current locale is assumed.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set
        /// to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
        /// with @key cannot be interpreted or no suitable translations
        /// can be found then the untranslated values are returned. The
        /// returned array is %NULL-terminated, so @length may optionally
        /// be %NULL.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier or %NULL
        /// </param>
        /// <param name="length">
        /// return location for the number of returned strings or %NULL
        /// </param>
        /// <returns>
        /// a newly allocated %NULL-terminated string array
        ///   or %NULL if the key isn't found. The string array should be freed
        ///   with g_strfreev().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_locale_string_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr locale,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns the values associated with @key under @group_name
        /// translated in the given @locale if available.  If @locale is
        /// %NULL then the current locale is assumed.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then %NULL is returned and @error is set
        /// to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
        /// with @key cannot be interpreted or no suitable translations
        /// can be found then the untranslated values are returned. The
        /// returned array is %NULL-terminated, so @length may optionally
        /// be %NULL.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier or %NULL
        /// </param>
        /// <param name="length">
        /// return location for the number of returned strings or %NULL
        /// </param>
        /// <returns>
        /// a newly allocated %NULL-terminated string array
        ///   or %NULL if the key isn't found. The string array should be freed
        ///   with g_strfreev().
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String[] GetLocaleStringList(
            System.String groupName,
            System.String key,
            System.String locale)
        {
            return default(System.String[]);
        }

        /// <summary>
        /// Returns the name of the start group of the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <returns>
        /// The start group of the key file.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_start_group(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile);

        /// <summary>
        /// Returns the string value associated with @key under @group_name.
        /// Unlike g_key_file_get_value(), this function handles escape sequences
        /// like \s.
        /// </summary>
        /// <remarks>
        /// In the event the key cannot be found, %NULL is returned and
        /// @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
        /// event that the @group_name cannot be found, %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// a newly allocated string or %NULL if the specified
        ///   key cannot be found.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_string(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the string value associated with @key under @group_name.
        /// Unlike g_key_file_get_value(), this function handles escape sequences
        /// like \s.
        /// </summary>
        /// <remarks>
        /// In the event the key cannot be found, %NULL is returned and
        /// @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
        /// event that the @group_name cannot be found, %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// a newly allocated string or %NULL if the specified
        ///   key cannot be found.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String GetString(
            System.String groupName,
            System.String key)
        {
            return default(System.String);
        }

        /// <summary>
        /// Returns the values associated with @key under @group_name.
        /// </summary>
        /// <remarks>
        /// In the event the key cannot be found, %NULL is returned and
        /// @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
        /// event that the @group_name cannot be found, %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// return location for the number of returned strings, or %NULL
        /// </param>
        /// <returns>
        /// 
        ///  a %NULL-terminated string array or %NULL if the specified
        ///  key cannot be found. The array should be freed with g_strfreev().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_string_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns the values associated with @key under @group_name.
        /// </summary>
        /// <remarks>
        /// In the event the key cannot be found, %NULL is returned and
        /// @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
        /// event that the @group_name cannot be found, %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="length">
        /// return location for the number of returned strings, or %NULL
        /// </param>
        /// <returns>
        /// 
        ///  a %NULL-terminated string array or %NULL if the specified
        ///  key cannot be found. The array should be freed with g_strfreev().
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String[] GetStringList(
            System.String groupName,
            System.String key)
        {
            return default(System.String[]);
        }

        /// <summary>
        /// Returns the value associated with @key under @group_name as an unsigned
        /// 64-bit integer. This is similar to g_key_file_get_integer() but can return
        /// large positive results without truncation.
        /// </summary>
        /// <param name="keyFile">
        /// a non-%NULL #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a non-%NULL group name
        /// </param>
        /// <param name="key">
        /// a non-%NULL key
        /// </param>
        /// <returns>
        /// the value associated with the key as an unsigned 64-bit integer,
        /// or 0 if the key was not found or could not be parsed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.UInt64 g_key_file_get_uint64(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the value associated with @key under @group_name as an unsigned
        /// 64-bit integer. This is similar to g_key_file_get_integer() but can return
        /// large positive results without truncation.
        /// </summary>
        /// <param name="keyFile">
        /// a non-%NULL #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a non-%NULL group name
        /// </param>
        /// <param name="key">
        /// a non-%NULL key
        /// </param>
        /// <returns>
        /// the value associated with the key as an unsigned 64-bit integer,
        /// or 0 if the key was not found or could not be parsed.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.UInt64 GetUint64(
            System.String groupName,
            System.String key)
        {
            return default(System.UInt64);
        }

        /// <summary>
        /// Returns the raw value associated with @key under @group_name.
        /// Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
        /// </summary>
        /// <remarks>
        /// In the event the key cannot be found, %NULL is returned and
        /// @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
        /// event that the @group_name cannot be found, %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// a newly allocated string or %NULL if the specified
        ///  key cannot be found.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_get_value(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Returns the raw value associated with @key under @group_name.
        /// Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
        /// </summary>
        /// <remarks>
        /// In the event the key cannot be found, %NULL is returned and
        /// @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
        /// event that the @group_name cannot be found, %NULL is returned
        /// and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// a newly allocated string or %NULL if the specified
        ///  key cannot be found.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String GetValue(
            System.String groupName,
            System.String key)
        {
            return default(System.String);
        }

        /// <summary>
        /// Looks whether the key file has the group @group_name.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <returns>
        /// %TRUE if @group_name is a part of @key_file, %FALSE
        /// otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_has_group(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName);

        /// <summary>
        /// Looks whether the key file has the group @group_name.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <returns>
        /// %TRUE if @group_name is a part of @key_file, %FALSE
        /// otherwise.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean HasGroup(
            System.String groupName)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Looks whether the key file has the key @key in the group
        /// @group_name.
        /// </summary>
        /// <remarks>
        /// Note that this function does not follow the rules for #GError strictly;
        /// the return value both carries meaning and signals an error.  To use
        /// this function, you must pass a #GError pointer in @error, and check
        /// whether it is not %NULL to see if an error occurred.
        /// 
        /// Language bindings should use g_key_file_get_value() to test whether
        /// or not a key exists.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key name
        /// </param>
        /// <returns>
        /// %TRUE if @key is a part of @group_name, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_has_key(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Looks whether the key file has the key @key in the group
        /// @group_name.
        /// </summary>
        /// <remarks>
        /// Note that this function does not follow the rules for #GError strictly;
        /// the return value both carries meaning and signals an error.  To use
        /// this function, you must pass a #GError pointer in @error, and check
        /// whether it is not %NULL to see if an error occurred.
        /// 
        /// Language bindings should use g_key_file_get_value() to test whether
        /// or not a key exists.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key name
        /// </param>
        /// <returns>
        /// %TRUE if @key is a part of @group_name, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean HasKey(
            System.String groupName,
            System.String key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Loads a key file from memory into an empty #GKeyFile structure.
        /// If the object cannot be created then %error is set to a #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="data">
        /// key file loaded in memory
        /// </param>
        /// <param name="length">
        /// the length of @data in bytes (or (gsize)-1 if data is nul-terminated)
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_load_from_data(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] System.UInt64 length,
            [System.Runtime.InteropServices.In()] GISharp.GLib.KeyFileFlags flags);

        /// <summary>
        /// Loads a key file from memory into an empty #GKeyFile structure.
        /// If the object cannot be created then %error is set to a #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="data">
        /// key file loaded in memory
        /// </param>
        /// <param name="length">
        /// the length of @data in bytes (or (gsize)-1 if data is nul-terminated)
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean LoadFromData(
            System.String data,
            System.UInt64 length,
            GISharp.GLib.KeyFileFlags flags)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// This function looks for a key file named @file in the paths
        /// returned from g_get_user_data_dir() and g_get_system_data_dirs(),
        /// loads the file into @key_file and returns the file's full path in
        /// @full_path.  If the file could not be loaded then an %error is
        /// set to either a #GFileError or #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="file">
        /// a relative path to a filename to open and parse
        /// </param>
        /// <param name="fullPath">
        /// return location for a string containing the full path
        ///   of the file, or %NULL
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE othewise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_load_from_data_dirs(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr file,
            [System.Runtime.InteropServices.Out()] out System.IntPtr fullPath,
            [System.Runtime.InteropServices.In()] GISharp.GLib.KeyFileFlags flags);

        /// <summary>
        /// This function looks for a key file named @file in the paths
        /// returned from g_get_user_data_dir() and g_get_system_data_dirs(),
        /// loads the file into @key_file and returns the file's full path in
        /// @full_path.  If the file could not be loaded then an %error is
        /// set to either a #GFileError or #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="file">
        /// a relative path to a filename to open and parse
        /// </param>
        /// <param name="fullPath">
        /// return location for a string containing the full path
        ///   of the file, or %NULL
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE othewise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean LoadFromDataDirs(
            System.String file,
            out System.String fullPath,
            GISharp.GLib.KeyFileFlags flags)
        {
            fullPath = default(System.String);
            return default(System.Boolean);
        }

        /// <summary>
        /// This function looks for a key file named @file in the paths
        /// specified in @search_dirs, loads the file into @key_file and
        /// returns the file's full path in @full_path.  If the file could not
        /// be loaded then an %error is set to either a #GFileError or
        /// #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="file">
        /// a relative path to a filename to open and parse
        /// </param>
        /// <param name="searchDirs">
        /// %NULL-terminated array of directories to search
        /// </param>
        /// <param name="fullPath">
        /// return location for a string containing the full path
        ///   of the file, or %NULL
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.Boolean g_key_file_load_from_dirs(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr file,
            [System.Runtime.InteropServices.In()] System.IntPtr[] searchDirs,
            [System.Runtime.InteropServices.Out()] out System.IntPtr fullPath,
            [System.Runtime.InteropServices.In()] GISharp.GLib.KeyFileFlags flags);

        /// <summary>
        /// This function looks for a key file named @file in the paths
        /// specified in @search_dirs, loads the file into @key_file and
        /// returns the file's full path in @full_path.  If the file could not
        /// be loaded then an %error is set to either a #GFileError or
        /// #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="file">
        /// a relative path to a filename to open and parse
        /// </param>
        /// <param name="searchDirs">
        /// %NULL-terminated array of directories to search
        /// </param>
        /// <param name="fullPath">
        /// return location for a string containing the full path
        ///   of the file, or %NULL
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public System.Boolean LoadFromDirs(
            System.String file,
            System.String[] searchDirs,
            out System.String fullPath,
            GISharp.GLib.KeyFileFlags flags)
        {
            fullPath = default(System.String);
            return default(System.Boolean);
        }

        /// <summary>
        /// Loads a key file into an empty #GKeyFile structure.
        /// If the file could not be loaded then @error is set to
        /// either a #GFileError or #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="file">
        /// the path of a filename to load, in the GLib filename encoding
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_load_from_file(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr file,
            [System.Runtime.InteropServices.In()] GISharp.GLib.KeyFileFlags flags);

        /// <summary>
        /// Loads a key file into an empty #GKeyFile structure.
        /// If the file could not be loaded then @error is set to
        /// either a #GFileError or #GKeyFileError.
        /// </summary>
        /// <param name="keyFile">
        /// an empty #GKeyFile struct
        /// </param>
        /// <param name="file">
        /// the path of a filename to load, in the GLib filename encoding
        /// </param>
        /// <param name="flags">
        /// flags from #GKeyFileFlags
        /// </param>
        /// <returns>
        /// %TRUE if a key file could be loaded, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean LoadFromFile(
            System.String file,
            GISharp.GLib.KeyFileFlags flags)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Increases the reference count of @key_file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <returns>
        /// the same @key_file.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_key_file_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile);

        /// <summary>
        /// Increases the reference count of @key_file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <returns>
        /// the same @key_file.
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Removes a comment above @key from @group_name.
        /// If @key is %NULL then @comment will be removed above @group_name.
        /// If both @key and @group_name are %NULL, then @comment will
        /// be removed above the first group in the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name, or %NULL
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// %TRUE if the comment was removed, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_remove_comment(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Removes a comment above @key from @group_name.
        /// If @key is %NULL then @comment will be removed above @group_name.
        /// If both @key and @group_name are %NULL, then @comment will
        /// be removed above the first group in the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name, or %NULL
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <returns>
        /// %TRUE if the comment was removed, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean RemoveComment(
            System.String groupName,
            System.String key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes the specified group, @group_name,
        /// from the key file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <returns>
        /// %TRUE if the group was removed, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_remove_group(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName);

        /// <summary>
        /// Removes the specified group, @group_name,
        /// from the key file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <returns>
        /// %TRUE if the group was removed, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean RemoveGroup(
            System.String groupName)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes @key in @group_name from the key file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key name to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was removed, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_remove_key(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Removes @key in @group_name from the key file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key name to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was removed, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean RemoveKey(
            System.String groupName,
            System.String key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Writes the contents of @key_file to @filename using
        /// g_file_set_contents().
        /// </summary>
        /// <remarks>
        /// This function can fail for any of the reasons that
        /// g_file_set_contents() may fail.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="filename">
        /// the name of the file to write to
        /// </param>
        /// <returns>
        /// %TRUE if successful, else %FALSE with @error set
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.Boolean g_key_file_save_to_file(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr filename);

        /// <summary>
        /// Writes the contents of @key_file to @filename using
        /// g_file_set_contents().
        /// </summary>
        /// <remarks>
        /// This function can fail for any of the reasons that
        /// g_file_set_contents() may fail.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="filename">
        /// the name of the file to write to
        /// </param>
        /// <returns>
        /// %TRUE if successful, else %FALSE with @error set
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public System.Boolean SaveToFile(
            System.String filename)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Associates a new boolean value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// %TRUE or %FALSE
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_boolean(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.Boolean value);

        /// <summary>
        /// Associates a new boolean value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// %TRUE or %FALSE
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetBoolean(
            System.String groupName,
            System.String key,
            System.Boolean value)
        {
        }

        /// <summary>
        /// Associates a list of boolean values with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// If @group_name is %NULL, the start_group is used.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of boolean values
        /// </param>
        /// <param name="length">
        /// length of @list
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_boolean_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 4)] System.Boolean[] list,
            [System.Runtime.InteropServices.In()] System.UInt64 length);

        /// <summary>
        /// Associates a list of boolean values with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// If @group_name is %NULL, the start_group is used.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of boolean values
        /// </param>
        /// <param name="length">
        /// length of @list
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetBooleanList(
            System.String groupName,
            System.String key,
            System.Boolean[] list)
        {
        }

        /// <summary>
        /// Places a comment above @key from @group_name.
        /// If @key is %NULL then @comment will be written above @group_name.
        /// If both @key and @group_name  are %NULL, then @comment will be
        /// written above the first group in the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name, or %NULL
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="comment">
        /// a comment
        /// </param>
        /// <returns>
        /// %TRUE if the comment was written, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.Boolean g_key_file_set_comment(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr comment);

        /// <summary>
        /// Places a comment above @key from @group_name.
        /// If @key is %NULL then @comment will be written above @group_name.
        /// If both @key and @group_name  are %NULL, then @comment will be
        /// written above the first group in the file.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name, or %NULL
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="comment">
        /// a comment
        /// </param>
        /// <returns>
        /// %TRUE if the comment was written, %FALSE otherwise
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.Boolean SetComment(
            System.String groupName,
            System.String key,
            System.String comment)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Associates a new double value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an double value
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern void g_key_file_set_double(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.Double value);

        /// <summary>
        /// Associates a new double value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an double value
        /// </param>
        [GISharp.Core.Since("2.12")]
        public void SetDouble(
            System.String groupName,
            System.String key,
            System.Double value)
        {
        }

        /// <summary>
        /// Associates a list of double values with @key under
        /// @group_name.  If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of double values
        /// </param>
        /// <param name="length">
        /// number of double values in @list
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern void g_key_file_set_double_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 4)] System.Double[] list,
            [System.Runtime.InteropServices.In()] System.UInt64 length);

        /// <summary>
        /// Associates a list of double values with @key under
        /// @group_name.  If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of double values
        /// </param>
        /// <param name="length">
        /// number of double values in @list
        /// </param>
        [GISharp.Core.Since("2.12")]
        public void SetDoubleList(
            System.String groupName,
            System.String key,
            System.Double[] list)
        {
        }

        /// <summary>
        /// Associates a new integer value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an integer value
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_key_file_set_int64(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.Int64 value);

        /// <summary>
        /// Associates a new integer value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an integer value
        /// </param>
        [GISharp.Core.Since("2.26")]
        public void SetInt64(
            System.String groupName,
            System.String key,
            System.Int64 value)
        {
        }

        /// <summary>
        /// Associates a new integer value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an integer value
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_integer(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.Int32 value);

        /// <summary>
        /// Associates a new integer value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an integer value
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetInteger(
            System.String groupName,
            System.String key,
            System.Int32 value)
        {
        }

        /// <summary>
        /// Associates a list of integer values with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of integer values
        /// </param>
        /// <param name="length">
        /// number of integer values in @list
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_integer_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 4)] System.Int32[] list,
            [System.Runtime.InteropServices.In()] System.UInt64 length);

        /// <summary>
        /// Associates a list of integer values with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of integer values
        /// </param>
        /// <param name="length">
        /// number of integer values in @list
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetIntegerList(
            System.String groupName,
            System.String key,
            System.Int32[] list)
        {
        }

        /// <summary>
        /// Sets the character which is used to separate
        /// values in lists. Typically ';' or ',' are used
        /// as separators. The default list separator is ';'.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="separator">
        /// the separator
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_list_separator(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.SByte separator);

        /// <summary>
        /// Sets the character which is used to separate
        /// values in lists. Typically ';' or ',' are used
        /// as separators. The default list separator is ';'.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="separator">
        /// the separator
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetListSeparator(
            System.SByte separator)
        {
        }

        /// <summary>
        /// Associates a string value for @key and @locale under @group_name.
        /// If the translation for @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier
        /// </param>
        /// <param name="string">
        /// a string
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_locale_string(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr locale,
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Associates a string value for @key and @locale under @group_name.
        /// If the translation for @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier
        /// </param>
        /// <param name="string">
        /// a string
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetLocaleString(
            System.String groupName,
            System.String key,
            System.String locale,
            System.String @string)
        {
        }

        /// <summary>
        /// Associates a list of string values for @key and @locale under
        /// @group_name.  If the translation for @key cannot be found then
        /// it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier
        /// </param>
        /// <param name="list">
        /// a %NULL-terminated array of locale string values
        /// </param>
        /// <param name="length">
        /// the length of @list
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_locale_string_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr locale,
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.UInt64 length);

        /// <summary>
        /// Associates a list of string values for @key and @locale under
        /// @group_name.  If the translation for @key cannot be found then
        /// it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="locale">
        /// a locale identifier
        /// </param>
        /// <param name="list">
        /// a %NULL-terminated array of locale string values
        /// </param>
        /// <param name="length">
        /// the length of @list
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetLocaleStringList(
            System.String groupName,
            System.String key,
            System.String locale,
            System.String[] list)
        {
        }

        /// <summary>
        /// Associates a new string value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// If @group_name cannot be found then it is created.
        /// Unlike g_key_file_set_value(), this function handles characters
        /// that need escaping, such as newlines.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="string">
        /// a string
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_string(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Associates a new string value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// If @group_name cannot be found then it is created.
        /// Unlike g_key_file_set_value(), this function handles characters
        /// that need escaping, such as newlines.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="string">
        /// a string
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetString(
            System.String groupName,
            System.String key,
            System.String @string)
        {
        }

        /// <summary>
        /// Associates a list of string values for @key under @group_name.
        /// If @key cannot be found then it is created.
        /// If @group_name cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of string values
        /// </param>
        /// <param name="length">
        /// number of string values in @list
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_string_list(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.UInt64 length);

        /// <summary>
        /// Associates a list of string values for @key under @group_name.
        /// If @key cannot be found then it is created.
        /// If @group_name cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="list">
        /// an array of string values
        /// </param>
        /// <param name="length">
        /// number of string values in @list
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetStringList(
            System.String groupName,
            System.String key,
            System.String[] list)
        {
        }

        /// <summary>
        /// Associates a new integer value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an integer value
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_key_file_set_uint64(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.UInt64 value);

        /// <summary>
        /// Associates a new integer value with @key under @group_name.
        /// If @key cannot be found then it is created.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// an integer value
        /// </param>
        [GISharp.Core.Since("2.26")]
        public void SetUint64(
            System.String groupName,
            System.String key,
            System.UInt64 value)
        {
        }

        /// <summary>
        /// Associates a new value with @key under @group_name.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then it is created. If @group_name cannot
        /// be found then it is created. To set an UTF-8 string which may contain
        /// characters that need escaping (such as newlines or spaces), use
        /// g_key_file_set_string().
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// a string
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern void g_key_file_set_value(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.In()] System.IntPtr groupName,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Associates a new value with @key under @group_name.
        /// </summary>
        /// <remarks>
        /// If @key cannot be found then it is created. If @group_name cannot
        /// be found then it is created. To set an UTF-8 string which may contain
        /// characters that need escaping (such as newlines or spaces), use
        /// g_key_file_set_string().
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="groupName">
        /// a group name
        /// </param>
        /// <param name="key">
        /// a key
        /// </param>
        /// <param name="value">
        /// a string
        /// </param>
        [GISharp.Core.Since("2.6")]
        public void SetValue(
            System.String groupName,
            System.String key,
            System.String value)
        {
        }

        /// <summary>
        /// This function outputs @key_file as a string.
        /// </summary>
        /// <remarks>
        /// Note that this function never reports an error,
        /// so it is safe to pass %NULL as @error.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="length">
        /// return location for the length of the
        ///   returned string, or %NULL
        /// </param>
        /// <returns>
        /// a newly allocated string holding
        ///   the contents of the #GKeyFile
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr g_key_file_to_data(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// This function outputs @key_file as a string.
        /// </summary>
        /// <remarks>
        /// Note that this function never reports an error,
        /// so it is safe to pass %NULL as @error.
        /// </remarks>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        /// <param name="length">
        /// return location for the length of the
        ///   returned string, or %NULL
        /// </param>
        /// <returns>
        /// a newly allocated string holding
        ///   the contents of the #GKeyFile
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public System.String ToData(
            out System.UInt64 length)
        {
            length = default(System.UInt64);
            return default(System.String);
        }

        /// <summary>
        /// Decreases the reference count of @key_file by 1. If the reference count
        /// reaches zero, frees the key file and all its allocated memory.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern void g_key_file_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr keyFile);

        /// <summary>
        /// Decreases the reference count of @key_file by 1. If the reference count
        /// reaches zero, frees the key file and all its allocated memory.
        /// </summary>
        /// <param name="keyFile">
        /// a #GKeyFile
        /// </param>
        [GISharp.Core.Since("2.32")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// Error codes returned by key file parsing.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"KeyFileError\" c:type=\"GKeyFileError\" glib:error-domain=\"g-key-file-error-quark\" gs:managed-name=\"KeyFileError\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Error codes returned by key file parsing.</doc>\n  <member name=\"unknown_encoding\" value=\"0\" c:identifier=\"G_KEY_FILE_ERROR_UNKNOWN_ENCODING\" gs:managed-name=\"UnknownEncoding\">\n    <doc xml:space=\"preserve\">the text being parsed was in\n    an unknown encoding</doc>\n  </member>\n  <member name=\"parse\" value=\"1\" c:identifier=\"G_KEY_FILE_ERROR_PARSE\" gs:managed-name=\"Parse\">\n    <doc xml:space=\"preserve\">document was ill-formed</doc>\n  </member>\n  <member name=\"not_found\" value=\"2\" c:identifier=\"G_KEY_FILE_ERROR_NOT_FOUND\" gs:managed-name=\"NotFound\">\n    <doc xml:space=\"preserve\">the file was not found</doc>\n  </member>\n  <member name=\"key_not_found\" value=\"3\" c:identifier=\"G_KEY_FILE_ERROR_KEY_NOT_FOUND\" gs:managed-name=\"KeyNotFound\">\n    <doc xml:space=\"preserve\">a requested key was not found</doc>\n  </member>\n  <member name=\"group_not_found\" value=\"4\" c:identifier=\"G_KEY_FILE_ERROR_GROUP_NOT_FOUND\" gs:managed-name=\"GroupNotFound\">\n    <doc xml:space=\"preserve\">a requested group was not found</doc>\n  </member>\n  <member name=\"invalid_value\" value=\"5\" c:identifier=\"G_KEY_FILE_ERROR_INVALID_VALUE\" gs:managed-name=\"InvalidValue\">\n    <doc xml:space=\"preserve\">a value could not be parsed</doc>\n  </member>\n</enumeration>")]
    [GISharp.Core.ErrorDomain("g-key-file-error-quark")]
    public enum KeyFileError
    {
        /// <summary>
        /// the text being parsed was in
        ///     an unknown encoding
        /// </summary>
        UnknownEncoding = 0,
        /// <summary>
        /// document was ill-formed
        /// </summary>
        Parse = 1,
        /// <summary>
        /// the file was not found
        /// </summary>
        NotFound = 2,
        /// <summary>
        /// a requested key was not found
        /// </summary>
        KeyNotFound = 3,
        /// <summary>
        /// a requested group was not found
        /// </summary>
        GroupNotFound = 4,
        /// <summary>
        /// a value could not be parsed
        /// </summary>
        InvalidValue = 5
    }

    /// <summary>
    /// Flags which influence the parsing.
    /// </summary>
    [GISharp.Core.GirXml("<bitfield name=\"KeyFileFlags\" c:type=\"GKeyFileFlags\" gs:managed-name=\"KeyFileFlags\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Flags which influence the parsing.</doc>\n  <member name=\"none\" value=\"0\" c:identifier=\"G_KEY_FILE_NONE\" gs:managed-name=\"None\">\n    <doc xml:space=\"preserve\">No flags, default behaviour</doc>\n  </member>\n  <member name=\"keep_comments\" value=\"1\" c:identifier=\"G_KEY_FILE_KEEP_COMMENTS\" gs:managed-name=\"KeepComments\">\n    <doc xml:space=\"preserve\">Use this flag if you plan to write the\n    (possibly modified) contents of the key file back to a file;\n    otherwise all comments will be lost when the key file is\n    written back.</doc>\n  </member>\n  <member name=\"keep_translations\" value=\"2\" c:identifier=\"G_KEY_FILE_KEEP_TRANSLATIONS\" gs:managed-name=\"KeepTranslations\">\n    <doc xml:space=\"preserve\">Use this flag if you plan to write the\n    (possibly modified) contents of the key file back to a file;\n    otherwise only the translations for the current language will be\n    written back.</doc>\n  </member>\n</bitfield>")]
    [System.Flags()]
    public enum KeyFileFlags
    {
        /// <summary>
        /// No flags, default behaviour
        /// </summary>
        None = 0,
        /// <summary>
        /// Use this flag if you plan to write the
        ///     (possibly modified) contents of the key file back to a file;
        ///     otherwise all comments will be lost when the key file is
        ///     written back.
        /// </summary>
        KeepComments = 1,
        /// <summary>
        /// Use this flag if you plan to write the
        ///     (possibly modified) contents of the key file back to a file;
        ///     otherwise only the translations for the current language will be
        ///     written back.
        /// </summary>
        KeepTranslations = 2
    }

    /// <summary>
    /// Specifies the prototype of log handler functions.
    /// </summary>
    /// <remarks>
    /// The default log handler, g_log_default_handler(), automatically appends a
    /// new-line character to @message when printing it. It is advised that any
    /// custom log handler functions behave similarly, so that logging calls in user
    /// code do not need modifying to add a new-line character to the message if the
    /// log handler is changed.
    /// </remarks>
    /// <param name="logDomain">
    /// the log domain of the message
    /// </param>
    /// <param name="logLevel">
    /// the log level of the message (including the
    ///     fatal and recursion flags)
    /// </param>
    /// <param name="message">
    /// the message to process
    /// </param>
    /// <param name="userData">
    /// user data, set in g_log_set_handler()
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the prototype of log handler functions.\n\nThe default log handler, g_log_default_handler(), automatically appends a\nnew-line character to @message when printing it. It is advised that any\ncustom log handler functions behave similarly, so that logging calls in user\ncode do not need modifying to add a new-line character to the message if the\nlog handler is changed.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the log domain of the message</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n      <doc xml:space=\"preserve\">the log level of the message (including the\n    fatal and recursion flags)</doc>\n      <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n    </parameter>\n    <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the message to process</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data, set in g_log_set_handler()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the log domain of the message</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n      <doc xml:space=\"preserve\">the log level of the message (including the\n    fatal and recursion flags)</doc>\n      <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n    </parameter>\n    <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the message to process</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void LogFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr logDomain,
        [System.Runtime.InteropServices.In()] GISharp.GLib.LogLevelFlags logLevel,
        [System.Runtime.InteropServices.In()] System.IntPtr message,
        [System.Runtime.InteropServices.In()] System.IntPtr userData);

    /// <summary>
    /// Specifies the prototype of log handler functions.
    /// </summary>
    /// <remarks>
    /// The default log handler, g_log_default_handler(), automatically appends a
    /// new-line character to @message when printing it. It is advised that any
    /// custom log handler functions behave similarly, so that logging calls in user
    /// code do not need modifying to add a new-line character to the message if the
    /// log handler is changed.
    /// </remarks>
    /// <param name="logDomain">
    /// the log domain of the message
    /// </param>
    /// <param name="logLevel">
    /// the log level of the message (including the
    ///     fatal and recursion flags)
    /// </param>
    /// <param name="message">
    /// the message to process
    /// </param>
    /// <param name="userData">
    /// user data, set in g_log_set_handler()
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the prototype of log handler functions.\n\nThe default log handler, g_log_default_handler(), automatically appends a\nnew-line character to @message when printing it. It is advised that any\ncustom log handler functions behave similarly, so that logging calls in user\ncode do not need modifying to add a new-line character to the message if the\nlog handler is changed.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the log domain of the message</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n      <doc xml:space=\"preserve\">the log level of the message (including the\n    fatal and recursion flags)</doc>\n      <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n    </parameter>\n    <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the message to process</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data, set in g_log_set_handler()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the log domain of the message</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n      <doc xml:space=\"preserve\">the log level of the message (including the\n    fatal and recursion flags)</doc>\n      <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n    </parameter>\n    <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the message to process</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate void LogFunc(
        System.String logDomain,
        GISharp.GLib.LogLevelFlags logLevel,
        System.String message);

    /// <summary>
    /// Flags specifying the level of log messages.
    /// </summary>
    /// <remarks>
    /// It is possible to change how GLib treats messages of the various
    /// levels using g_log_set_handler() and g_log_set_fatal_mask().
    /// </remarks>
    [GISharp.Core.GirXml("<bitfield name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Flags specifying the level of log messages.\n\nIt is possible to change how GLib treats messages of the various\nlevels using g_log_set_handler() and g_log_set_fatal_mask().</doc>\n  <member name=\"flag_recursion\" value=\"1\" c:identifier=\"G_LOG_FLAG_RECURSION\" gs:managed-name=\"FlagRecursion\">\n    <doc xml:space=\"preserve\">internal flag</doc>\n  </member>\n  <member name=\"flag_fatal\" value=\"2\" c:identifier=\"G_LOG_FLAG_FATAL\" gs:managed-name=\"FlagFatal\">\n    <doc xml:space=\"preserve\">internal flag</doc>\n  </member>\n  <member name=\"level_error\" value=\"4\" c:identifier=\"G_LOG_LEVEL_ERROR\" gs:managed-name=\"LevelError\">\n    <doc xml:space=\"preserve\">log level for errors, see g_error().\n    This level is also used for messages produced by g_assert().</doc>\n  </member>\n  <member name=\"level_critical\" value=\"8\" c:identifier=\"G_LOG_LEVEL_CRITICAL\" gs:managed-name=\"LevelCritical\">\n    <doc xml:space=\"preserve\">log level for critical messages, see g_critical().\n    This level is also used for messages produced by g_return_if_fail()\n    and g_return_val_if_fail().</doc>\n  </member>\n  <member name=\"level_warning\" value=\"16\" c:identifier=\"G_LOG_LEVEL_WARNING\" gs:managed-name=\"LevelWarning\">\n    <doc xml:space=\"preserve\">log level for warnings, see g_warning()</doc>\n  </member>\n  <member name=\"level_message\" value=\"32\" c:identifier=\"G_LOG_LEVEL_MESSAGE\" gs:managed-name=\"LevelMessage\">\n    <doc xml:space=\"preserve\">log level for messages, see g_message()</doc>\n  </member>\n  <member name=\"level_info\" value=\"64\" c:identifier=\"G_LOG_LEVEL_INFO\" gs:managed-name=\"LevelInfo\">\n    <doc xml:space=\"preserve\">log level for informational messages, see g_info()</doc>\n  </member>\n  <member name=\"level_debug\" value=\"128\" c:identifier=\"G_LOG_LEVEL_DEBUG\" gs:managed-name=\"LevelDebug\">\n    <doc xml:space=\"preserve\">log level for debug messages, see g_debug()</doc>\n  </member>\n  <member name=\"level_mask\" value=\"-4\" c:identifier=\"G_LOG_LEVEL_MASK\" gs:managed-name=\"LevelMask\">\n    <doc xml:space=\"preserve\">a mask including all log levels</doc>\n  </member>\n</bitfield>")]
    [System.Flags()]
    public enum LogLevelFlags
    {
        /// <summary>
        /// internal flag
        /// </summary>
        FlagRecursion = 1,
        /// <summary>
        /// internal flag
        /// </summary>
        FlagFatal = 2,
        /// <summary>
        /// log level for errors, see g_error().
        ///     This level is also used for messages produced by g_assert().
        /// </summary>
        LevelError = 4,
        /// <summary>
        /// log level for critical messages, see g_critical().
        ///     This level is also used for messages produced by g_return_if_fail()
        ///     and g_return_val_if_fail().
        /// </summary>
        LevelCritical = 8,
        /// <summary>
        /// log level for warnings, see g_warning()
        /// </summary>
        LevelWarning = 16,
        /// <summary>
        /// log level for messages, see g_message()
        /// </summary>
        LevelMessage = 32,
        /// <summary>
        /// log level for informational messages, see g_info()
        /// </summary>
        LevelInfo = 64,
        /// <summary>
        /// log level for debug messages, see g_debug()
        /// </summary>
        LevelDebug = 128,
        /// <summary>
        /// a mask including all log levels
        /// </summary>
        LevelMask = -4
    }

    /// <summary>
    /// The `GMainContext` struct is an opaque data
    /// type representing a set of sources to be handled in a main loop.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"MainContext\" c:type=\"GMainContext\" glib:type-name=\"GMainContext\" glib:get-type=\"g_main_context_get_type\" c:symbol-prefix=\"main_context\" gs:managed-name=\"MainContext\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The `GMainContext` struct is an opaque data\ntype representing a set of sources to be handled in a main loop.</doc>\n  <constructor name=\"new\" c:identifier=\"g_main_context_new\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GMainContext structure.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new #GMainContext</doc>\n      <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n    </return-value>\n  </constructor>\n  <method name=\"acquire\" c:identifier=\"g_main_context_acquire\" gs:managed-name=\"Acquire\">\n    <doc xml:space=\"preserve\">Tries to become the owner of the specified context.\nIf some other thread is the owner of the context,\nreturns %FALSE immediately. Ownership is properly\nrecursive: the owner can require ownership again\nand will release ownership when g_main_context_release()\nis called as many times as g_main_context_acquire().\n\nYou must be the owner of a context before you\ncan call g_main_context_prepare(), g_main_context_query(),\ng_main_context_check(), g_main_context_dispatch().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the operation succeeded, and\n  this thread is now the owner of @context.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"add_poll\" c:identifier=\"g_main_context_add_poll\" gs:managed-name=\"AddPoll\">\n    <doc xml:space=\"preserve\">Adds a file descriptor to the set of file descriptors polled for\nthis context. This will very seldom be used directly. Instead\na typical event source will use g_source_add_unix_fd() instead.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (or %NULL for the default context)</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD structure holding information about a file\n     descriptor to watch.</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority for this file descriptor which should be\n     the same as the priority used for g_source_attach() to ensure that the\n     file descriptor is polled whenever the results may be needed.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD structure holding information about a file\n     descriptor to watch.</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority for this file descriptor which should be\n     the same as the priority used for g_source_attach() to ensure that the\n     file descriptor is polled whenever the results may be needed.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"check\" c:identifier=\"g_main_context_check\" gs:managed-name=\"Check\">\n    <doc xml:space=\"preserve\">Passes the results of polling back to the main loop.\n\nYou must have successfully acquired the context with\ng_main_context_acquire() before you may call this function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">%TRUE if some sources are ready to be dispatched.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"max_priority\" transfer-ownership=\"none\" gs:managed-name=\"maxPriority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the maximum numerical priority of sources to check</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"fds\" transfer-ownership=\"none\" gs:managed-name=\"fds\" gs:managed-type=\"PollFD[]\" gs:unmanaged-type=\"PollFD[]\">\n        <doc xml:space=\"preserve\">array of #GPollFD's that was passed to\n      the last call to g_main_context_query()</doc>\n        <array length=\"2\" zero-terminated=\"0\" c:type=\"GPollFD*\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n          <type name=\"PollFD\" c:type=\"GPollFD\" gs:managed-name=\"PollFD\" />\n        </array>\n      </parameter>\n      <parameter name=\"n_fds\" transfer-ownership=\"none\" gs:managed-name=\"nFds\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">return value of g_main_context_query()</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"max_priority\" transfer-ownership=\"none\" gs:managed-name=\"maxPriority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the maximum numerical priority of sources to check</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"fds\" transfer-ownership=\"none\" gs:managed-name=\"fds\" gs:managed-type=\"PollFD[]\" gs:unmanaged-type=\"PollFD[]\">\n        <doc xml:space=\"preserve\">array of #GPollFD's that was passed to\n      the last call to g_main_context_query()</doc>\n        <array length=\"2\" zero-terminated=\"0\" c:type=\"GPollFD*\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n          <type name=\"PollFD\" c:type=\"GPollFD\" gs:managed-name=\"PollFD\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"dispatch\" c:identifier=\"g_main_context_dispatch\" gs:managed-name=\"Dispatch\">\n    <doc xml:space=\"preserve\">Dispatches all pending sources.\n\nYou must have successfully acquired the context with\ng_main_context_acquire() before you may call this function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"find_source_by_funcs_user_data\" c:identifier=\"g_main_context_find_source_by_funcs_user_data\" gs:managed-name=\"FindSourceByFuncsUserData\">\n    <doc xml:space=\"preserve\">Finds a source with the given source functions and user data.  If\nmultiple sources exist with the same source function and user data,\nthe first one found will be returned.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the source, if one was found, otherwise %NULL</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (if %NULL, the default context will be used).</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"funcs\" transfer-ownership=\"none\" gs:managed-name=\"funcs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">the @source_funcs passed to g_source_new().</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user data from the callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"funcs\" transfer-ownership=\"none\" gs:managed-name=\"funcs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">the @source_funcs passed to g_source_new().</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user data from the callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find_source_by_id\" c:identifier=\"g_main_context_find_source_by_id\" gs:managed-name=\"FindSourceById\">\n    <doc xml:space=\"preserve\">Finds a #GSource given a pair of context and ID.\n\nIt is a programmer error to attempt to lookup a non-existent source.\n\nMore specifically: source IDs can be reissued after a source has been\ndestroyed and therefore it is never valid to use this function with a\nsource ID which may have already been removed.  An example is when\nscheduling an idle to run in another thread with g_idle_add(): the\nidle may already have run and been removed by the time this function\nis called on its (now invalid) source ID.  This source ID may have\nbeen reissued, leading to the operation being performed against the\nwrong source.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GSource</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (if %NULL, the default context will be used)</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"source_id\" transfer-ownership=\"none\" gs:managed-name=\"sourceId\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the source ID, as returned by g_source_get_id().</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"source_id\" transfer-ownership=\"none\" gs:managed-name=\"sourceId\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the source ID, as returned by g_source_get_id().</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find_source_by_user_data\" c:identifier=\"g_main_context_find_source_by_user_data\" gs:managed-name=\"FindSourceByUserData\">\n    <doc xml:space=\"preserve\">Finds a source with the given user data for the callback.  If\nmultiple sources exist with the same user data, the first\none found will be returned.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the source, if one was found, otherwise %NULL</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user_data for the callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user_data for the callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_poll_func\" c:identifier=\"g_main_context_get_poll_func\" introspectable=\"0\" gs:managed-name=\"get_PollFunc\" gs:property=\"PollFunc\">\n    <doc xml:space=\"preserve\">Gets the poll function set by g_main_context_set_poll_func().</doc>\n    <return-value gs:managed-type=\"PollFunc\" gs:unmanaged-type=\"PollFuncNative\">\n      <doc xml:space=\"preserve\">the poll function</doc>\n      <type name=\"PollFunc\" c:type=\"GPollFunc\" gs:managed-name=\"PollFunc\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"invoke\" c:identifier=\"g_main_context_invoke\" version=\"2.28\" introspectable=\"0\" gs:managed-name=\"Invoke\">\n    <doc xml:space=\"preserve\">Invokes a function in such a way that @context is owned during the\ninvocation of @function.\n\nIf @context is %NULL then the global default main context — as\nreturned by g_main_context_default() — is used.\n\nIf @context is owned by the current thread, @function is called\ndirectly.  Otherwise, if @context is the thread-default main context\nof the current thread and g_main_context_acquire() succeeds, then\n@function is called and g_main_context_release() is called\nafterwards.\n\nIn any other case, an idle source is created to call @function and\nthat source is attached to @context (presumably to be run in another\nthread).  The idle source is attached with #G_PRIORITY_DEFAULT\npriority.  If you want a different priority, use\ng_main_context_invoke_full().\n\nNote that, as with normal idle functions, @function should probably\nreturn %FALSE.  If it returns %TRUE, it will be continuously run in a\nloop (and may prevent this call from returning).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext, or %NULL</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"function\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"invoke_full\" c:identifier=\"g_main_context_invoke_full\" version=\"2.28\" gs:managed-name=\"InvokeFull\">\n    <doc xml:space=\"preserve\">Invokes a function in such a way that @context is owned during the\ninvocation of @function.\n\nThis function is the same as g_main_context_invoke() except that it\nlets you specify the priority incase @function ends up being\nscheduled as an idle and also lets you give a #GDestroyNotify for @data.\n\n@notify should not assume that it is called from any particular\nthread or with any particular context acquired.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext, or %NULL</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority at which to run @function</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"2\" destroy=\"3\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a function to call when @data is no longer in use, or %NULL.</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority at which to run @function</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"2\" destroy=\"3\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"is_owner\" c:identifier=\"g_main_context_is_owner\" version=\"2.10\" gs:managed-name=\"get_IsOwner\" gs:property=\"IsOwner\">\n    <doc xml:space=\"preserve\">Determines whether this thread holds the (recursive)\nownership of this #GMainContext. This is useful to\nknow before waiting on another thread that may be\nblocking to get ownership of @context.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if current thread is owner of @context.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"iteration\" c:identifier=\"g_main_context_iteration\" gs:managed-name=\"Iteration\">\n    <doc xml:space=\"preserve\">Runs a single iteration for the given main loop. This involves\nchecking to see if any event sources are ready to be processed,\nthen if no events sources are ready and @may_block is %TRUE, waiting\nfor a source to become ready, then dispatching the highest priority\nevents sources that are ready. Otherwise, if @may_block is %FALSE\nsources are not waited to become ready, only those highest priority\nevents sources will be dispatched (if any), that are ready at this\ngiven moment without further waiting.\n\nNote that even when @may_block is %TRUE, it is still possible for\ng_main_context_iteration() to return %FALSE, since the wait may\nbe interrupted for other reasons than an event source becoming ready.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if events were dispatched.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (if %NULL, the default context will be used)</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"may_block\" transfer-ownership=\"none\" gs:managed-name=\"mayBlock\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">whether the call may block.</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"may_block\" transfer-ownership=\"none\" gs:managed-name=\"mayBlock\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">whether the call may block.</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"pending\" c:identifier=\"g_main_context_pending\" gs:managed-name=\"Pending\">\n    <doc xml:space=\"preserve\">Checks if any sources have pending events for the given context.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if events are pending.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (if %NULL, the default context will be used)</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"pop_thread_default\" c:identifier=\"g_main_context_pop_thread_default\" version=\"2.22\" gs:managed-name=\"PopThreadDefault\">\n    <doc xml:space=\"preserve\">Pops @context off the thread-default context stack (verifying that\nit was on the top of the stack).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext object, or %NULL</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"prepare\" c:identifier=\"g_main_context_prepare\" gs:managed-name=\"Prepare\">\n    <doc xml:space=\"preserve\">Prepares to poll sources within a main loop. The resulting information\nfor polling is determined by calling g_main_context_query ().\n\nYou must have successfully acquired the context with\ng_main_context_acquire() before you may call this function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if some source is ready to be dispatched\n              prior to polling.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">location to store priority of highest priority\n           source already ready.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">location to store priority of highest priority\n           source already ready.</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"push_thread_default\" c:identifier=\"g_main_context_push_thread_default\" version=\"2.22\" gs:managed-name=\"PushThreadDefault\">\n    <doc xml:space=\"preserve\">Acquires @context and sets it as the thread-default context for the\ncurrent thread. This will cause certain asynchronous operations\n(such as most [gio][gio]-based I/O) which are\nstarted in this thread to run under @context and deliver their\nresults to its main loop, rather than running under the global\ndefault context in the main thread. Note that calling this function\nchanges the context returned by g_main_context_get_thread_default(),\nnot the one returned by g_main_context_default(), so it does not affect\nthe context used by functions like g_idle_add().\n\nNormally you would call this function shortly after creating a new\nthread, passing it a #GMainContext which will be run by a\n#GMainLoop in that thread, to set a new default context for all\nasync operations in that thread. (In this case, you don't need to\never call g_main_context_pop_thread_default().) In some cases\nhowever, you may want to schedule a single operation in a\nnon-default context, or temporarily use a non-default context in\nthe main thread. In that case, you can wrap the call to the\nasynchronous operation inside a\ng_main_context_push_thread_default() /\ng_main_context_pop_thread_default() pair, but it is up to you to\nensure that no other asynchronous operations accidentally get\nstarted while the non-default context is active.\n\nBeware that libraries that predate this function may not correctly\nhandle being used from a thread with a thread-default context. Eg,\nsee g_file_supports_thread_contexts().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext, or %NULL for the global default context</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"query\" c:identifier=\"g_main_context_query\" gs:managed-name=\"Query\">\n    <doc xml:space=\"preserve\">Determines information necessary to poll this main loop.\n\nYou must have successfully acquired the context with\ng_main_context_acquire() before you may call this function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the number of records actually stored in @fds,\n  or, if more than @n_fds records need to be stored, the number\n  of records that need to be stored.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"max_priority\" transfer-ownership=\"none\" gs:managed-name=\"maxPriority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">maximum priority source to check</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"timeout_\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">location to store timeout to be used in polling</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"fds\" direction=\"out\" caller-allocates=\"1\" transfer-ownership=\"none\" gs:managed-name=\"fds\" gs:managed-type=\"PollFD[]\" gs:unmanaged-type=\"PollFD[]\">\n        <doc xml:space=\"preserve\">location to\n      store #GPollFD records that need to be polled.</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"GPollFD*\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n          <type name=\"PollFD\" c:type=\"GPollFD\" gs:managed-name=\"PollFD\" />\n        </array>\n      </parameter>\n      <parameter name=\"n_fds\" direction=\"in\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"nFds\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">length of @fds.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"max_priority\" transfer-ownership=\"none\" gs:managed-name=\"maxPriority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">maximum priority source to check</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"timeout_\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">location to store timeout to be used in polling</doc>\n        <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"fds\" direction=\"out\" caller-allocates=\"1\" transfer-ownership=\"none\" gs:managed-name=\"fds\" gs:managed-type=\"PollFD[]\" gs:unmanaged-type=\"PollFD[]\">\n        <doc xml:space=\"preserve\">location to\n      store #GPollFD records that need to be polled.</doc>\n        <array length=\"3\" zero-terminated=\"0\" c:type=\"GPollFD*\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n          <type name=\"PollFD\" c:type=\"GPollFD\" gs:managed-name=\"PollFD\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_main_context_ref\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count on a #GMainContext object by one.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the @context that was passed in (since 2.6)</doc>\n      <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"release\" c:identifier=\"g_main_context_release\" gs:managed-name=\"Release\">\n    <doc xml:space=\"preserve\">Releases ownership of a context previously acquired by this thread\nwith g_main_context_acquire(). If the context was acquired multiple\ntimes, the ownership will be released only when g_main_context_release()\nis called as many times as it was acquired.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove_poll\" c:identifier=\"g_main_context_remove_poll\" gs:managed-name=\"RemovePoll\">\n    <doc xml:space=\"preserve\">Removes file descriptor from the set of file descriptors to be\npolled for a particular context.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD descriptor previously added with g_main_context_add_poll()</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD descriptor previously added with g_main_context_add_poll()</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_poll_func\" c:identifier=\"g_main_context_set_poll_func\" introspectable=\"0\" gs:managed-name=\"set_PollFunc\" gs:property=\"PollFunc\">\n    <doc xml:space=\"preserve\">Sets the function to use to handle polling of file descriptors. It\nwill be used instead of the poll() system call\n(or GLib's replacement function, which is used where\npoll() isn't available).\n\nThis function could possibly be used to integrate the GLib event\nloop with an external event loop.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"PollFunc\" gs:unmanaged-type=\"PollFuncNative\">\n        <doc xml:space=\"preserve\">the function to call to poll all file descriptors</doc>\n        <type name=\"PollFunc\" c:type=\"GPollFunc\" gs:managed-name=\"PollFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"PollFunc\" gs:unmanaged-type=\"PollFuncNative\">\n        <doc xml:space=\"preserve\">the function to call to poll all file descriptors</doc>\n        <type name=\"PollFunc\" c:type=\"GPollFunc\" gs:managed-name=\"PollFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_main_context_unref\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count on a #GMainContext object by one. If\nthe result is zero, free the context and free all associated memory.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"wakeup\" c:identifier=\"g_main_context_wakeup\" gs:managed-name=\"Wakeup\">\n    <doc xml:space=\"preserve\">If @context is currently blocking in g_main_context_iteration()\nwaiting for a source to become ready, cause it to stop blocking\nand return.  Otherwise, cause the next invocation of\ng_main_context_iteration() to return without blocking.\n\nThis API is useful for low-level control over #GMainContext; for\nexample, integrating it with main loop implementations such as\n#GMainLoop.\n\nAnother related use for this function is when implementing a main\nloop with a termination condition, computed from multiple threads:\n\n|[&lt;!-- language=\"C\" --&gt;\n  #define NUM_TASKS 10\n  static volatile gint tasks_remaining = NUM_TASKS;\n  ...\n \n  while (g_atomic_int_get (&amp;tasks_remaining) != 0)\n    g_main_context_iteration (NULL, TRUE);\n]|\n \nThen in a thread:\n|[&lt;!-- language=\"C\" --&gt;\n  perform_work();\n\n  if (g_atomic_int_dec_and_test (&amp;tasks_remaining))\n    g_main_context_wakeup (NULL);\n]|</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"context\" transfer-ownership=\"none\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"get_default\" c:identifier=\"g_main_context_default\" gs:managed-name=\"get_Default\" gs:property=\"Default\">\n    <doc xml:space=\"preserve\">Returns the global default main context. This is the main context\nused for main loop functions when a main loop is not explicitly\nspecified, and corresponds to the \"main\" main loop. See also\ng_main_context_get_thread_default().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the global default main context.</doc>\n      <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n    </return-value>\n  </function>\n  <function name=\"ref_thread_default\" c:identifier=\"g_main_context_ref_thread_default\" version=\"2.32\" gs:managed-name=\"RefThreadDefault\">\n    <doc xml:space=\"preserve\">Gets the thread-default #GMainContext for this thread, as with\ng_main_context_get_thread_default(), but also adds a reference to\nit with g_main_context_ref(). In addition, unlike\ng_main_context_get_thread_default(), if the thread-default context\nis the global default context, this will return that #GMainContext\n(with a ref added to it) rather than returning %NULL.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the thread-default #GMainContext. Unref\n    with g_main_context_unref() when you are done with it.</doc>\n      <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n    </return-value>\n  </function>\n  <function name=\"main_depth\" c:identifier=\"g_main_depth\" gs:managed-name=\"MainDepth\">\n    <doc xml:space=\"preserve\">Returns the depth of the stack of calls to\ng_main_context_dispatch() on any #GMainContext in the current thread.\n That is, when called from the toplevel, it gives 0. When\ncalled from within a callback from g_main_context_iteration()\n(or g_main_loop_run(), etc.) it returns 1. When called from within\na callback to a recursive call to g_main_context_iteration(),\nit returns 2. And so forth.\n\nThis function is useful in a situation like the following:\nImagine an extremely simple \"garbage collected\" system.\n\n|[&lt;!-- language=\"C\" --&gt;\nstatic GList *free_list;\n\ngpointer\nallocate_memory (gsize size)\n{\n  gpointer result = g_malloc (size);\n  free_list = g_list_prepend (free_list, result);\n  return result;\n}\n\nvoid\nfree_allocated_memory (void)\n{\n  GList *l;\n  for (l = free_list; l; l = l-&gt;next);\n    g_free (l-&gt;data);\n  g_list_free (free_list);\n  free_list = NULL;\n }\n\n[...]\n\nwhile (TRUE);\n {\n   g_main_context_iteration (NULL, TRUE);\n   free_allocated_memory();\n  }\n]|\n\nThis works from an application, however, if you want to do the same\nthing from a library, it gets more difficult, since you no longer\ncontrol the main loop. You might think you can simply use an idle\nfunction to make the call to free_allocated_memory(), but that\ndoesn't work, since the idle function could be called from a\nrecursive callback. This can be fixed by using g_main_depth()\n\n|[&lt;!-- language=\"C\" --&gt;\ngpointer\nallocate_memory (gsize size)\n{\n  FreeListBlock *block = g_new (FreeListBlock, 1);\n  block-&gt;mem = g_malloc (size);\n  block-&gt;depth = g_main_depth ();\n  free_list = g_list_prepend (free_list, block);\n  return block-&gt;mem;\n}\n\nvoid\nfree_allocated_memory (void)\n{\n  GList *l;\n  \n  int depth = g_main_depth ();\n  for (l = free_list; l; );\n    {\n      GList *next = l-&gt;next;\n      FreeListBlock *block = l-&gt;data;\n      if (block-&gt;depth &gt; depth)\n        {\n          g_free (block-&gt;mem);\n          g_free (block);\n          free_list = g_list_delete_link (free_list, l);\n        }\n              \n      l = next;\n    }\n  }\n]|\n\nThere is a temptation to use g_main_depth() to solve\nproblems with reentrancy. For instance, while waiting for data\nto be received from the network in response to a menu item,\nthe menu item might be selected again. It might seem that\none could make the menu item's callback return immediately\nand do nothing if g_main_depth() returns a value greater than 1.\nHowever, this should be avoided since the user then sees selecting\nthe menu item do nothing. Furthermore, you'll find yourself adding\nthese checks all over your code, since there are doubtless many,\nmany things that the user could do. Instead, you can use the\nfollowing techniques:\n\n1. Use gtk_widget_set_sensitive() or modal dialogs to prevent\n   the user from interacting with elements while the main\n   loop is recursing.\n\n2. Avoid main loop recursion in situations where you can't handle\n   arbitrary  callbacks. Instead, structure your code so that you\n   simply return to the main loop and then get called again when\n   there is more work to do.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">The main loop recursion level in the current thread</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n  </function>\n  <function name=\"poll\" c:identifier=\"g_poll\" version=\"2.20\" gs:managed-name=\"Poll\">\n    <doc xml:space=\"preserve\">Polls @fds, as with the poll() system call, but portably. (On\nsystems that don't have poll(), it is emulated using select().)\nThis is used internally by #GMainContext, but it can be called\ndirectly if you need to block until a file descriptor is ready, but\ndon't want to run the full main loop.\n\nEach element of @fds is a #GPollFD describing a single file\ndescriptor to poll. The %fd field indicates the file descriptor,\nand the %events field indicates the events to poll for. On return,\nthe %revents fields will be filled with the events that actually\noccurred.\n\nOn POSIX systems, the file descriptors in @fds can be any sort of\nfile descriptor, but the situation is much more complicated on\nWindows. If you need to use g_poll() in code that has to run on\nWindows, the easiest solution is to construct all of your\n#GPollFDs with g_io_channel_win32_make_pollfd().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the number of entries in @fds whose %revents fields\nwere filled in, or 0 if the operation timed out, or -1 on error or\nif the call was interrupted.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"fds\" transfer-ownership=\"none\" gs:managed-name=\"fds\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">file descriptors to poll</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n      <parameter name=\"nfds\" transfer-ownership=\"none\" gs:managed-name=\"nfds\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of file descriptors in @fds</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"timeout\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">amount of time to wait, in milliseconds, or -1 to wait forever</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"fds\" transfer-ownership=\"none\" gs:managed-name=\"fds\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">file descriptors to poll</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n      <parameter name=\"nfds\" transfer-ownership=\"none\" gs:managed-name=\"nfds\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of file descriptors in @fds</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"timeout\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">amount of time to wait, in milliseconds, or -1 to wait forever</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    public partial class MainContext : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.MainContext>
    {
        /// <summary>
        /// Returns the global default main context. This is the main context
        /// used for main loop functions when a main loop is not explicitly
        /// specified, and corresponds to the "main" main loop. See also
        /// g_main_context_get_thread_default().
        /// </summary>
        /// <returns>
        /// the global default main context.
        /// </returns>
        public static GISharp.GLib.MainContext Default
        {
            get
            {
                return default(GISharp.GLib.MainContext);
            }
        }

        /// <summary>
        /// Gets the poll function set by g_main_context_set_poll_func().
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// the poll function
        /// </returns>
        public GISharp.GLib.PollFunc PollFunc
        {
            get
            {
                return default(GISharp.GLib.PollFunc);
            }

            set
            {
            }
        }

        /// <summary>
        /// Determines whether this thread holds the (recursive)
        /// ownership of this #GMainContext. This is useful to
        /// know before waiting on another thread that may be
        /// blocking to get ownership of @context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if current thread is owner of @context.
        /// </returns>
        [GISharp.Core.Since("2.10")]
        public System.Boolean IsOwner
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public MainContext(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GMainContext structure.
        /// </summary>
        /// <returns>
        /// the new #GMainContext
        /// </returns>
        public MainContext() : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GMainContext structure.
        /// </summary>
        /// <returns>
        /// the new #GMainContext
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_context_new();

        /// <summary>
        /// Returns the global default main context. This is the main context
        /// used for main loop functions when a main loop is not explicitly
        /// specified, and corresponds to the "main" main loop. See also
        /// g_main_context_get_thread_default().
        /// </summary>
        /// <returns>
        /// the global default main context.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_context_default();

        /// <summary>
        /// Gets the thread-default #GMainContext for this thread, as with
        /// g_main_context_get_thread_default(), but also adds a reference to
        /// it with g_main_context_ref(). In addition, unlike
        /// g_main_context_get_thread_default(), if the thread-default context
        /// is the global default context, this will return that #GMainContext
        /// (with a ref added to it) rather than returning %NULL.
        /// </summary>
        /// <returns>
        /// the thread-default #GMainContext. Unref
        ///     with g_main_context_unref() when you are done with it.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_main_context_ref_thread_default();

        /// <summary>
        /// Gets the thread-default #GMainContext for this thread, as with
        /// g_main_context_get_thread_default(), but also adds a reference to
        /// it with g_main_context_ref(). In addition, unlike
        /// g_main_context_get_thread_default(), if the thread-default context
        /// is the global default context, this will return that #GMainContext
        /// (with a ref added to it) rather than returning %NULL.
        /// </summary>
        /// <returns>
        /// the thread-default #GMainContext. Unref
        ///     with g_main_context_unref() when you are done with it.
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public static GISharp.GLib.MainContext RefThreadDefault()
        {
            return default(GISharp.GLib.MainContext);
        }

        /// <summary>
        /// Returns the depth of the stack of calls to
        /// g_main_context_dispatch() on any #GMainContext in the current thread.
        ///  That is, when called from the toplevel, it gives 0. When
        /// called from within a callback from g_main_context_iteration()
        /// (or g_main_loop_run(), etc.) it returns 1. When called from within
        /// a callback to a recursive call to g_main_context_iteration(),
        /// it returns 2. And so forth.
        /// </summary>
        /// <remarks>
        /// This function is useful in a situation like the following:
        /// Imagine an extremely simple "garbage collected" system.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static GList *free_list;
        /// 
        /// gpointer
        /// allocate_memory (gsize size)
        /// {
        ///   gpointer result = g_malloc (size);
        ///   free_list = g_list_prepend (free_list, result);
        ///   return result;
        /// }
        /// 
        /// void
        /// free_allocated_memory (void)
        /// {
        ///   GList *l;
        ///   for (l = free_list; l; l = l-&gt;next);
        ///     g_free (l-&gt;data);
        ///   g_list_free (free_list);
        ///   free_list = NULL;
        ///  }
        /// 
        /// [...]
        /// 
        /// while (TRUE);
        ///  {
        ///    g_main_context_iteration (NULL, TRUE);
        ///    free_allocated_memory();
        ///   }
        /// ]|
        /// 
        /// This works from an application, however, if you want to do the same
        /// thing from a library, it gets more difficult, since you no longer
        /// control the main loop. You might think you can simply use an idle
        /// function to make the call to free_allocated_memory(), but that
        /// doesn't work, since the idle function could be called from a
        /// recursive callback. This can be fixed by using g_main_depth()
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// gpointer
        /// allocate_memory (gsize size)
        /// {
        ///   FreeListBlock *block = g_new (FreeListBlock, 1);
        ///   block-&gt;mem = g_malloc (size);
        ///   block-&gt;depth = g_main_depth ();
        ///   free_list = g_list_prepend (free_list, block);
        ///   return block-&gt;mem;
        /// }
        /// 
        /// void
        /// free_allocated_memory (void)
        /// {
        ///   GList *l;
        ///   
        ///   int depth = g_main_depth ();
        ///   for (l = free_list; l; );
        ///     {
        ///       GList *next = l-&gt;next;
        ///       FreeListBlock *block = l-&gt;data;
        ///       if (block-&gt;depth &gt; depth)
        ///         {
        ///           g_free (block-&gt;mem);
        ///           g_free (block);
        ///           free_list = g_list_delete_link (free_list, l);
        ///         }
        ///               
        ///       l = next;
        ///     }
        ///   }
        /// ]|
        /// 
        /// There is a temptation to use g_main_depth() to solve
        /// problems with reentrancy. For instance, while waiting for data
        /// to be received from the network in response to a menu item,
        /// the menu item might be selected again. It might seem that
        /// one could make the menu item's callback return immediately
        /// and do nothing if g_main_depth() returns a value greater than 1.
        /// However, this should be avoided since the user then sees selecting
        /// the menu item do nothing. Furthermore, you'll find yourself adding
        /// these checks all over your code, since there are doubtless many,
        /// many things that the user could do. Instead, you can use the
        /// following techniques:
        /// 
        /// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
        ///    the user from interacting with elements while the main
        ///    loop is recursing.
        /// 
        /// 2. Avoid main loop recursion in situations where you can't handle
        ///    arbitrary  callbacks. Instead, structure your code so that you
        ///    simply return to the main loop and then get called again when
        ///    there is more work to do.
        /// </remarks>
        /// <returns>
        /// The main loop recursion level in the current thread
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_main_depth();

        /// <summary>
        /// Returns the depth of the stack of calls to
        /// g_main_context_dispatch() on any #GMainContext in the current thread.
        ///  That is, when called from the toplevel, it gives 0. When
        /// called from within a callback from g_main_context_iteration()
        /// (or g_main_loop_run(), etc.) it returns 1. When called from within
        /// a callback to a recursive call to g_main_context_iteration(),
        /// it returns 2. And so forth.
        /// </summary>
        /// <remarks>
        /// This function is useful in a situation like the following:
        /// Imagine an extremely simple "garbage collected" system.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static GList *free_list;
        /// 
        /// gpointer
        /// allocate_memory (gsize size)
        /// {
        ///   gpointer result = g_malloc (size);
        ///   free_list = g_list_prepend (free_list, result);
        ///   return result;
        /// }
        /// 
        /// void
        /// free_allocated_memory (void)
        /// {
        ///   GList *l;
        ///   for (l = free_list; l; l = l-&gt;next);
        ///     g_free (l-&gt;data);
        ///   g_list_free (free_list);
        ///   free_list = NULL;
        ///  }
        /// 
        /// [...]
        /// 
        /// while (TRUE);
        ///  {
        ///    g_main_context_iteration (NULL, TRUE);
        ///    free_allocated_memory();
        ///   }
        /// ]|
        /// 
        /// This works from an application, however, if you want to do the same
        /// thing from a library, it gets more difficult, since you no longer
        /// control the main loop. You might think you can simply use an idle
        /// function to make the call to free_allocated_memory(), but that
        /// doesn't work, since the idle function could be called from a
        /// recursive callback. This can be fixed by using g_main_depth()
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// gpointer
        /// allocate_memory (gsize size)
        /// {
        ///   FreeListBlock *block = g_new (FreeListBlock, 1);
        ///   block-&gt;mem = g_malloc (size);
        ///   block-&gt;depth = g_main_depth ();
        ///   free_list = g_list_prepend (free_list, block);
        ///   return block-&gt;mem;
        /// }
        /// 
        /// void
        /// free_allocated_memory (void)
        /// {
        ///   GList *l;
        ///   
        ///   int depth = g_main_depth ();
        ///   for (l = free_list; l; );
        ///     {
        ///       GList *next = l-&gt;next;
        ///       FreeListBlock *block = l-&gt;data;
        ///       if (block-&gt;depth &gt; depth)
        ///         {
        ///           g_free (block-&gt;mem);
        ///           g_free (block);
        ///           free_list = g_list_delete_link (free_list, l);
        ///         }
        ///               
        ///       l = next;
        ///     }
        ///   }
        /// ]|
        /// 
        /// There is a temptation to use g_main_depth() to solve
        /// problems with reentrancy. For instance, while waiting for data
        /// to be received from the network in response to a menu item,
        /// the menu item might be selected again. It might seem that
        /// one could make the menu item's callback return immediately
        /// and do nothing if g_main_depth() returns a value greater than 1.
        /// However, this should be avoided since the user then sees selecting
        /// the menu item do nothing. Furthermore, you'll find yourself adding
        /// these checks all over your code, since there are doubtless many,
        /// many things that the user could do. Instead, you can use the
        /// following techniques:
        /// 
        /// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
        ///    the user from interacting with elements while the main
        ///    loop is recursing.
        /// 
        /// 2. Avoid main loop recursion in situations where you can't handle
        ///    arbitrary  callbacks. Instead, structure your code so that you
        ///    simply return to the main loop and then get called again when
        ///    there is more work to do.
        /// </remarks>
        /// <returns>
        /// The main loop recursion level in the current thread
        /// </returns>
        public static System.Int32 MainDepth()
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Polls @fds, as with the poll() system call, but portably. (On
        /// systems that don't have poll(), it is emulated using select().)
        /// This is used internally by #GMainContext, but it can be called
        /// directly if you need to block until a file descriptor is ready, but
        /// don't want to run the full main loop.
        /// </summary>
        /// <remarks>
        /// Each element of @fds is a #GPollFD describing a single file
        /// descriptor to poll. The %fd field indicates the file descriptor,
        /// and the %events field indicates the events to poll for. On return,
        /// the %revents fields will be filled with the events that actually
        /// occurred.
        /// 
        /// On POSIX systems, the file descriptors in @fds can be any sort of
        /// file descriptor, but the situation is much more complicated on
        /// Windows. If you need to use g_poll() in code that has to run on
        /// Windows, the easiest solution is to construct all of your
        /// #GPollFDs with g_io_channel_win32_make_pollfd().
        /// </remarks>
        /// <param name="fds">
        /// file descriptors to poll
        /// </param>
        /// <param name="nfds">
        /// the number of file descriptors in @fds
        /// </param>
        /// <param name="timeout">
        /// amount of time to wait, in milliseconds, or -1 to wait forever
        /// </param>
        /// <returns>
        /// the number of entries in @fds whose %revents fields
        /// were filled in, or 0 if the operation timed out, or -1 on error or
        /// if the call was interrupted.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.20")]
        static extern System.Int32 g_poll(
            [System.Runtime.InteropServices.In()] GISharp.GLib.PollFD fds,
            [System.Runtime.InteropServices.In()] System.UInt32 nfds,
            [System.Runtime.InteropServices.In()] System.Int32 timeout);

        /// <summary>
        /// Polls @fds, as with the poll() system call, but portably. (On
        /// systems that don't have poll(), it is emulated using select().)
        /// This is used internally by #GMainContext, but it can be called
        /// directly if you need to block until a file descriptor is ready, but
        /// don't want to run the full main loop.
        /// </summary>
        /// <remarks>
        /// Each element of @fds is a #GPollFD describing a single file
        /// descriptor to poll. The %fd field indicates the file descriptor,
        /// and the %events field indicates the events to poll for. On return,
        /// the %revents fields will be filled with the events that actually
        /// occurred.
        /// 
        /// On POSIX systems, the file descriptors in @fds can be any sort of
        /// file descriptor, but the situation is much more complicated on
        /// Windows. If you need to use g_poll() in code that has to run on
        /// Windows, the easiest solution is to construct all of your
        /// #GPollFDs with g_io_channel_win32_make_pollfd().
        /// </remarks>
        /// <param name="fds">
        /// file descriptors to poll
        /// </param>
        /// <param name="nfds">
        /// the number of file descriptors in @fds
        /// </param>
        /// <param name="timeout">
        /// amount of time to wait, in milliseconds, or -1 to wait forever
        /// </param>
        /// <returns>
        /// the number of entries in @fds whose %revents fields
        /// were filled in, or 0 if the operation timed out, or -1 on error or
        /// if the call was interrupted.
        /// </returns>
        [GISharp.Core.Since("2.20")]
        public static System.Int32 Poll(
            GISharp.GLib.PollFD fds,
            System.UInt32 nfds,
            System.Int32 timeout)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Tries to become the owner of the specified context.
        /// If some other thread is the owner of the context,
        /// returns %FALSE immediately. Ownership is properly
        /// recursive: the owner can require ownership again
        /// and will release ownership when g_main_context_release()
        /// is called as many times as g_main_context_acquire().
        /// </summary>
        /// <remarks>
        /// You must be the owner of a context before you
        /// can call g_main_context_prepare(), g_main_context_query(),
        /// g_main_context_check(), g_main_context_dispatch().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if the operation succeeded, and
        ///   this thread is now the owner of @context.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_main_context_acquire(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Tries to become the owner of the specified context.
        /// If some other thread is the owner of the context,
        /// returns %FALSE immediately. Ownership is properly
        /// recursive: the owner can require ownership again
        /// and will release ownership when g_main_context_release()
        /// is called as many times as g_main_context_acquire().
        /// </summary>
        /// <remarks>
        /// You must be the owner of a context before you
        /// can call g_main_context_prepare(), g_main_context_query(),
        /// g_main_context_check(), g_main_context_dispatch().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if the operation succeeded, and
        ///   this thread is now the owner of @context.
        /// </returns>
        public System.Boolean Acquire()
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this context. This will very seldom be used directly. Instead
        /// a typical event source will use g_source_add_unix_fd() instead.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (or %NULL for the default context)
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        /// <param name="priority">
        /// the priority for this file descriptor which should be
        ///      the same as the priority used for g_source_attach() to ensure that the
        ///      file descriptor is polled whenever the results may be needed.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_add_poll(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] GISharp.GLib.PollFD fd,
            [System.Runtime.InteropServices.In()] System.Int32 priority);

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this context. This will very seldom be used directly. Instead
        /// a typical event source will use g_source_add_unix_fd() instead.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (or %NULL for the default context)
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        /// <param name="priority">
        /// the priority for this file descriptor which should be
        ///      the same as the priority used for g_source_attach() to ensure that the
        ///      file descriptor is polled whenever the results may be needed.
        /// </param>
        public void AddPoll(
            GISharp.GLib.PollFD fd,
            System.Int32 priority)
        {
        }

        /// <summary>
        /// Passes the results of polling back to the main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// the maximum numerical priority of sources to check
        /// </param>
        /// <param name="fds">
        /// array of #GPollFD's that was passed to
        ///       the last call to g_main_context_query()
        /// </param>
        /// <param name="nFds">
        /// return value of g_main_context_query()
        /// </param>
        /// <returns>
        /// %TRUE if some sources are ready to be dispatched.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_main_context_check(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.Int32 maxPriority,
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 3)] GISharp.GLib.PollFD[] fds,
            [System.Runtime.InteropServices.In()] System.Int32 nFds);

        /// <summary>
        /// Passes the results of polling back to the main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// the maximum numerical priority of sources to check
        /// </param>
        /// <param name="fds">
        /// array of #GPollFD's that was passed to
        ///       the last call to g_main_context_query()
        /// </param>
        /// <param name="nFds">
        /// return value of g_main_context_query()
        /// </param>
        /// <returns>
        /// %TRUE if some sources are ready to be dispatched.
        /// </returns>
        public System.Int32 Check(
            System.Int32 maxPriority,
            GISharp.GLib.PollFD[] fds)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Dispatches all pending sources.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_dispatch(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Dispatches all pending sources.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        public void Dispatch()
        {
        }

        /// <summary>
        /// Finds a source with the given source functions and user data.  If
        /// multiple sources exist with the same source function and user data,
        /// the first one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used).
        /// </param>
        /// <param name="funcs">
        /// the @source_funcs passed to g_source_new().
        /// </param>
        /// <param name="userData">
        /// the user data from the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_context_find_source_by_funcs_user_data(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFuncs funcs,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Finds a source with the given source functions and user data.  If
        /// multiple sources exist with the same source function and user data,
        /// the first one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used).
        /// </param>
        /// <param name="funcs">
        /// the @source_funcs passed to g_source_new().
        /// </param>
        /// <param name="userData">
        /// the user data from the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        public GISharp.GLib.Source FindSourceByFuncsUserData(
            GISharp.GLib.SourceFuncs funcs,
            System.IntPtr userData)
        {
            return default(GISharp.GLib.Source);
        }

        /// <summary>
        /// Finds a #GSource given a pair of context and ID.
        /// </summary>
        /// <remarks>
        /// It is a programmer error to attempt to lookup a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="sourceId">
        /// the source ID, as returned by g_source_get_id().
        /// </param>
        /// <returns>
        /// the #GSource
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_context_find_source_by_id(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.UInt32 sourceId);

        /// <summary>
        /// Finds a #GSource given a pair of context and ID.
        /// </summary>
        /// <remarks>
        /// It is a programmer error to attempt to lookup a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="sourceId">
        /// the source ID, as returned by g_source_get_id().
        /// </param>
        /// <returns>
        /// the #GSource
        /// </returns>
        public GISharp.GLib.Source FindSourceById(
            System.UInt32 sourceId)
        {
            return default(GISharp.GLib.Source);
        }

        /// <summary>
        /// Finds a source with the given user data for the callback.  If
        /// multiple sources exist with the same user data, the first
        /// one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_context_find_source_by_user_data(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Finds a source with the given user data for the callback.  If
        /// multiple sources exist with the same user data, the first
        /// one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        public GISharp.GLib.Source FindSourceByUserData(
            System.IntPtr userData)
        {
            return default(GISharp.GLib.Source);
        }

        /// <summary>
        /// Gets the poll function set by g_main_context_set_poll_func().
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// the poll function
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.PollFunc g_main_context_get_poll_func(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Invokes a function in such a way that @context is owned during the
        /// invocation of @function.
        /// </summary>
        /// <remarks>
        /// If @context is %NULL then the global default main context — as
        /// returned by g_main_context_default() — is used.
        /// 
        /// If @context is owned by the current thread, @function is called
        /// directly.  Otherwise, if @context is the thread-default main context
        /// of the current thread and g_main_context_acquire() succeeds, then
        /// @function is called and g_main_context_release() is called
        /// afterwards.
        /// 
        /// In any other case, an idle source is created to call @function and
        /// that source is attached to @context (presumably to be run in another
        /// thread).  The idle source is attached with #G_PRIORITY_DEFAULT
        /// priority.  If you want a different priority, use
        /// g_main_context_invoke_full().
        /// 
        /// Note that, as with normal idle functions, @function should probably
        /// return %FALSE.  If it returns %TRUE, it will be continuously run in a
        /// loop (and may prevent this call from returning).
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern void g_main_context_invoke(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc function,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Invokes a function in such a way that @context is owned during the
        /// invocation of @function.
        /// </summary>
        /// <remarks>
        /// If @context is %NULL then the global default main context — as
        /// returned by g_main_context_default() — is used.
        /// 
        /// If @context is owned by the current thread, @function is called
        /// directly.  Otherwise, if @context is the thread-default main context
        /// of the current thread and g_main_context_acquire() succeeds, then
        /// @function is called and g_main_context_release() is called
        /// afterwards.
        /// 
        /// In any other case, an idle source is created to call @function and
        /// that source is attached to @context (presumably to be run in another
        /// thread).  The idle source is attached with #G_PRIORITY_DEFAULT
        /// priority.  If you want a different priority, use
        /// g_main_context_invoke_full().
        /// 
        /// Note that, as with normal idle functions, @function should probably
        /// return %FALSE.  If it returns %TRUE, it will be continuously run in a
        /// loop (and may prevent this call from returning).
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        [GISharp.Core.Since("2.28")]
        public void Invoke(
            GISharp.GLib.SourceFunc function)
        {
        }

        /// <summary>
        /// Invokes a function in such a way that @context is owned during the
        /// invocation of @function.
        /// </summary>
        /// <remarks>
        /// This function is the same as g_main_context_invoke() except that it
        /// lets you specify the priority incase @function ends up being
        /// scheduled as an idle and also lets you give a #GDestroyNotify for @data.
        /// 
        /// @notify should not assume that it is called from any particular
        /// thread or with any particular context acquired.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL
        /// </param>
        /// <param name="priority">
        /// the priority at which to run @function
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern void g_main_context_invoke_full(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.Int32 priority,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc function,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify);

        /// <summary>
        /// Invokes a function in such a way that @context is owned during the
        /// invocation of @function.
        /// </summary>
        /// <remarks>
        /// This function is the same as g_main_context_invoke() except that it
        /// lets you specify the priority incase @function ends up being
        /// scheduled as an idle and also lets you give a #GDestroyNotify for @data.
        /// 
        /// @notify should not assume that it is called from any particular
        /// thread or with any particular context acquired.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL
        /// </param>
        /// <param name="priority">
        /// the priority at which to run @function
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        [GISharp.Core.Since("2.28")]
        public void InvokeFull(
            System.Int32 priority,
            GISharp.GLib.SourceFunc function)
        {
        }

        /// <summary>
        /// Determines whether this thread holds the (recursive)
        /// ownership of this #GMainContext. This is useful to
        /// know before waiting on another thread that may be
        /// blocking to get ownership of @context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if current thread is owner of @context.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.10")]
        static extern System.Boolean g_main_context_is_owner(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Runs a single iteration for the given main loop. This involves
        /// checking to see if any event sources are ready to be processed,
        /// then if no events sources are ready and @may_block is %TRUE, waiting
        /// for a source to become ready, then dispatching the highest priority
        /// events sources that are ready. Otherwise, if @may_block is %FALSE
        /// sources are not waited to become ready, only those highest priority
        /// events sources will be dispatched (if any), that are ready at this
        /// given moment without further waiting.
        /// </summary>
        /// <remarks>
        /// Note that even when @may_block is %TRUE, it is still possible for
        /// g_main_context_iteration() to return %FALSE, since the wait may
        /// be interrupted for other reasons than an event source becoming ready.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="mayBlock">
        /// whether the call may block.
        /// </param>
        /// <returns>
        /// %TRUE if events were dispatched.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_main_context_iteration(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.Boolean mayBlock);

        /// <summary>
        /// Runs a single iteration for the given main loop. This involves
        /// checking to see if any event sources are ready to be processed,
        /// then if no events sources are ready and @may_block is %TRUE, waiting
        /// for a source to become ready, then dispatching the highest priority
        /// events sources that are ready. Otherwise, if @may_block is %FALSE
        /// sources are not waited to become ready, only those highest priority
        /// events sources will be dispatched (if any), that are ready at this
        /// given moment without further waiting.
        /// </summary>
        /// <remarks>
        /// Note that even when @may_block is %TRUE, it is still possible for
        /// g_main_context_iteration() to return %FALSE, since the wait may
        /// be interrupted for other reasons than an event source becoming ready.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="mayBlock">
        /// whether the call may block.
        /// </param>
        /// <returns>
        /// %TRUE if events were dispatched.
        /// </returns>
        public System.Boolean Iteration(
            System.Boolean mayBlock)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Checks if any sources have pending events for the given context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// %TRUE if events are pending.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_main_context_pending(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Checks if any sources have pending events for the given context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// %TRUE if events are pending.
        /// </returns>
        public System.Boolean Pending()
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Pops @context off the thread-default context stack (verifying that
        /// it was on the top of the stack).
        /// </summary>
        /// <param name="context">
        /// a #GMainContext object, or %NULL
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern void g_main_context_pop_thread_default(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Pops @context off the thread-default context stack (verifying that
        /// it was on the top of the stack).
        /// </summary>
        /// <param name="context">
        /// a #GMainContext object, or %NULL
        /// </param>
        [GISharp.Core.Since("2.22")]
        public void PopThreadDefault()
        {
        }

        /// <summary>
        /// Prepares to poll sources within a main loop. The resulting information
        /// for polling is determined by calling g_main_context_query ().
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="priority">
        /// location to store priority of highest priority
        ///            source already ready.
        /// </param>
        /// <returns>
        /// %TRUE if some source is ready to be dispatched
        ///               prior to polling.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_main_context_prepare(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.Int32 priority);

        /// <summary>
        /// Prepares to poll sources within a main loop. The resulting information
        /// for polling is determined by calling g_main_context_query ().
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="priority">
        /// location to store priority of highest priority
        ///            source already ready.
        /// </param>
        /// <returns>
        /// %TRUE if some source is ready to be dispatched
        ///               prior to polling.
        /// </returns>
        public System.Boolean Prepare(
            System.Int32 priority)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Acquires @context and sets it as the thread-default context for the
        /// current thread. This will cause certain asynchronous operations
        /// (such as most [gio][gio]-based I/O) which are
        /// started in this thread to run under @context and deliver their
        /// results to its main loop, rather than running under the global
        /// default context in the main thread. Note that calling this function
        /// changes the context returned by g_main_context_get_thread_default(),
        /// not the one returned by g_main_context_default(), so it does not affect
        /// the context used by functions like g_idle_add().
        /// </summary>
        /// <remarks>
        /// Normally you would call this function shortly after creating a new
        /// thread, passing it a #GMainContext which will be run by a
        /// #GMainLoop in that thread, to set a new default context for all
        /// async operations in that thread. (In this case, you don't need to
        /// ever call g_main_context_pop_thread_default().) In some cases
        /// however, you may want to schedule a single operation in a
        /// non-default context, or temporarily use a non-default context in
        /// the main thread. In that case, you can wrap the call to the
        /// asynchronous operation inside a
        /// g_main_context_push_thread_default() /
        /// g_main_context_pop_thread_default() pair, but it is up to you to
        /// ensure that no other asynchronous operations accidentally get
        /// started while the non-default context is active.
        /// 
        /// Beware that libraries that predate this function may not correctly
        /// handle being used from a thread with a thread-default context. Eg,
        /// see g_file_supports_thread_contexts().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL for the global default context
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern void g_main_context_push_thread_default(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Acquires @context and sets it as the thread-default context for the
        /// current thread. This will cause certain asynchronous operations
        /// (such as most [gio][gio]-based I/O) which are
        /// started in this thread to run under @context and deliver their
        /// results to its main loop, rather than running under the global
        /// default context in the main thread. Note that calling this function
        /// changes the context returned by g_main_context_get_thread_default(),
        /// not the one returned by g_main_context_default(), so it does not affect
        /// the context used by functions like g_idle_add().
        /// </summary>
        /// <remarks>
        /// Normally you would call this function shortly after creating a new
        /// thread, passing it a #GMainContext which will be run by a
        /// #GMainLoop in that thread, to set a new default context for all
        /// async operations in that thread. (In this case, you don't need to
        /// ever call g_main_context_pop_thread_default().) In some cases
        /// however, you may want to schedule a single operation in a
        /// non-default context, or temporarily use a non-default context in
        /// the main thread. In that case, you can wrap the call to the
        /// asynchronous operation inside a
        /// g_main_context_push_thread_default() /
        /// g_main_context_pop_thread_default() pair, but it is up to you to
        /// ensure that no other asynchronous operations accidentally get
        /// started while the non-default context is active.
        /// 
        /// Beware that libraries that predate this function may not correctly
        /// handle being used from a thread with a thread-default context. Eg,
        /// see g_file_supports_thread_contexts().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL for the global default context
        /// </param>
        [GISharp.Core.Since("2.22")]
        public void PushThreadDefault()
        {
        }

        /// <summary>
        /// Determines information necessary to poll this main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// maximum priority source to check
        /// </param>
        /// <param name="timeout">
        /// location to store timeout to be used in polling
        /// </param>
        /// <param name="fds">
        /// location to
        ///       store #GPollFD records that need to be polled.
        /// </param>
        /// <param name="nFds">
        /// length of @fds.
        /// </param>
        /// <returns>
        /// the number of records actually stored in @fds,
        ///   or, if more than @n_fds records need to be stored, the number
        ///   of records that need to be stored.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_main_context_query(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.Int32 maxPriority,
            [System.Runtime.InteropServices.Out()] out System.Int32 timeout,
            [System.Runtime.InteropServices.Out(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 4)] out GISharp.GLib.PollFD[] fds,
            [System.Runtime.InteropServices.In()] System.Int32 nFds);

        /// <summary>
        /// Determines information necessary to poll this main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// maximum priority source to check
        /// </param>
        /// <param name="timeout">
        /// location to store timeout to be used in polling
        /// </param>
        /// <param name="fds">
        /// location to
        ///       store #GPollFD records that need to be polled.
        /// </param>
        /// <param name="nFds">
        /// length of @fds.
        /// </param>
        /// <returns>
        /// the number of records actually stored in @fds,
        ///   or, if more than @n_fds records need to be stored, the number
        ///   of records that need to be stored.
        /// </returns>
        public System.Int32 Query(
            System.Int32 maxPriority,
            out System.Int32 timeout,
            out GISharp.GLib.PollFD[] fds)
        {
            timeout = default(System.Int32);
            fds = default(GISharp.GLib.PollFD[]);
            return default(System.Int32);
        }

        /// <summary>
        /// Increases the reference count on a #GMainContext object by one.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// the @context that was passed in (since 2.6)
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_context_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Increases the reference count on a #GMainContext object by one.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// the @context that was passed in (since 2.6)
        /// </returns>
        public override void Ref()
        {
        }

        /// <summary>
        /// Releases ownership of a context previously acquired by this thread
        /// with g_main_context_acquire(). If the context was acquired multiple
        /// times, the ownership will be released only when g_main_context_release()
        /// is called as many times as it was acquired.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_release(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Releases ownership of a context previously acquired by this thread
        /// with g_main_context_acquire(). If the context was acquired multiple
        /// times, the ownership will be released only when g_main_context_release()
        /// is called as many times as it was acquired.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        public void Release()
        {
        }

        /// <summary>
        /// Removes file descriptor from the set of file descriptors to be
        /// polled for a particular context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="fd">
        /// a #GPollFD descriptor previously added with g_main_context_add_poll()
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_remove_poll(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] GISharp.GLib.PollFD fd);

        /// <summary>
        /// Removes file descriptor from the set of file descriptors to be
        /// polled for a particular context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="fd">
        /// a #GPollFD descriptor previously added with g_main_context_add_poll()
        /// </param>
        public void RemovePoll(
            GISharp.GLib.PollFD fd)
        {
        }

        /// <summary>
        /// Sets the function to use to handle polling of file descriptors. It
        /// will be used instead of the poll() system call
        /// (or GLib's replacement function, which is used where
        /// poll() isn't available).
        /// </summary>
        /// <remarks>
        /// This function could possibly be used to integrate the GLib event
        /// loop with an external event loop.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="func">
        /// the function to call to poll all file descriptors
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_set_poll_func(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] GISharp.GLib.PollFunc func);

        /// <summary>
        /// Decreases the reference count on a #GMainContext object by one. If
        /// the result is zero, free the context and free all associated memory.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Decreases the reference count on a #GMainContext object by one. If
        /// the result is zero, free the context and free all associated memory.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        public override void Unref()
        {
        }

        /// <summary>
        /// If @context is currently blocking in g_main_context_iteration()
        /// waiting for a source to become ready, cause it to stop blocking
        /// and return.  Otherwise, cause the next invocation of
        /// g_main_context_iteration() to return without blocking.
        /// </summary>
        /// <remarks>
        /// This API is useful for low-level control over #GMainContext; for
        /// example, integrating it with main loop implementations such as
        /// #GMainLoop.
        /// 
        /// Another related use for this function is when implementing a main
        /// loop with a termination condition, computed from multiple threads:
        /// 
        /// |[&lt;!-- language="C" --&gt;
        ///   #define NUM_TASKS 10
        ///   static volatile gint tasks_remaining = NUM_TASKS;
        ///   ...
        ///  
        ///   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
        ///     g_main_context_iteration (NULL, TRUE);
        /// ]|
        ///  
        /// Then in a thread:
        /// |[&lt;!-- language="C" --&gt;
        ///   perform_work();
        /// 
        ///   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
        ///     g_main_context_wakeup (NULL);
        /// ]|
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_context_wakeup(
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// If @context is currently blocking in g_main_context_iteration()
        /// waiting for a source to become ready, cause it to stop blocking
        /// and return.  Otherwise, cause the next invocation of
        /// g_main_context_iteration() to return without blocking.
        /// </summary>
        /// <remarks>
        /// This API is useful for low-level control over #GMainContext; for
        /// example, integrating it with main loop implementations such as
        /// #GMainLoop.
        /// 
        /// Another related use for this function is when implementing a main
        /// loop with a termination condition, computed from multiple threads:
        /// 
        /// |[&lt;!-- language="C" --&gt;
        ///   #define NUM_TASKS 10
        ///   static volatile gint tasks_remaining = NUM_TASKS;
        ///   ...
        ///  
        ///   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
        ///     g_main_context_iteration (NULL, TRUE);
        /// ]|
        ///  
        /// Then in a thread:
        /// |[&lt;!-- language="C" --&gt;
        ///   perform_work();
        /// 
        ///   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
        ///     g_main_context_wakeup (NULL);
        /// ]|
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        public void Wakeup()
        {
        }
    }

    /// <summary>
    /// The `GMainLoop` struct is an opaque data type
    /// representing the main event loop of a GLib or GTK+ application.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"MainLoop\" c:type=\"GMainLoop\" glib:type-name=\"GMainLoop\" glib:get-type=\"g_main_loop_get_type\" c:symbol-prefix=\"main_loop\" gs:managed-name=\"MainLoop\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The `GMainLoop` struct is an opaque data type\nrepresenting the main event loop of a GLib or GTK+ application.</doc>\n  <constructor name=\"new\" c:identifier=\"g_main_loop_new\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GMainLoop structure.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GMainLoop.</doc>\n      <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:default=\"null\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext  (if %NULL, the default context will be used).</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </parameter>\n      <parameter name=\"is_running\" transfer-ownership=\"none\" gs:default=\"false\" gs:managed-name=\"isRunning\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">set to %TRUE to indicate that the loop is running. This\nis not very important since calling g_main_loop_run() will set this to\n%TRUE anyway.</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:default=\"null\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext  (if %NULL, the default context will be used).</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </parameter>\n      <parameter name=\"is_running\" transfer-ownership=\"none\" gs:default=\"false\" gs:managed-name=\"isRunning\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">set to %TRUE to indicate that the loop is running. This\nis not very important since calling g_main_loop_run() will set this to\n%TRUE anyway.</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"get_context\" c:identifier=\"g_main_loop_get_context\" gs:managed-name=\"get_Context\" gs:property=\"Context\">\n    <doc xml:space=\"preserve\">Returns the #GMainContext of @loop.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GMainContext of @loop</doc>\n      <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"loop\" transfer-ownership=\"none\" gs:managed-name=\"loop\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainLoop.</doc>\n        <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_running\" c:identifier=\"g_main_loop_is_running\" gs:managed-name=\"get_IsRunning\" gs:property=\"IsRunning\">\n    <doc xml:space=\"preserve\">Checks to see if the main loop is currently being run via g_main_loop_run().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the mainloop is currently being run.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"loop\" transfer-ownership=\"none\" gs:managed-name=\"loop\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainLoop.</doc>\n        <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"quit\" c:identifier=\"g_main_loop_quit\" gs:managed-name=\"Quit\">\n    <doc xml:space=\"preserve\">Stops a #GMainLoop from running. Any calls to g_main_loop_run()\nfor the loop will return.\n\nNote that sources that have already been dispatched when\ng_main_loop_quit() is called will still be executed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"loop\" transfer-ownership=\"none\" gs:managed-name=\"loop\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainLoop</doc>\n        <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"ref\" c:identifier=\"g_main_loop_ref\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count on a #GMainLoop object by one.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">@loop</doc>\n      <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"loop\" transfer-ownership=\"none\" gs:managed-name=\"loop\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainLoop</doc>\n        <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"run\" c:identifier=\"g_main_loop_run\" gs:managed-name=\"Run\">\n    <doc xml:space=\"preserve\">Runs a main loop until g_main_loop_quit() is called on the loop.\nIf this is called for the thread of the loop's #GMainContext,\nit will process events from the loop, otherwise it will\nsimply wait.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"loop\" transfer-ownership=\"none\" gs:managed-name=\"loop\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainLoop</doc>\n        <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref\" c:identifier=\"g_main_loop_unref\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count on a #GMainLoop object by one. If\nthe result is zero, free the loop and free all associated memory.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"loop\" transfer-ownership=\"none\" gs:managed-name=\"loop\" gs:managed-type=\"MainLoop\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainLoop</doc>\n        <type name=\"MainLoop\" c:type=\"GMainLoop*\" gs:managed-name=\"MainLoop\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    public partial class MainLoop : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.MainLoop>
    {
        /// <summary>
        /// Returns the #GMainContext of @loop.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop.
        /// </param>
        /// <returns>
        /// the #GMainContext of @loop
        /// </returns>
        public GISharp.GLib.MainContext Context
        {
            get
            {
                return default(GISharp.GLib.MainContext);
            }
        }

        /// <summary>
        /// Checks to see if the main loop is currently being run via g_main_loop_run().
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop.
        /// </param>
        /// <returns>
        /// %TRUE if the mainloop is currently being run.
        /// </returns>
        public System.Boolean IsRunning
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public MainLoop(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GMainLoop structure.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext  (if %NULL, the default context will be used).
        /// </param>
        /// <param name="isRunning">
        /// set to %TRUE to indicate that the loop is running. This
        /// is not very important since calling g_main_loop_run() will set this to
        /// %TRUE anyway.
        /// </param>
        /// <returns>
        /// a new #GMainLoop.
        /// </returns>
        public MainLoop(
            GISharp.GLib.MainContext context = null,
            System.Boolean isRunning = false) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GMainLoop structure.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext  (if %NULL, the default context will be used).
        /// </param>
        /// <param name="isRunning">
        /// set to %TRUE to indicate that the loop is running. This
        /// is not very important since calling g_main_loop_run() will set this to
        /// %TRUE anyway.
        /// </param>
        /// <returns>
        /// a new #GMainLoop.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_loop_new(
            [System.Runtime.InteropServices.In()] System.IntPtr context,
            [System.Runtime.InteropServices.In()] System.Boolean isRunning);

        /// <summary>
        /// Returns the #GMainContext of @loop.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop.
        /// </param>
        /// <returns>
        /// the #GMainContext of @loop
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_loop_get_context(
            [System.Runtime.InteropServices.In()] System.IntPtr loop);

        /// <summary>
        /// Checks to see if the main loop is currently being run via g_main_loop_run().
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop.
        /// </param>
        /// <returns>
        /// %TRUE if the mainloop is currently being run.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_main_loop_is_running(
            [System.Runtime.InteropServices.In()] System.IntPtr loop);

        /// <summary>
        /// Stops a #GMainLoop from running. Any calls to g_main_loop_run()
        /// for the loop will return.
        /// </summary>
        /// <remarks>
        /// Note that sources that have already been dispatched when
        /// g_main_loop_quit() is called will still be executed.
        /// </remarks>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_loop_quit(
            [System.Runtime.InteropServices.In()] System.IntPtr loop);

        /// <summary>
        /// Stops a #GMainLoop from running. Any calls to g_main_loop_run()
        /// for the loop will return.
        /// </summary>
        /// <remarks>
        /// Note that sources that have already been dispatched when
        /// g_main_loop_quit() is called will still be executed.
        /// </remarks>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        public void Quit()
        {
        }

        /// <summary>
        /// Increases the reference count on a #GMainLoop object by one.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        /// <returns>
        /// @loop
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_main_loop_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr loop);

        /// <summary>
        /// Increases the reference count on a #GMainLoop object by one.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        /// <returns>
        /// @loop
        /// </returns>
        public override void Ref()
        {
        }

        /// <summary>
        /// Runs a main loop until g_main_loop_quit() is called on the loop.
        /// If this is called for the thread of the loop's #GMainContext,
        /// it will process events from the loop, otherwise it will
        /// simply wait.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_loop_run(
            [System.Runtime.InteropServices.In()] System.IntPtr loop);

        /// <summary>
        /// Runs a main loop until g_main_loop_quit() is called on the loop.
        /// If this is called for the thread of the loop's #GMainContext,
        /// it will process events from the loop, otherwise it will
        /// simply wait.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        public void Run()
        {
        }

        /// <summary>
        /// Decreases the reference count on a #GMainLoop object by one. If
        /// the result is zero, free the loop and free all associated memory.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_main_loop_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr loop);

        /// <summary>
        /// Decreases the reference count on a #GMainLoop object by one. If
        /// the result is zero, free the loop and free all associated memory.
        /// </summary>
        /// <param name="loop">
        /// a #GMainLoop
        /// </param>
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// The #GNode struct represents one node in a [n-ary tree][glib-N-ary-Trees].
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Node\" c:type=\"GNode\" gs:managed-name=\"Node\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The #GNode struct represents one node in a [n-ary tree][glib-N-ary-Trees].</doc>\n  <method name=\"child_index\" c:identifier=\"g_node_child_index\" gs:managed-name=\"ChildIndex\">\n    <doc xml:space=\"preserve\">Gets the position of the first child of a #GNode\nwhich contains the given data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the index of the child of @node which contains\n    @data, or -1 if the data is not found</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"child_position\" c:identifier=\"g_node_child_position\" gs:managed-name=\"ChildPosition\">\n    <doc xml:space=\"preserve\">Gets the position of a #GNode with respect to its siblings.\n@child must be a child of @node. The first child is numbered 0,\nthe second 1, and so on.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the position of @child with respect to its siblings</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"child\" transfer-ownership=\"none\" gs:managed-name=\"child\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a child of @node</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"child\" transfer-ownership=\"none\" gs:managed-name=\"child\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a child of @node</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"children_foreach\" c:identifier=\"g_node_children_foreach\" introspectable=\"0\" gs:managed-name=\"ChildrenForeach\">\n    <doc xml:space=\"preserve\">Calls a function for each of the children of a #GNode.\nNote that it doesn't descend beneath the child nodes.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be visited, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"NodeForeachFunc\" gs:unmanaged-type=\"NodeForeachFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each visited node</doc>\n        <type name=\"NodeForeachFunc\" c:type=\"GNodeForeachFunc\" gs:managed-name=\"NodeForeachFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be visited, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"NodeForeachFunc\" gs:unmanaged-type=\"NodeForeachFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each visited node</doc>\n        <type name=\"NodeForeachFunc\" c:type=\"GNodeForeachFunc\" gs:managed-name=\"NodeForeachFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"copy\" c:identifier=\"g_node_copy\" introspectable=\"0\" gs:managed-name=\"Copy\" gs:special-func=\"copy\">\n    <doc xml:space=\"preserve\">Recursively copies a #GNode (but does not deep-copy the data inside the\nnodes, see g_node_copy_deep() if you need that).</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GNode containing the same data pointers</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"copy_deep\" c:identifier=\"g_node_copy_deep\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"CopyDeep\">\n    <doc xml:space=\"preserve\">Recursively copies a #GNode and its data.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GNode containing copies of the data in @node.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"copy_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"copyFunc\" gs:managed-type=\"CopyFunc\" gs:unmanaged-type=\"CopyFuncNative\">\n        <doc xml:space=\"preserve\">the function which is called to copy the data inside each node,\n  or %NULL to use the original data.</doc>\n        <type name=\"CopyFunc\" c:type=\"GCopyFunc\" gs:managed-name=\"CopyFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @copy_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"copy_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"copyFunc\" gs:managed-type=\"CopyFunc\" gs:unmanaged-type=\"CopyFuncNative\">\n        <doc xml:space=\"preserve\">the function which is called to copy the data inside each node,\n  or %NULL to use the original data.</doc>\n        <type name=\"CopyFunc\" c:type=\"GCopyFunc\" gs:managed-name=\"CopyFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"depth\" c:identifier=\"g_node_depth\" gs:managed-name=\"Depth\">\n    <doc xml:space=\"preserve\">Gets the depth of a #GNode.\n\nIf @node is %NULL the depth is 0. The root node has a depth of 1.\nFor the children of the root node the depth is 2. And so on.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the depth of the #GNode</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free\" c:identifier=\"g_node_destroy\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Removes @root and its children from the tree, freeing any memory\nallocated.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"root\" transfer-ownership=\"none\" gs:managed-name=\"root\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the root of the tree/subtree to destroy</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"find\" c:identifier=\"g_node_find\" introspectable=\"0\" gs:managed-name=\"Find\">\n    <doc xml:space=\"preserve\">Finds a #GNode in a tree.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the found #GNode, or %NULL if the data is not found</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"root\" transfer-ownership=\"none\" gs:managed-name=\"root\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the root #GNode of the tree to search</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"order\" transfer-ownership=\"none\" gs:managed-name=\"order\" gs:managed-type=\"TraverseType\" gs:unmanaged-type=\"TraverseType\">\n        <doc xml:space=\"preserve\">the order in which nodes are visited - %G_IN_ORDER,\n    %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER</doc>\n        <type name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be searched, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"order\" transfer-ownership=\"none\" gs:managed-name=\"order\" gs:managed-type=\"TraverseType\" gs:unmanaged-type=\"TraverseType\">\n        <doc xml:space=\"preserve\">the order in which nodes are visited - %G_IN_ORDER,\n    %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER</doc>\n        <type name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be searched, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find_child\" c:identifier=\"g_node_find_child\" introspectable=\"0\" gs:managed-name=\"FindChild\">\n    <doc xml:space=\"preserve\">Finds the first child of a #GNode with the given data.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the found child #GNode, or %NULL if the data is not found</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be searched, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be searched, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"first_sibling\" c:identifier=\"g_node_first_sibling\" introspectable=\"0\" gs:managed-name=\"FirstSibling\">\n    <doc xml:space=\"preserve\">Gets the first sibling of a #GNode.\nThis could possibly be the node itself.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the first sibling of @node</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_root\" c:identifier=\"g_node_get_root\" introspectable=\"0\" gs:managed-name=\"get_Root\" gs:property=\"Root\">\n    <doc xml:space=\"preserve\">Gets the root of a tree.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the root of the tree</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"insert\" c:identifier=\"g_node_insert\" introspectable=\"0\" gs:managed-name=\"Insert\">\n    <doc xml:space=\"preserve\">Inserts a #GNode beneath the parent at the given position.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the inserted #GNode</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"parent\" transfer-ownership=\"none\" gs:managed-name=\"parent\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to place @node under</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"position\" transfer-ownership=\"none\" gs:managed-name=\"position\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to place @node at, with respect to its siblings\n    If position is -1, @node is inserted as the last child of @parent</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"position\" transfer-ownership=\"none\" gs:managed-name=\"position\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to place @node at, with respect to its siblings\n    If position is -1, @node is inserted as the last child of @parent</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_after\" c:identifier=\"g_node_insert_after\" introspectable=\"0\" gs:managed-name=\"InsertAfter\">\n    <doc xml:space=\"preserve\">Inserts a #GNode beneath the parent after the given sibling.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the inserted #GNode</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"parent\" transfer-ownership=\"none\" gs:managed-name=\"parent\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to place @node under</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the sibling #GNode to place @node after.\n    If sibling is %NULL, the node is inserted as the first child of @parent.</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the sibling #GNode to place @node after.\n    If sibling is %NULL, the node is inserted as the first child of @parent.</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_before\" c:identifier=\"g_node_insert_before\" introspectable=\"0\" gs:managed-name=\"InsertBefore\">\n    <doc xml:space=\"preserve\">Inserts a #GNode beneath the parent before the given sibling.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the inserted #GNode</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"parent\" transfer-ownership=\"none\" gs:managed-name=\"parent\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to place @node under</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the sibling #GNode to place @node before.\n    If sibling is %NULL, the node is inserted as the last child of @parent.</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the sibling #GNode to place @node before.\n    If sibling is %NULL, the node is inserted as the last child of @parent.</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"is_ancestor\" c:identifier=\"g_node_is_ancestor\" gs:managed-name=\"IsAncestor\">\n    <doc xml:space=\"preserve\">Returns %TRUE if @node is an ancestor of @descendant.\nThis is true if node is the parent of @descendant,\nor if node is the grandparent of @descendant etc.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @node is an ancestor of @descendant</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"descendant\" transfer-ownership=\"none\" gs:managed-name=\"descendant\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"descendant\" transfer-ownership=\"none\" gs:managed-name=\"descendant\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"last_child\" c:identifier=\"g_node_last_child\" introspectable=\"0\" gs:managed-name=\"LastChild\">\n    <doc xml:space=\"preserve\">Gets the last child of a #GNode.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the last child of @node, or %NULL if @node has no children</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode (must not be %NULL)</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"last_sibling\" c:identifier=\"g_node_last_sibling\" introspectable=\"0\" gs:managed-name=\"LastSibling\">\n    <doc xml:space=\"preserve\">Gets the last sibling of a #GNode.\nThis could possibly be the node itself.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the last sibling of @node</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"max_height\" c:identifier=\"g_node_max_height\" gs:managed-name=\"MaxHeight\">\n    <doc xml:space=\"preserve\">Gets the maximum height of all branches beneath a #GNode.\nThis is the maximum distance from the #GNode to all leaf nodes.\n\nIf @root is %NULL, 0 is returned. If @root has no children,\n1 is returned. If @root has children, 2 is returned. And so on.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the maximum height of the tree beneath @root</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"root\" transfer-ownership=\"none\" gs:managed-name=\"root\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"n_children\" c:identifier=\"g_node_n_children\" gs:managed-name=\"NChildren\">\n    <doc xml:space=\"preserve\">Gets the number of children of a #GNode.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of children of @node</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"n_nodes\" c:identifier=\"g_node_n_nodes\" gs:managed-name=\"NNodes\">\n    <doc xml:space=\"preserve\">Gets the number of nodes in a tree.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of nodes in the tree</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"root\" transfer-ownership=\"none\" gs:managed-name=\"root\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be counted, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be counted, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"nth_child\" c:identifier=\"g_node_nth_child\" introspectable=\"0\" gs:managed-name=\"NthChild\">\n    <doc xml:space=\"preserve\">Gets a child of a #GNode, using the given index.\nThe first child is at index 0. If the index is\ntoo big, %NULL is returned.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the child of @node at index @n</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the desired child</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the desired child</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"prepend\" c:identifier=\"g_node_prepend\" introspectable=\"0\" gs:managed-name=\"Prepend\">\n    <doc xml:space=\"preserve\">Inserts a #GNode as the first child of the given parent.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the inserted #GNode</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"parent\" transfer-ownership=\"none\" gs:managed-name=\"parent\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to place the new #GNode under</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to insert</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"reverse_children\" c:identifier=\"g_node_reverse_children\" gs:managed-name=\"ReverseChildren\">\n    <doc xml:space=\"preserve\">Reverses the order of the children of a #GNode.\n(It doesn't change the order of the grandchildren.)</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GNode.</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"traverse\" c:identifier=\"g_node_traverse\" introspectable=\"0\" gs:managed-name=\"Traverse\">\n    <doc xml:space=\"preserve\">Traverses a tree starting at the given root #GNode.\nIt calls the given function for each node visited.\nThe traversal can be halted at any point by returning %TRUE from @func.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"root\" transfer-ownership=\"none\" gs:managed-name=\"root\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the root #GNode of the tree to traverse</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n      <parameter name=\"order\" transfer-ownership=\"none\" gs:managed-name=\"order\" gs:managed-type=\"TraverseType\" gs:unmanaged-type=\"TraverseType\">\n        <doc xml:space=\"preserve\">the order in which nodes are visited - %G_IN_ORDER,\n    %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.</doc>\n        <type name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be visited, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"max_depth\" transfer-ownership=\"none\" gs:managed-name=\"maxDepth\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the maximum depth of the traversal. Nodes below this\n    depth will not be visited. If max_depth is -1 all nodes in\n    the tree are visited. If depth is 1, only the root is visited.\n    If depth is 2, the root and its children are visited. And so on.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"4\" gs:managed-name=\"func\" gs:managed-type=\"NodeTraverseFunc\" gs:unmanaged-type=\"NodeTraverseFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each visited #GNode</doc>\n        <type name=\"NodeTraverseFunc\" c:type=\"GNodeTraverseFunc\" gs:managed-name=\"NodeTraverseFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"order\" transfer-ownership=\"none\" gs:managed-name=\"order\" gs:managed-type=\"TraverseType\" gs:unmanaged-type=\"TraverseType\">\n        <doc xml:space=\"preserve\">the order in which nodes are visited - %G_IN_ORDER,\n    %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.</doc>\n        <type name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" />\n      </parameter>\n      <parameter name=\"flags\" transfer-ownership=\"none\" gs:managed-name=\"flags\" gs:managed-type=\"TraverseFlags\" gs:unmanaged-type=\"TraverseFlags\">\n        <doc xml:space=\"preserve\">which types of children are to be visited, one of\n    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>\n        <type name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" />\n      </parameter>\n      <parameter name=\"max_depth\" transfer-ownership=\"none\" gs:managed-name=\"maxDepth\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the maximum depth of the traversal. Nodes below this\n    depth will not be visited. If max_depth is -1 all nodes in\n    the tree are visited. If depth is 1, only the root is visited.\n    If depth is 2, the root and its children are visited. And so on.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"4\" gs:managed-name=\"func\" gs:managed-type=\"NodeTraverseFunc\" gs:unmanaged-type=\"NodeTraverseFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each visited #GNode</doc>\n        <type name=\"NodeTraverseFunc\" c:type=\"GNodeTraverseFunc\" gs:managed-name=\"NodeTraverseFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unlink\" c:identifier=\"g_node_unlink\" gs:managed-name=\"Unlink\">\n    <doc xml:space=\"preserve\">Unlinks a #GNode from a tree, resulting in two separate trees.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GNode to unlink, which becomes the root of a new tree</doc>\n        <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"new\" c:identifier=\"g_node_new\" introspectable=\"0\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GNode containing the given data.\nUsed to create the first node in a tree.</doc>\n    <return-value gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GNode</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data of the new node</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data of the new node</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    public partial class Node : GISharp.Core.OwnedOpaque<GISharp.GLib.Node>
    {
        /// <summary>
        /// Gets the root of a tree.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the root of the tree
        /// </returns>
        public GISharp.GLib.Node Root
        {
            get
            {
                return default(GISharp.GLib.Node);
            }
        }

        public Node(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GNode containing the given data.
        /// Used to create the first node in a tree.
        /// </summary>
        /// <param name="data">
        /// the data of the new node
        /// </param>
        /// <returns>
        /// a new #GNode
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_new(
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Creates a new #GNode containing the given data.
        /// Used to create the first node in a tree.
        /// </summary>
        /// <param name="data">
        /// the data of the new node
        /// </param>
        /// <returns>
        /// a new #GNode
        /// </returns>
        public static GISharp.GLib.Node New(
            System.IntPtr data)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Gets the position of the first child of a #GNode
        /// which contains the given data.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the index of the child of @node which contains
        ///     @data, or -1 if the data is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_node_child_index(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Gets the position of the first child of a #GNode
        /// which contains the given data.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the index of the child of @node which contains
        ///     @data, or -1 if the data is not found
        /// </returns>
        public System.Int32 ChildIndex(
            System.IntPtr data)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Gets the position of a #GNode with respect to its siblings.
        /// @child must be a child of @node. The first child is numbered 0,
        /// the second 1, and so on.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="child">
        /// a child of @node
        /// </param>
        /// <returns>
        /// the position of @child with respect to its siblings
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_node_child_position(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] System.IntPtr child);

        /// <summary>
        /// Gets the position of a #GNode with respect to its siblings.
        /// @child must be a child of @node. The first child is numbered 0,
        /// the second 1, and so on.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="child">
        /// a child of @node
        /// </param>
        /// <returns>
        /// the position of @child with respect to its siblings
        /// </returns>
        public System.Int32 ChildPosition(
            GISharp.GLib.Node child)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Calls a function for each of the children of a #GNode.
        /// Note that it doesn't descend beneath the child nodes.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="flags">
        /// which types of children are to be visited, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="func">
        /// the function to call for each visited node
        /// </param>
        /// <param name="data">
        /// user data to pass to the function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_node_children_foreach(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFlags flags,
            [System.Runtime.InteropServices.In()] GISharp.GLib.NodeForeachFunc func,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Calls a function for each of the children of a #GNode.
        /// Note that it doesn't descend beneath the child nodes.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="flags">
        /// which types of children are to be visited, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="func">
        /// the function to call for each visited node
        /// </param>
        /// <param name="data">
        /// user data to pass to the function
        /// </param>
        public void ChildrenForeach(
            GISharp.GLib.TraverseFlags flags,
            GISharp.GLib.NodeForeachFunc func)
        {
        }

        /// <summary>
        /// Recursively copies a #GNode (but does not deep-copy the data inside the
        /// nodes, see g_node_copy_deep() if you need that).
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// a new #GNode containing the same data pointers
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_copy(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Recursively copies a #GNode (but does not deep-copy the data inside the
        /// nodes, see g_node_copy_deep() if you need that).
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// a new #GNode containing the same data pointers
        /// </returns>
        public override GISharp.GLib.Node Copy()
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Recursively copies a #GNode and its data.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="copyFunc">
        /// the function which is called to copy the data inside each node,
        ///   or %NULL to use the original data.
        /// </param>
        /// <param name="data">
        /// data to pass to @copy_func
        /// </param>
        /// <returns>
        /// a new #GNode containing copies of the data in @node.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_node_copy_deep(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] GISharp.Core.CopyFuncNative copyFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Recursively copies a #GNode and its data.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="copyFunc">
        /// the function which is called to copy the data inside each node,
        ///   or %NULL to use the original data.
        /// </param>
        /// <param name="data">
        /// data to pass to @copy_func
        /// </param>
        /// <returns>
        /// a new #GNode containing copies of the data in @node.
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.GLib.Node CopyDeep(
            GISharp.Core.CopyFuncNative copyFunc)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Gets the depth of a #GNode.
        /// </summary>
        /// <remarks>
        /// If @node is %NULL the depth is 0. The root node has a depth of 1.
        /// For the children of the root node the depth is 2. And so on.
        /// </remarks>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the depth of the #GNode
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_node_depth(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Gets the depth of a #GNode.
        /// </summary>
        /// <remarks>
        /// If @node is %NULL the depth is 0. The root node has a depth of 1.
        /// For the children of the root node the depth is 2. And so on.
        /// </remarks>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the depth of the #GNode
        /// </returns>
        public System.UInt32 Depth()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Removes @root and its children from the tree, freeing any memory
        /// allocated.
        /// </summary>
        /// <param name="root">
        /// the root of the tree/subtree to destroy
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_node_destroy(
            [System.Runtime.InteropServices.In()] System.IntPtr root);

        /// <summary>
        /// Removes @root and its children from the tree, freeing any memory
        /// allocated.
        /// </summary>
        /// <param name="root">
        /// the root of the tree/subtree to destroy
        /// </param>
        protected override void Free()
        {
        }

        /// <summary>
        /// Finds a #GNode in a tree.
        /// </summary>
        /// <param name="root">
        /// the root #GNode of the tree to search
        /// </param>
        /// <param name="order">
        /// the order in which nodes are visited - %G_IN_ORDER,
        ///     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER
        /// </param>
        /// <param name="flags">
        /// which types of children are to be searched, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the found #GNode, or %NULL if the data is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_find(
            [System.Runtime.InteropServices.In()] System.IntPtr root,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseType order,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFlags flags,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Finds a #GNode in a tree.
        /// </summary>
        /// <param name="root">
        /// the root #GNode of the tree to search
        /// </param>
        /// <param name="order">
        /// the order in which nodes are visited - %G_IN_ORDER,
        ///     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER
        /// </param>
        /// <param name="flags">
        /// which types of children are to be searched, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the found #GNode, or %NULL if the data is not found
        /// </returns>
        public GISharp.GLib.Node Find(
            GISharp.GLib.TraverseType order,
            GISharp.GLib.TraverseFlags flags,
            System.IntPtr data)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Finds the first child of a #GNode with the given data.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="flags">
        /// which types of children are to be searched, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the found child #GNode, or %NULL if the data is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_find_child(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFlags flags,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Finds the first child of a #GNode with the given data.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="flags">
        /// which types of children are to be searched, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the found child #GNode, or %NULL if the data is not found
        /// </returns>
        public GISharp.GLib.Node FindChild(
            GISharp.GLib.TraverseFlags flags,
            System.IntPtr data)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Gets the first sibling of a #GNode.
        /// This could possibly be the node itself.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the first sibling of @node
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_first_sibling(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Gets the first sibling of a #GNode.
        /// This could possibly be the node itself.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the first sibling of @node
        /// </returns>
        public GISharp.GLib.Node FirstSibling()
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Gets the root of a tree.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the root of the tree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_get_root(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Inserts a #GNode beneath the parent at the given position.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place @node under
        /// </param>
        /// <param name="position">
        /// the position to place @node at, with respect to its siblings
        ///     If position is -1, @node is inserted as the last child of @parent
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_insert(
            [System.Runtime.InteropServices.In()] System.IntPtr parent,
            [System.Runtime.InteropServices.In()] System.Int32 position,
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Inserts a #GNode beneath the parent at the given position.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place @node under
        /// </param>
        /// <param name="position">
        /// the position to place @node at, with respect to its siblings
        ///     If position is -1, @node is inserted as the last child of @parent
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        public GISharp.GLib.Node Insert(
            System.Int32 position,
            GISharp.GLib.Node node)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Inserts a #GNode beneath the parent after the given sibling.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place @node under
        /// </param>
        /// <param name="sibling">
        /// the sibling #GNode to place @node after.
        ///     If sibling is %NULL, the node is inserted as the first child of @parent.
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_insert_after(
            [System.Runtime.InteropServices.In()] System.IntPtr parent,
            [System.Runtime.InteropServices.In()] System.IntPtr sibling,
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Inserts a #GNode beneath the parent after the given sibling.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place @node under
        /// </param>
        /// <param name="sibling">
        /// the sibling #GNode to place @node after.
        ///     If sibling is %NULL, the node is inserted as the first child of @parent.
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        public GISharp.GLib.Node InsertAfter(
            GISharp.GLib.Node sibling,
            GISharp.GLib.Node node)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Inserts a #GNode beneath the parent before the given sibling.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place @node under
        /// </param>
        /// <param name="sibling">
        /// the sibling #GNode to place @node before.
        ///     If sibling is %NULL, the node is inserted as the last child of @parent.
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_insert_before(
            [System.Runtime.InteropServices.In()] System.IntPtr parent,
            [System.Runtime.InteropServices.In()] System.IntPtr sibling,
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Inserts a #GNode beneath the parent before the given sibling.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place @node under
        /// </param>
        /// <param name="sibling">
        /// the sibling #GNode to place @node before.
        ///     If sibling is %NULL, the node is inserted as the last child of @parent.
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        public GISharp.GLib.Node InsertBefore(
            GISharp.GLib.Node sibling,
            GISharp.GLib.Node node)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Returns %TRUE if @node is an ancestor of @descendant.
        /// This is true if node is the parent of @descendant,
        /// or if node is the grandparent of @descendant etc.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="descendant">
        /// a #GNode
        /// </param>
        /// <returns>
        /// %TRUE if @node is an ancestor of @descendant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_node_is_ancestor(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] System.IntPtr descendant);

        /// <summary>
        /// Returns %TRUE if @node is an ancestor of @descendant.
        /// This is true if node is the parent of @descendant,
        /// or if node is the grandparent of @descendant etc.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="descendant">
        /// a #GNode
        /// </param>
        /// <returns>
        /// %TRUE if @node is an ancestor of @descendant
        /// </returns>
        public System.Boolean IsAncestor(
            GISharp.GLib.Node descendant)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Gets the last child of a #GNode.
        /// </summary>
        /// <param name="node">
        /// a #GNode (must not be %NULL)
        /// </param>
        /// <returns>
        /// the last child of @node, or %NULL if @node has no children
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_last_child(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Gets the last child of a #GNode.
        /// </summary>
        /// <param name="node">
        /// a #GNode (must not be %NULL)
        /// </param>
        /// <returns>
        /// the last child of @node, or %NULL if @node has no children
        /// </returns>
        public GISharp.GLib.Node LastChild()
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Gets the last sibling of a #GNode.
        /// This could possibly be the node itself.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the last sibling of @node
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_last_sibling(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Gets the last sibling of a #GNode.
        /// This could possibly be the node itself.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the last sibling of @node
        /// </returns>
        public GISharp.GLib.Node LastSibling()
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Gets the maximum height of all branches beneath a #GNode.
        /// This is the maximum distance from the #GNode to all leaf nodes.
        /// </summary>
        /// <remarks>
        /// If @root is %NULL, 0 is returned. If @root has no children,
        /// 1 is returned. If @root has children, 2 is returned. And so on.
        /// </remarks>
        /// <param name="root">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the maximum height of the tree beneath @root
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_node_max_height(
            [System.Runtime.InteropServices.In()] System.IntPtr root);

        /// <summary>
        /// Gets the maximum height of all branches beneath a #GNode.
        /// This is the maximum distance from the #GNode to all leaf nodes.
        /// </summary>
        /// <remarks>
        /// If @root is %NULL, 0 is returned. If @root has no children,
        /// 1 is returned. If @root has children, 2 is returned. And so on.
        /// </remarks>
        /// <param name="root">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the maximum height of the tree beneath @root
        /// </returns>
        public System.UInt32 MaxHeight()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Gets the number of children of a #GNode.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the number of children of @node
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_node_n_children(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Gets the number of children of a #GNode.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <returns>
        /// the number of children of @node
        /// </returns>
        public System.UInt32 NChildren()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Gets the number of nodes in a tree.
        /// </summary>
        /// <param name="root">
        /// a #GNode
        /// </param>
        /// <param name="flags">
        /// which types of children are to be counted, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <returns>
        /// the number of nodes in the tree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_node_n_nodes(
            [System.Runtime.InteropServices.In()] System.IntPtr root,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFlags flags);

        /// <summary>
        /// Gets the number of nodes in a tree.
        /// </summary>
        /// <param name="root">
        /// a #GNode
        /// </param>
        /// <param name="flags">
        /// which types of children are to be counted, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <returns>
        /// the number of nodes in the tree
        /// </returns>
        public System.UInt32 NNodes(
            GISharp.GLib.TraverseFlags flags)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Gets a child of a #GNode, using the given index.
        /// The first child is at index 0. If the index is
        /// too big, %NULL is returned.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="n">
        /// the index of the desired child
        /// </param>
        /// <returns>
        /// the child of @node at index @n
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_nth_child(
            [System.Runtime.InteropServices.In()] System.IntPtr node,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Gets a child of a #GNode, using the given index.
        /// The first child is at index 0. If the index is
        /// too big, %NULL is returned.
        /// </summary>
        /// <param name="node">
        /// a #GNode
        /// </param>
        /// <param name="n">
        /// the index of the desired child
        /// </param>
        /// <returns>
        /// the child of @node at index @n
        /// </returns>
        public GISharp.GLib.Node NthChild(
            System.UInt32 n)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Inserts a #GNode as the first child of the given parent.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place the new #GNode under
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_node_prepend(
            [System.Runtime.InteropServices.In()] System.IntPtr parent,
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Inserts a #GNode as the first child of the given parent.
        /// </summary>
        /// <param name="parent">
        /// the #GNode to place the new #GNode under
        /// </param>
        /// <param name="node">
        /// the #GNode to insert
        /// </param>
        /// <returns>
        /// the inserted #GNode
        /// </returns>
        public GISharp.GLib.Node Prepend(
            GISharp.GLib.Node node)
        {
            return default(GISharp.GLib.Node);
        }

        /// <summary>
        /// Reverses the order of the children of a #GNode.
        /// (It doesn't change the order of the grandchildren.)
        /// </summary>
        /// <param name="node">
        /// a #GNode.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_node_reverse_children(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Reverses the order of the children of a #GNode.
        /// (It doesn't change the order of the grandchildren.)
        /// </summary>
        /// <param name="node">
        /// a #GNode.
        /// </param>
        public void ReverseChildren()
        {
        }

        /// <summary>
        /// Traverses a tree starting at the given root #GNode.
        /// It calls the given function for each node visited.
        /// The traversal can be halted at any point by returning %TRUE from @func.
        /// </summary>
        /// <param name="root">
        /// the root #GNode of the tree to traverse
        /// </param>
        /// <param name="order">
        /// the order in which nodes are visited - %G_IN_ORDER,
        ///     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.
        /// </param>
        /// <param name="flags">
        /// which types of children are to be visited, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="maxDepth">
        /// the maximum depth of the traversal. Nodes below this
        ///     depth will not be visited. If max_depth is -1 all nodes in
        ///     the tree are visited. If depth is 1, only the root is visited.
        ///     If depth is 2, the root and its children are visited. And so on.
        /// </param>
        /// <param name="func">
        /// the function to call for each visited #GNode
        /// </param>
        /// <param name="data">
        /// user data to pass to the function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_node_traverse(
            [System.Runtime.InteropServices.In()] System.IntPtr root,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseType order,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFlags flags,
            [System.Runtime.InteropServices.In()] System.Int32 maxDepth,
            [System.Runtime.InteropServices.In()] GISharp.GLib.NodeTraverseFunc func,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Traverses a tree starting at the given root #GNode.
        /// It calls the given function for each node visited.
        /// The traversal can be halted at any point by returning %TRUE from @func.
        /// </summary>
        /// <param name="root">
        /// the root #GNode of the tree to traverse
        /// </param>
        /// <param name="order">
        /// the order in which nodes are visited - %G_IN_ORDER,
        ///     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.
        /// </param>
        /// <param name="flags">
        /// which types of children are to be visited, one of
        ///     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
        /// </param>
        /// <param name="maxDepth">
        /// the maximum depth of the traversal. Nodes below this
        ///     depth will not be visited. If max_depth is -1 all nodes in
        ///     the tree are visited. If depth is 1, only the root is visited.
        ///     If depth is 2, the root and its children are visited. And so on.
        /// </param>
        /// <param name="func">
        /// the function to call for each visited #GNode
        /// </param>
        /// <param name="data">
        /// user data to pass to the function
        /// </param>
        public void Traverse(
            GISharp.GLib.TraverseType order,
            GISharp.GLib.TraverseFlags flags,
            System.Int32 maxDepth,
            GISharp.GLib.NodeTraverseFunc func)
        {
        }

        /// <summary>
        /// Unlinks a #GNode from a tree, resulting in two separate trees.
        /// </summary>
        /// <param name="node">
        /// the #GNode to unlink, which becomes the root of a new tree
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_node_unlink(
            [System.Runtime.InteropServices.In()] System.IntPtr node);

        /// <summary>
        /// Unlinks a #GNode from a tree, resulting in two separate trees.
        /// </summary>
        /// <param name="node">
        /// the #GNode to unlink, which becomes the root of a new tree
        /// </param>
        public void Unlink()
        {
        }
    }

    /// <summary>
    /// Specifies the type of function passed to g_node_children_foreach().
    /// The function is called with each child node, together with the user
    /// data passed to g_node_children_foreach().
    /// </summary>
    /// <param name="node">
    /// a #GNode.
    /// </param>
    /// <param name="data">
    /// user data passed to g_node_children_foreach().
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"NodeForeachFunc\" c:type=\"GNodeForeachFunc\" gs:managed-name=\"NodeForeachFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_node_children_foreach().\nThe function is called with each child node, together with the user\ndata passed to g_node_children_foreach().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_children_foreach().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_children_foreach().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void NodeForeachFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr node,
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// Specifies the type of function passed to g_node_children_foreach().
    /// The function is called with each child node, together with the user
    /// data passed to g_node_children_foreach().
    /// </summary>
    /// <param name="node">
    /// a #GNode.
    /// </param>
    /// <param name="data">
    /// user data passed to g_node_children_foreach().
    /// </param>
    [GISharp.Core.GirXml("<callback name=\"NodeForeachFunc\" c:type=\"GNodeForeachFunc\" gs:managed-name=\"NodeForeachFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_node_children_foreach().\nThe function is called with each child node, together with the user\ndata passed to g_node_children_foreach().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_children_foreach().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_children_foreach().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate void NodeForeachFunc(
        GISharp.GLib.Node node,
        System.IntPtr data);

    /// <summary>
    /// Specifies the type of function passed to g_node_traverse(). The
    /// function is called with each of the nodes visited, together with the
    /// user data passed to g_node_traverse(). If the function returns
    /// %TRUE, then the traversal is stopped.
    /// </summary>
    /// <param name="node">
    /// a #GNode.
    /// </param>
    /// <param name="data">
    /// user data passed to g_node_traverse().
    /// </param>
    /// <returns>
    /// %TRUE to stop the traversal.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"NodeTraverseFunc\" c:type=\"GNodeTraverseFunc\" gs:managed-name=\"NodeTraverseFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_node_traverse(). The\nfunction is called with each of the nodes visited, together with the\nuser data passed to g_node_traverse(). If the function returns\n%TRUE, then the traversal is stopped.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">%TRUE to stop the traversal.</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_traverse().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_traverse().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.Boolean NodeTraverseFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr node,
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// Specifies the type of function passed to g_node_traverse(). The
    /// function is called with each of the nodes visited, together with the
    /// user data passed to g_node_traverse(). If the function returns
    /// %TRUE, then the traversal is stopped.
    /// </summary>
    /// <param name="node">
    /// a #GNode.
    /// </param>
    /// <param name="data">
    /// user data passed to g_node_traverse().
    /// </param>
    /// <returns>
    /// %TRUE to stop the traversal.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"NodeTraverseFunc\" c:type=\"GNodeTraverseFunc\" gs:managed-name=\"NodeTraverseFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_node_traverse(). The\nfunction is called with each of the nodes visited, together with the\nuser data passed to g_node_traverse(). If the function returns\n%TRUE, then the traversal is stopped.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">%TRUE to stop the traversal.</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_traverse().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"node\" transfer-ownership=\"none\" gs:managed-name=\"node\" gs:managed-type=\"Node\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GNode.</doc>\n      <type name=\"Node\" c:type=\"GNode*\" gs:managed-name=\"Node\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_node_traverse().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate System.Boolean NodeTraverseFunc(
        GISharp.GLib.Node node,
        System.IntPtr data);

    /// <summary>
    /// Represents a file descriptor, which events to poll for, and which events
    /// occurred.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"PollFD\" c:type=\"GPollFD\" glib:type-name=\"GPollFD\" glib:get-type=\"g_pollfd_get_type\" c:symbol-prefix=\"pollfd\" gs:managed-name=\"PollFD\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Represents a file descriptor, which events to poll for, and which events\noccurred.</doc>\n  <field name=\"fd\" writable=\"1\" gs:managed-name=\"Fd\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <doc xml:space=\"preserve\">the file descriptor to poll (or a HANDLE on Win32)</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </field>\n  <field name=\"events\" writable=\"1\" gs:managed-name=\"Events\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n    <doc xml:space=\"preserve\">a bitwise combination from #GIOCondition, specifying which\n    events should be polled for. Typically for reading from a file\n    descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n    for writing you would use %G_IO_OUT | %G_IO_ERR.</doc>\n    <type name=\"gushort\" c:type=\"gushort\" gs:managed-name=\"Gushort\" />\n  </field>\n  <field name=\"revents\" writable=\"1\" gs:managed-name=\"Revents\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n    <doc xml:space=\"preserve\">a bitwise combination of flags from #GIOCondition, returned\n    from the poll() function to indicate which events occurred.</doc>\n    <type name=\"gushort\" c:type=\"gushort\" gs:managed-name=\"Gushort\" />\n  </field>\n</record>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct PollFD
    {
        /// <summary>
        /// the file descriptor to poll (or a HANDLE on Win32)
        /// </summary>
        public System.Int32 Fd;

        /// <summary>
        /// a bitwise combination from #GIOCondition, specifying which
        ///     events should be polled for. Typically for reading from a file
        ///     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
        ///     for writing you would use %G_IO_OUT | %G_IO_ERR.
        /// </summary>
        public System.UInt16 Events;

        /// <summary>
        /// a bitwise combination of flags from #GIOCondition, returned
        ///     from the poll() function to indicate which events occurred.
        /// </summary>
        public System.UInt16 Revents;
    }

    /// <summary>
    /// Specifies the type of function passed to g_main_context_set_poll_func().
    /// The semantics of the function should match those of the poll() system call.
    /// </summary>
    /// <param name="ufds">
    /// an array of #GPollFD elements
    /// </param>
    /// <param name="nfsd">
    /// the number of elements in @ufds
    /// </param>
    /// <param name="timeout">
    /// the maximum time to wait for an event of the file descriptors.
    ///     A negative value indicates an infinite timeout.
    /// </param>
    /// <returns>
    /// the number of #GPollFD elements which have events or errors
    ///     reported, or -1 if an error occurred.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"PollFunc\" c:type=\"GPollFunc\" gs:managed-name=\"PollFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_main_context_set_poll_func().\nThe semantics of the function should match those of the poll() system call.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <doc xml:space=\"preserve\">the number of #GPollFD elements which have events or errors\n    reported, or -1 if an error occurred.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"ufds\" transfer-ownership=\"none\" gs:managed-name=\"ufds\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n      <doc xml:space=\"preserve\">an array of #GPollFD elements</doc>\n      <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n    </parameter>\n    <parameter name=\"nfsd\" transfer-ownership=\"none\" gs:managed-name=\"nfsd\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of elements in @ufds</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </parameter>\n    <parameter name=\"timeout_\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the maximum time to wait for an event of the file descriptors.\n    A negative value indicates an infinite timeout.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"ufds\" transfer-ownership=\"none\" gs:managed-name=\"ufds\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n      <doc xml:space=\"preserve\">an array of #GPollFD elements</doc>\n      <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n    </parameter>\n    <parameter name=\"nfsd\" transfer-ownership=\"none\" gs:managed-name=\"nfsd\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of elements in @ufds</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </parameter>\n    <parameter name=\"timeout_\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the maximum time to wait for an event of the file descriptors.\n    A negative value indicates an infinite timeout.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.Int32 PollFuncNative(
        [System.Runtime.InteropServices.In()] GISharp.GLib.PollFD ufds,
        [System.Runtime.InteropServices.In()] System.UInt32 nfsd,
        [System.Runtime.InteropServices.In()] System.Int32 timeout);

    /// <summary>
    /// Specifies the type of function passed to g_main_context_set_poll_func().
    /// The semantics of the function should match those of the poll() system call.
    /// </summary>
    /// <param name="ufds">
    /// an array of #GPollFD elements
    /// </param>
    /// <param name="nfsd">
    /// the number of elements in @ufds
    /// </param>
    /// <param name="timeout">
    /// the maximum time to wait for an event of the file descriptors.
    ///     A negative value indicates an infinite timeout.
    /// </param>
    /// <returns>
    /// the number of #GPollFD elements which have events or errors
    ///     reported, or -1 if an error occurred.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"PollFunc\" c:type=\"GPollFunc\" gs:managed-name=\"PollFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_main_context_set_poll_func().\nThe semantics of the function should match those of the poll() system call.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <doc xml:space=\"preserve\">the number of #GPollFD elements which have events or errors\n    reported, or -1 if an error occurred.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"ufds\" transfer-ownership=\"none\" gs:managed-name=\"ufds\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n      <doc xml:space=\"preserve\">an array of #GPollFD elements</doc>\n      <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n    </parameter>\n    <parameter name=\"nfsd\" transfer-ownership=\"none\" gs:managed-name=\"nfsd\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of elements in @ufds</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </parameter>\n    <parameter name=\"timeout_\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the maximum time to wait for an event of the file descriptors.\n    A negative value indicates an infinite timeout.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"ufds\" transfer-ownership=\"none\" gs:managed-name=\"ufds\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n      <doc xml:space=\"preserve\">an array of #GPollFD elements</doc>\n      <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n    </parameter>\n    <parameter name=\"nfsd\" transfer-ownership=\"none\" gs:managed-name=\"nfsd\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of elements in @ufds</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </parameter>\n    <parameter name=\"timeout_\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the maximum time to wait for an event of the file descriptors.\n    A negative value indicates an infinite timeout.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate System.Int32 PollFunc(
        GISharp.GLib.PollFD ufds,
        System.UInt32 nfsd,
        System.Int32 timeout);

    /// <summary>
    /// Contains the public fields of a pointer array.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"PtrArray\" c:type=\"GPtrArray\" glib:type-name=\"GPtrArray\" glib:get-type=\"g_ptr_array_get_type\" c:symbol-prefix=\"ptr_array\" gs:managed-name=\"PtrArray\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Contains the public fields of a pointer array.</doc>\n  <method name=\"add\" c:identifier=\"g_ptr_array_add\" introspectable=\"0\" gs:managed-name=\"Add\">\n    <doc xml:space=\"preserve\">Adds a pointer to the end of the pointer array. The array will grow\nin size automatically if necessary.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to add</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to add</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"foreach\" c:identifier=\"g_ptr_array_foreach\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"Foreach\">\n    <doc xml:space=\"preserve\">Calls a function for each element of a #GPtrArray.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each array element</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each array element</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free\" c:identifier=\"g_ptr_array_free\" introspectable=\"0\" gs:managed-name=\"Free\">\n    <doc xml:space=\"preserve\">Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE\nit frees the memory block holding the elements as well. Pass %FALSE\nif you want to free the #GPtrArray wrapper but preserve the\nunderlying array for use elsewhere. If the reference count of @array\nis greater than one, the #GPtrArray wrapper is preserved but the\nsize of @array will be set to zero.\n\nIf array contents point to dynamically-allocated memory, they should\nbe freed separately if @free_seg is %TRUE and no #GDestroyNotify\nfunction has been set for @array.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the pointer array if @free_seg is %FALSE, otherwise %NULL.\n    The pointer array should be freed using g_free().</doc>\n      <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"free_seg\" transfer-ownership=\"none\" gs:managed-name=\"freeSeg\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">if %TRUE the actual pointer array is freed as well</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"free_seg\" transfer-ownership=\"none\" gs:managed-name=\"freeSeg\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">if %TRUE the actual pointer array is freed as well</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert\" c:identifier=\"g_ptr_array_insert\" version=\"2.40\" introspectable=\"0\" gs:managed-name=\"Insert\">\n    <doc xml:space=\"preserve\">Inserts an element into the pointer array at the given index. The\narray will grow in size automatically if necessary.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the index to place the new element at, or -1 to append</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to add.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the index to place the new element at, or -1 to append</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to add.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <constructor name=\"new\" c:identifier=\"g_ptr_array_new\" introspectable=\"0\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GPtrArray with a reference count of 1.</doc>\n    <return-value gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new #GPtrArray</doc>\n      <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n  </constructor>\n  <constructor name=\"new_full\" c:identifier=\"g_ptr_array_new_full\" version=\"2.30\" introspectable=\"0\" gs:managed-name=\"NewFull\">\n    <doc xml:space=\"preserve\">Creates a new #GPtrArray with @reserved_size pointers preallocated\nand a reference count of 1. This avoids frequent reallocation, if\nyou are going to add many pointers to the array. Note however that\nthe size of the array is still 0. It also set @element_free_func\nfor freeing each element when the array is destroyed either via\ng_ptr_array_unref(), when g_ptr_array_free() is called with\n@free_segment set to %TRUE or when removing elements.</doc>\n    <return-value gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">A new #GPtrArray</doc>\n      <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n    <parameters>\n      <parameter name=\"reserved_size\" transfer-ownership=\"none\" gs:managed-name=\"reservedSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of pointers preallocated</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"element_free_func\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"elementFreeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">A function to free elements with\n    destroy @array or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"reserved_size\" transfer-ownership=\"none\" gs:managed-name=\"reservedSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of pointers preallocated</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"element_free_func\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"elementFreeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">A function to free elements with\n    destroy @array or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_with_free_func\" c:identifier=\"g_ptr_array_new_with_free_func\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"NewWithFreeFunc\">\n    <doc xml:space=\"preserve\">Creates a new #GPtrArray with a reference count of 1 and use\n@element_free_func for freeing each element when the array is destroyed\neither via g_ptr_array_unref(), when g_ptr_array_free() is called with\n@free_segment set to %TRUE or when removing elements.</doc>\n    <return-value gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">A new #GPtrArray</doc>\n      <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n    <parameters>\n      <parameter name=\"element_free_func\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"elementFreeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">A function to free elements with\n    destroy @array or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"element_free_func\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"elementFreeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">A function to free elements with\n    destroy @array or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"ref\" c:identifier=\"g_ptr_array_ref\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Atomically increments the reference count of @array by one.\nThis function is thread-safe and may be called from any thread.</doc>\n    <return-value skip=\"1\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">The passed in #GPtrArray</doc>\n      <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove\" c:identifier=\"g_ptr_array_remove\" introspectable=\"0\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes the first occurrence of the given pointer from the pointer\narray. The following elements are moved down one place. If @array\nhas a non-%NULL #GDestroyNotify function it is called for the\nremoved element.\n\nIt returns %TRUE if the pointer was removed, or %FALSE if the\npointer was not found.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the pointer is removed, %FALSE if the pointer\n    is not found in the array</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to remove</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to remove</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_fast\" c:identifier=\"g_ptr_array_remove_fast\" introspectable=\"0\" gs:managed-name=\"RemoveFast\">\n    <doc xml:space=\"preserve\">Removes the first occurrence of the given pointer from the pointer\narray. The last element in the array is used to fill in the space,\nso this function does not preserve the order of the array. But it\nis faster than g_ptr_array_remove(). If @array has a non-%NULL\n#GDestroyNotify function it is called for the removed element.\n\nIt returns %TRUE if the pointer was removed, or %FALSE if the\npointer was not found.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the pointer was found in the array</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to remove</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the pointer to remove</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_index\" c:identifier=\"g_ptr_array_remove_index\" introspectable=\"0\" gs:managed-name=\"RemoveIndex\">\n    <doc xml:space=\"preserve\">Removes the pointer at the given index from the pointer array.\nThe following elements are moved down one place. If @array has\na non-%NULL #GDestroyNotify function it is called for the removed\nelement.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the pointer which was removed</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the pointer to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the pointer to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_index_fast\" c:identifier=\"g_ptr_array_remove_index_fast\" introspectable=\"0\" gs:managed-name=\"RemoveIndexFast\">\n    <doc xml:space=\"preserve\">Removes the pointer at the given index from the pointer array.\nThe last element in the array is used to fill in the space, so\nthis function does not preserve the order of the array. But it\nis faster than g_ptr_array_remove_index(). If @array has a non-%NULL\n#GDestroyNotify function it is called for the removed element.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the pointer which was removed</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the pointer to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the pointer to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_range\" c:identifier=\"g_ptr_array_remove_range\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"RemoveRange\">\n    <doc xml:space=\"preserve\">Removes the given number of pointers starting at the given index\nfrom a #GPtrArray. The following elements are moved to close the\ngap. If @array has a non-%NULL #GDestroyNotify function it is\ncalled for the removed elements.</doc>\n    <return-value gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the @array</doc>\n      <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a @GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the first pointer to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of pointers to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the index of the first pointer to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the number of pointers to remove</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_free_func\" c:identifier=\"g_ptr_array_set_free_func\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"SetFreeFunc\">\n    <doc xml:space=\"preserve\">Sets a function for freeing each element when @array is destroyed\neither via g_ptr_array_unref(), when g_ptr_array_free() is called\nwith @free_segment set to %TRUE or when removing elements.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"element_free_func\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"elementFreeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">A function to free elements with\n    destroy @array or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"element_free_func\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"elementFreeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">A function to free elements with\n    destroy @array or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_size\" c:identifier=\"g_ptr_array_set_size\" introspectable=\"0\" gs:managed-name=\"SetSize\">\n    <doc xml:space=\"preserve\">Sets the size of the array. When making the array larger,\nnewly-added elements will be set to %NULL. When making it smaller,\nif @array has a non-%NULL #GDestroyNotify function then it will be\ncalled for the removed elements.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the new length of the pointer array</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the new length of the pointer array</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <constructor name=\"sized_new\" c:identifier=\"g_ptr_array_sized_new\" introspectable=\"0\" gs:managed-name=\"SizedNew\">\n    <doc xml:space=\"preserve\">Creates a new #GPtrArray with @reserved_size pointers preallocated\nand a reference count of 1. This avoids frequent reallocation, if\nyou are going to add many pointers to the array. Note however that\nthe size of the array is still 0.</doc>\n    <return-value gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new #GPtrArray</doc>\n      <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n    <parameters>\n      <parameter name=\"reserved_size\" transfer-ownership=\"none\" gs:managed-name=\"reservedSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of pointers preallocated</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"reserved_size\" transfer-ownership=\"none\" gs:managed-name=\"reservedSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">number of pointers preallocated</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"sort\" c:identifier=\"g_ptr_array_sort\" introspectable=\"0\" gs:managed-name=\"Sort\">\n    <doc xml:space=\"preserve\">Sorts the array, using @compare_func which should be a qsort()-style\ncomparison function (returns less than zero for first arg is less\nthan second arg, zero for equal, greater than zero if irst arg is\ngreater than second arg).\n\nNote that the comparison function for g_ptr_array_sort() doesn't\ntake the pointers from the array as arguments, it takes pointers to\nthe pointers in the array.\n\nThis is guaranteed to be a stable sort since version 2.32.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"sort_with_data\" c:identifier=\"g_ptr_array_sort_with_data\" introspectable=\"0\" gs:managed-name=\"SortWithData\">\n    <doc xml:space=\"preserve\">Like g_ptr_array_sort(), but the comparison function has an extra\nuser data argument.\n\nNote that the comparison function for g_ptr_array_sort_with_data()\ndoesn't take the pointers from the array as arguments, it takes\npointers to the pointers in the array.\n\nThis is guaranteed to be a stable sort since version 2.32.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @compare_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @compare_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_ptr_array_unref\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Atomically decrements the reference count of @array by one. If the\nreference count drops to 0, the effect is the same as calling\ng_ptr_array_free() with @free_segment set to %TRUE. This function\nis MT-safe and may be called from any thread.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"array\" transfer-ownership=\"none\" gs:managed-name=\"array\" gs:managed-type=\"GLib.PtrArray`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GPtrArray</doc>\n        <array name=\"GLib.PtrArray\" c:type=\"GPtrArray*\" gs:managed-name=\"GLib.PtrArray\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </array>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    public partial class PtrArray : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.PtrArray>
    {
        public PtrArray(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GPtrArray with a reference count of 1.
        /// </summary>
        /// <returns>
        /// the new #GPtrArray
        /// </returns>
        public PtrArray() : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GPtrArray with @reserved_size pointers preallocated
        /// and a reference count of 1. This avoids frequent reallocation, if
        /// you are going to add many pointers to the array. Note however that
        /// the size of the array is still 0. It also set @element_free_func
        /// for freeing each element when the array is destroyed either via
        /// g_ptr_array_unref(), when g_ptr_array_free() is called with
        /// @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="reservedSize">
        /// number of pointers preallocated
        /// </param>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        /// <returns>
        /// A new #GPtrArray
        /// </returns>
        [GISharp.Core.Since("2.30")]
        public PtrArray(
            System.UInt32 reservedSize,
            GISharp.GLib.DestroyNotify elementFreeFunc) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GPtrArray with a reference count of 1 and use
        /// @element_free_func for freeing each element when the array is destroyed
        /// either via g_ptr_array_unref(), when g_ptr_array_free() is called with
        /// @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        /// <returns>
        /// A new #GPtrArray
        /// </returns>
        [GISharp.Core.Since("2.22")]
        public PtrArray(
            GISharp.GLib.DestroyNotify elementFreeFunc) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GPtrArray with @reserved_size pointers preallocated
        /// and a reference count of 1. This avoids frequent reallocation, if
        /// you are going to add many pointers to the array. Note however that
        /// the size of the array is still 0.
        /// </summary>
        /// <param name="reservedSize">
        /// number of pointers preallocated
        /// </param>
        /// <returns>
        /// the new #GPtrArray
        /// </returns>
        public PtrArray(
            System.UInt32 reservedSize) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GPtrArray with a reference count of 1.
        /// </summary>
        /// <returns>
        /// the new #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_ptr_array_new();

        /// <summary>
        /// Creates a new #GPtrArray with @reserved_size pointers preallocated
        /// and a reference count of 1. This avoids frequent reallocation, if
        /// you are going to add many pointers to the array. Note however that
        /// the size of the array is still 0. It also set @element_free_func
        /// for freeing each element when the array is destroyed either via
        /// g_ptr_array_unref(), when g_ptr_array_free() is called with
        /// @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="reservedSize">
        /// number of pointers preallocated
        /// </param>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        /// <returns>
        /// A new #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.30")]
        static extern System.IntPtr g_ptr_array_new_full(
            [System.Runtime.InteropServices.In()] System.UInt32 reservedSize,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify elementFreeFunc);

        /// <summary>
        /// Creates a new #GPtrArray with a reference count of 1 and use
        /// @element_free_func for freeing each element when the array is destroyed
        /// either via g_ptr_array_unref(), when g_ptr_array_free() is called with
        /// @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        /// <returns>
        /// A new #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern System.IntPtr g_ptr_array_new_with_free_func(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify elementFreeFunc);

        /// <summary>
        /// Creates a new #GPtrArray with @reserved_size pointers preallocated
        /// and a reference count of 1. This avoids frequent reallocation, if
        /// you are going to add many pointers to the array. Note however that
        /// the size of the array is still 0.
        /// </summary>
        /// <param name="reservedSize">
        /// number of pointers preallocated
        /// </param>
        /// <returns>
        /// the new #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_ptr_array_sized_new(
            [System.Runtime.InteropServices.In()] System.UInt32 reservedSize);

        /// <summary>
        /// Adds a pointer to the end of the pointer array. The array will grow
        /// in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to add
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_ptr_array_add(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a pointer to the end of the pointer array. The array will grow
        /// in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to add
        /// </param>
        public void Add(
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Calls a function for each element of a #GPtrArray.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="func">
        /// the function to call for each array element
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_ptr_array_foreach(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] GISharp.Core.FuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls a function for each element of a #GPtrArray.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="func">
        /// the function to call for each array element
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void Foreach(
            GISharp.Core.FuncNative func,
            System.IntPtr userData)
        {
        }

        /// <summary>
        /// Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE
        /// it frees the memory block holding the elements as well. Pass %FALSE
        /// if you want to free the #GPtrArray wrapper but preserve the
        /// underlying array for use elsewhere. If the reference count of @array
        /// is greater than one, the #GPtrArray wrapper is preserved but the
        /// size of @array will be set to zero.
        /// </summary>
        /// <remarks>
        /// If array contents point to dynamically-allocated memory, they should
        /// be freed separately if @free_seg is %TRUE and no #GDestroyNotify
        /// function has been set for @array.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="freeSeg">
        /// if %TRUE the actual pointer array is freed as well
        /// </param>
        /// <returns>
        /// the pointer array if @free_seg is %FALSE, otherwise %NULL.
        ///     The pointer array should be freed using g_free().
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_ptr_array_free(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.Boolean freeSeg);

        /// <summary>
        /// Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE
        /// it frees the memory block holding the elements as well. Pass %FALSE
        /// if you want to free the #GPtrArray wrapper but preserve the
        /// underlying array for use elsewhere. If the reference count of @array
        /// is greater than one, the #GPtrArray wrapper is preserved but the
        /// size of @array will be set to zero.
        /// </summary>
        /// <remarks>
        /// If array contents point to dynamically-allocated memory, they should
        /// be freed separately if @free_seg is %TRUE and no #GDestroyNotify
        /// function has been set for @array.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="freeSeg">
        /// if %TRUE the actual pointer array is freed as well
        /// </param>
        /// <returns>
        /// the pointer array if @free_seg is %FALSE, otherwise %NULL.
        ///     The pointer array should be freed using g_free().
        /// </returns>
        public System.IntPtr Free(
            System.Boolean freeSeg)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Inserts an element into the pointer array at the given index. The
        /// array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index to place the new element at, or -1 to append
        /// </param>
        /// <param name="data">
        /// the pointer to add.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern void g_ptr_array_insert(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.Int32 index,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Inserts an element into the pointer array at the given index. The
        /// array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index to place the new element at, or -1 to append
        /// </param>
        /// <param name="data">
        /// the pointer to add.
        /// </param>
        [GISharp.Core.Since("2.40")]
        public void Insert(
            System.Int32 index,
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Atomically increments the reference count of @array by one.
        /// This function is thread-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <returns>
        /// The passed in #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern System.IntPtr g_ptr_array_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr array);

        /// <summary>
        /// Atomically increments the reference count of @array by one.
        /// This function is thread-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <returns>
        /// The passed in #GPtrArray
        /// </returns>
        [GISharp.Core.Since("2.22")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Removes the first occurrence of the given pointer from the pointer
        /// array. The following elements are moved down one place. If @array
        /// has a non-%NULL #GDestroyNotify function it is called for the
        /// removed element.
        /// </summary>
        /// <remarks>
        /// It returns %TRUE if the pointer was removed, or %FALSE if the
        /// pointer was not found.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to remove
        /// </param>
        /// <returns>
        /// %TRUE if the pointer is removed, %FALSE if the pointer
        ///     is not found in the array
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_ptr_array_remove(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Removes the first occurrence of the given pointer from the pointer
        /// array. The following elements are moved down one place. If @array
        /// has a non-%NULL #GDestroyNotify function it is called for the
        /// removed element.
        /// </summary>
        /// <remarks>
        /// It returns %TRUE if the pointer was removed, or %FALSE if the
        /// pointer was not found.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to remove
        /// </param>
        /// <returns>
        /// %TRUE if the pointer is removed, %FALSE if the pointer
        ///     is not found in the array
        /// </returns>
        public System.Boolean Remove(
            System.IntPtr data)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes the first occurrence of the given pointer from the pointer
        /// array. The last element in the array is used to fill in the space,
        /// so this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_remove(). If @array has a non-%NULL
        /// #GDestroyNotify function it is called for the removed element.
        /// </summary>
        /// <remarks>
        /// It returns %TRUE if the pointer was removed, or %FALSE if the
        /// pointer was not found.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to remove
        /// </param>
        /// <returns>
        /// %TRUE if the pointer was found in the array
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_ptr_array_remove_fast(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Removes the first occurrence of the given pointer from the pointer
        /// array. The last element in the array is used to fill in the space,
        /// so this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_remove(). If @array has a non-%NULL
        /// #GDestroyNotify function it is called for the removed element.
        /// </summary>
        /// <remarks>
        /// It returns %TRUE if the pointer was removed, or %FALSE if the
        /// pointer was not found.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to remove
        /// </param>
        /// <returns>
        /// %TRUE if the pointer was found in the array
        /// </returns>
        public System.Boolean RemoveFast(
            System.IntPtr data)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The following elements are moved down one place. If @array has
        /// a non-%NULL #GDestroyNotify function it is called for the removed
        /// element.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to remove
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_ptr_array_remove_index(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 index);

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The following elements are moved down one place. If @array has
        /// a non-%NULL #GDestroyNotify function it is called for the removed
        /// element.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to remove
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        public System.IntPtr RemoveIndex(
            System.UInt32 index)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The last element in the array is used to fill in the space, so
        /// this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_remove_index(). If @array has a non-%NULL
        /// #GDestroyNotify function it is called for the removed element.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to remove
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_ptr_array_remove_index_fast(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 index);

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The last element in the array is used to fill in the space, so
        /// this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_remove_index(). If @array has a non-%NULL
        /// #GDestroyNotify function it is called for the removed element.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to remove
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        public System.IntPtr RemoveIndexFast(
            System.UInt32 index)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Removes the given number of pointers starting at the given index
        /// from a #GPtrArray. The following elements are moved to close the
        /// gap. If @array has a non-%NULL #GDestroyNotify function it is
        /// called for the removed elements.
        /// </summary>
        /// <param name="array">
        /// a @GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the first pointer to remove
        /// </param>
        /// <param name="length">
        /// the number of pointers to remove
        /// </param>
        /// <returns>
        /// the @array
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_ptr_array_remove_range(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.UInt32 index,
            [System.Runtime.InteropServices.In()] System.UInt32 length);

        /// <summary>
        /// Removes the given number of pointers starting at the given index
        /// from a #GPtrArray. The following elements are moved to close the
        /// gap. If @array has a non-%NULL #GDestroyNotify function it is
        /// called for the removed elements.
        /// </summary>
        /// <param name="array">
        /// a @GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the first pointer to remove
        /// </param>
        /// <param name="length">
        /// the number of pointers to remove
        /// </param>
        /// <returns>
        /// the @array
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.PtrArray<GISharp.Core.IWrappedNative> RemoveRange(
            System.UInt32 index,
            System.UInt32 length)
        {
            return default(GISharp.Core.PtrArray<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Sets a function for freeing each element when @array is destroyed
        /// either via g_ptr_array_unref(), when g_ptr_array_free() is called
        /// with @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="array">
        /// A #GPtrArray
        /// </param>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern void g_ptr_array_set_free_func(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify elementFreeFunc);

        /// <summary>
        /// Sets a function for freeing each element when @array is destroyed
        /// either via g_ptr_array_unref(), when g_ptr_array_free() is called
        /// with @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="array">
        /// A #GPtrArray
        /// </param>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        [GISharp.Core.Since("2.22")]
        public void SetFreeFunc(
            GISharp.GLib.DestroyNotify elementFreeFunc)
        {
        }

        /// <summary>
        /// Sets the size of the array. When making the array larger,
        /// newly-added elements will be set to %NULL. When making it smaller,
        /// if @array has a non-%NULL #GDestroyNotify function then it will be
        /// called for the removed elements.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="length">
        /// the new length of the pointer array
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_ptr_array_set_size(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] System.Int32 length);

        /// <summary>
        /// Sets the size of the array. When making the array larger,
        /// newly-added elements will be set to %NULL. When making it smaller,
        /// if @array has a non-%NULL #GDestroyNotify function then it will be
        /// called for the removed elements.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="length">
        /// the new length of the pointer array
        /// </param>
        public void SetSize(
            System.Int32 length)
        {
        }

        /// <summary>
        /// Sorts the array, using @compare_func which should be a qsort()-style
        /// comparison function (returns less than zero for first arg is less
        /// than second arg, zero for equal, greater than zero if irst arg is
        /// greater than second arg).
        /// </summary>
        /// <remarks>
        /// Note that the comparison function for g_ptr_array_sort() doesn't
        /// take the pointers from the array as arguments, it takes pointers to
        /// the pointers in the array.
        /// 
        /// This is guaranteed to be a stable sort since version 2.32.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_ptr_array_sort(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative compareFunc);

        /// <summary>
        /// Sorts the array, using @compare_func which should be a qsort()-style
        /// comparison function (returns less than zero for first arg is less
        /// than second arg, zero for equal, greater than zero if irst arg is
        /// greater than second arg).
        /// </summary>
        /// <remarks>
        /// Note that the comparison function for g_ptr_array_sort() doesn't
        /// take the pointers from the array as arguments, it takes pointers to
        /// the pointers in the array.
        /// 
        /// This is guaranteed to be a stable sort since version 2.32.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        public void Sort(
            GISharp.Core.CompareFuncNative compareFunc)
        {
        }

        /// <summary>
        /// Like g_ptr_array_sort(), but the comparison function has an extra
        /// user data argument.
        /// </summary>
        /// <remarks>
        /// Note that the comparison function for g_ptr_array_sort_with_data()
        /// doesn't take the pointers from the array as arguments, it takes
        /// pointers to the pointers in the array.
        /// 
        /// This is guaranteed to be a stable sort since version 2.32.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to @compare_func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_ptr_array_sort_with_data(
            [System.Runtime.InteropServices.In()] System.IntPtr array,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative compareFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Like g_ptr_array_sort(), but the comparison function has an extra
        /// user data argument.
        /// </summary>
        /// <remarks>
        /// Note that the comparison function for g_ptr_array_sort_with_data()
        /// doesn't take the pointers from the array as arguments, it takes
        /// pointers to the pointers in the array.
        /// 
        /// This is guaranteed to be a stable sort since version 2.32.
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to @compare_func
        /// </param>
        public void SortWithData(
            GISharp.Core.CompareDataFuncNative compareFunc,
            System.IntPtr userData)
        {
        }

        /// <summary>
        /// Atomically decrements the reference count of @array by one. If the
        /// reference count drops to 0, the effect is the same as calling
        /// g_ptr_array_free() with @free_segment set to %TRUE. This function
        /// is MT-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// A #GPtrArray
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern void g_ptr_array_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr array);

        /// <summary>
        /// Atomically decrements the reference count of @array by one. If the
        /// reference count drops to 0, the effect is the same as calling
        /// g_ptr_array_free() with @free_segment set to %TRUE. This function
        /// is MT-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// A #GPtrArray
        /// </param>
        [GISharp.Core.Since("2.22")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// Contains the public fields of a
    /// [Queue][glib-Double-ended-Queues].
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Queue\" c:type=\"GQueue\" gs:managed-name=\"Queue\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Contains the public fields of a\n[Queue][glib-Double-ended-Queues].</doc>\n  <method name=\"clear\" c:identifier=\"g_queue_clear\" version=\"2.14\" gs:managed-name=\"Clear\">\n    <doc xml:space=\"preserve\">Removes all the elements in @queue. If queue elements contain\ndynamically-allocated memory, they should be freed first.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"copy\" c:identifier=\"g_queue_copy\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"Copy\" gs:special-func=\"copy\">\n    <doc xml:space=\"preserve\">Copies a @queue. Note that is a shallow copy. If the elements in the\nqueue consist of pointers to data, the pointers are copied, but the\nactual data is not.</doc>\n    <return-value gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a copy of @queue</doc>\n      <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"delete_link\" c:identifier=\"g_queue_delete_link\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"DeleteLink\">\n    <doc xml:space=\"preserve\">Removes @link_ from @queue and frees it.\n\n@link_ must be part of @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find\" c:identifier=\"g_queue_find\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"Find\">\n    <doc xml:space=\"preserve\">Finds the first link in @queue which contains @data.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the first link in @queue which contains @data</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find_custom\" c:identifier=\"g_queue_find_custom\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"FindCustom\">\n    <doc xml:space=\"preserve\">Finds an element in a #GQueue, using a supplied function to find the\ndesired element. It iterates over the queue, calling the given function\nwhich should return 0 when the desired element is found. The function\ntakes two gconstpointer arguments, the #GQueue element's data as the\nfirst argument and the given user data as the second argument.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the found link, or %NULL if it wasn't found</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @func</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">a #GCompareFunc to call for each element. It should return 0\n    when the desired element is found</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @func</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">a #GCompareFunc to call for each element. It should return 0\n    when the desired element is found</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"foreach\" c:identifier=\"g_queue_foreach\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"Foreach\">\n    <doc xml:space=\"preserve\">Calls @func for each element in the queue passing @user_data to the\nfunction.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each element's data</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to @func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each element's data</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free\" c:identifier=\"g_queue_free\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees the memory allocated for the #GQueue. Only call this function\nif @queue was created with g_queue_new(). If queue elements contain\ndynamically-allocated memory, they should be freed first.\n\nIf queue elements contain dynamically-allocated memory, you should\neither use g_queue_free_full() or free them manually first.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free_full\" c:identifier=\"g_queue_free_full\" version=\"2.32\" gs:managed-name=\"FreeFull\">\n    <doc xml:space=\"preserve\">Convenience method, which frees all the memory used by a #GQueue,\nand calls the specified destroy function on every element's data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"free_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"freeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">the function to be called to free each element's data</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"free_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"freeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">the function to be called to free each element's data</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_length\" c:identifier=\"g_queue_get_length\" version=\"2.4\" gs:managed-name=\"get_Length\" gs:property=\"Length\">\n    <doc xml:space=\"preserve\">Returns the number of items in @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of items in @queue</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"index\" c:identifier=\"g_queue_index\" version=\"2.4\" gs:managed-name=\"Index\">\n    <doc xml:space=\"preserve\">Returns the position of the first element in @queue which contains @data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the position of the first element in @queue which\n    contains @data, or -1 if no element in @queue contains @data</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"init\" c:identifier=\"g_queue_init\" version=\"2.14\" gs:managed-name=\"Init\">\n    <doc xml:space=\"preserve\">A statically-allocated #GQueue must be initialized with this function\nbefore it can be used. Alternatively you can initialize it with\n#G_QUEUE_INIT. It is not necessary to initialize queues created with\ng_queue_new().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an uninitialized #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"insert_after\" c:identifier=\"g_queue_insert_after\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"InsertAfter\">\n    <doc xml:space=\"preserve\">Inserts @data into @queue after @sibling\n\n@sibling must be part of @queue</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_before\" c:identifier=\"g_queue_insert_before\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"InsertBefore\">\n    <doc xml:space=\"preserve\">Inserts @data into @queue before @sibling.\n\n@sibling must be part of @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_sorted\" c:identifier=\"g_queue_insert_sorted\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"InsertSorted\">\n    <doc xml:space=\"preserve\">Inserts @data into @queue using @func to determine the new position.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the #GCompareDataFunc used to compare elements in the queue. It is\n    called with two elements of the @queue and @user_data. It should\n    return 0 if the elements are equal, a negative value if the first\n    element comes before the second, and a positive value if the second\n    element comes before the first.</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the #GCompareDataFunc used to compare elements in the queue. It is\n    called with two elements of the @queue and @user_data. It should\n    return 0 if the elements are equal, a negative value if the first\n    element comes before the second, and a positive value if the second\n    element comes before the first.</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"is_empty\" c:identifier=\"g_queue_is_empty\" gs:managed-name=\"get_IsEmpty\" gs:property=\"IsEmpty\">\n    <doc xml:space=\"preserve\">Returns %TRUE if the queue is empty.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the queue is empty</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue.</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"link_index\" c:identifier=\"g_queue_link_index\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"LinkIndex\">\n    <doc xml:space=\"preserve\">Returns the position of @link_ in @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the position of @link_, or -1 if the link is\n    not part of @queue</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"peek_head\" c:identifier=\"g_queue_peek_head\" introspectable=\"0\" gs:managed-name=\"PeekHead\">\n    <doc xml:space=\"preserve\">Returns the first element of the queue.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data of the first element in the queue, or %NULL\n    if the queue is empty</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"peek_head_link\" c:identifier=\"g_queue_peek_head_link\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PeekHeadLink\">\n    <doc xml:space=\"preserve\">Returns the first link in @queue.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the first link in @queue, or %NULL if @queue is empty</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"peek_nth\" c:identifier=\"g_queue_peek_nth\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PeekNth\">\n    <doc xml:space=\"preserve\">Returns the @n'th element of @queue.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data for the @n'th element of @queue,\n    or %NULL if @n is off the end of @queue</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"peek_nth_link\" c:identifier=\"g_queue_peek_nth_link\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PeekNthLink\">\n    <doc xml:space=\"preserve\">Returns the link at the given position</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the link at the @n'th position, or %NULL\n    if @n is off the end of the list</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the link</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the link</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"peek_tail\" c:identifier=\"g_queue_peek_tail\" introspectable=\"0\" gs:managed-name=\"PeekTail\">\n    <doc xml:space=\"preserve\">Returns the last element of the queue.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data of the last element in the queue, or %NULL\n    if the queue is empty</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"peek_tail_link\" c:identifier=\"g_queue_peek_tail_link\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PeekTailLink\">\n    <doc xml:space=\"preserve\">Returns the last link in @queue.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the last link in @queue, or %NULL if @queue is empty</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"pop_head\" c:identifier=\"g_queue_pop_head\" introspectable=\"0\" gs:managed-name=\"PopHead\">\n    <doc xml:space=\"preserve\">Removes the first element of the queue and returns its data.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data of the first element in the queue, or %NULL\n    if the queue is empty</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"pop_head_link\" c:identifier=\"g_queue_pop_head_link\" introspectable=\"0\" gs:managed-name=\"PopHeadLink\">\n    <doc xml:space=\"preserve\">Removes and returns the first element of the queue.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GList element at the head of the queue, or %NULL\n    if the queue is empty</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"pop_nth\" c:identifier=\"g_queue_pop_nth\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PopNth\">\n    <doc xml:space=\"preserve\">Removes the @n'th element of @queue and returns its data.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the element's data, or %NULL if @n is off the end of @queue</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"pop_nth_link\" c:identifier=\"g_queue_pop_nth_link\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PopNthLink\">\n    <doc xml:space=\"preserve\">Removes and returns the link at the given position.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the @n'th link, or %NULL if @n is off the end of @queue</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the link's position</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the link's position</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"pop_tail\" c:identifier=\"g_queue_pop_tail\" introspectable=\"0\" gs:managed-name=\"PopTail\">\n    <doc xml:space=\"preserve\">Removes the last element of the queue and returns its data.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data of the last element in the queue, or %NULL\n    if the queue is empty</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"pop_tail_link\" c:identifier=\"g_queue_pop_tail_link\" introspectable=\"0\" gs:managed-name=\"PopTailLink\">\n    <doc xml:space=\"preserve\">Removes and returns the last element of the queue.</doc>\n    <return-value gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GList element at the tail of the queue, or %NULL\n    if the queue is empty</doc>\n      <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"push_head\" c:identifier=\"g_queue_push_head\" gs:managed-name=\"PushHead\">\n    <doc xml:space=\"preserve\">Adds a new element at the head of the queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue.</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"push_head_link\" c:identifier=\"g_queue_push_head_link\" introspectable=\"0\" gs:managed-name=\"PushHeadLink\">\n    <doc xml:space=\"preserve\">Adds a new element at the head of the queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a single #GList element, not a list with more than one element</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a single #GList element, not a list with more than one element</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"push_nth\" c:identifier=\"g_queue_push_nth\" version=\"2.4\" gs:managed-name=\"PushNth\">\n    <doc xml:space=\"preserve\">Inserts a new element into @queue at the given position.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to insert the new element. If @n is negative or\n    larger than the number of elements in the @queue, the element is\n    added to the end of the queue.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to insert the new element. If @n is negative or\n    larger than the number of elements in the @queue, the element is\n    added to the end of the queue.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"push_nth_link\" c:identifier=\"g_queue_push_nth_link\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"PushNthLink\">\n    <doc xml:space=\"preserve\">Inserts @link into @queue at the given position.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to insert the link. If this is negative or larger than\n    the number of elements in @queue, the link is added to the end of\n    @queue.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the link to add to @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to insert the link. If this is negative or larger than\n    the number of elements in @queue, the link is added to the end of\n    @queue.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the link to add to @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"push_tail\" c:identifier=\"g_queue_push_tail\" gs:managed-name=\"PushTail\">\n    <doc xml:space=\"preserve\">Adds a new element at the tail of the queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"push_tail_link\" c:identifier=\"g_queue_push_tail_link\" introspectable=\"0\" gs:managed-name=\"PushTailLink\">\n    <doc xml:space=\"preserve\">Adds a new element at the tail of the queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a single #GList element, not a list with more than one element</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a single #GList element, not a list with more than one element</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove\" c:identifier=\"g_queue_remove\" version=\"2.4\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes the first element in @queue that contains @data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @data was found and removed from @queue</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_all\" c:identifier=\"g_queue_remove_all\" version=\"2.4\" gs:managed-name=\"RemoveAll\">\n    <doc xml:space=\"preserve\">Remove all elements whose data equals @data from @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of elements removed from @queue</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"reverse\" c:identifier=\"g_queue_reverse\" version=\"2.4\" gs:managed-name=\"Reverse\">\n    <doc xml:space=\"preserve\">Reverses the order of the items in @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"sort\" c:identifier=\"g_queue_sort\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"Sort\">\n    <doc xml:space=\"preserve\">Sorts @queue using @compare_func.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the #GCompareDataFunc used to sort @queue. This function\n    is passed two elements of the queue and should return 0 if they are\n    equal, a negative value if the first comes before the second, and\n    a positive value if the second comes before the first.</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @compare_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the #GCompareDataFunc used to sort @queue. This function\n    is passed two elements of the queue and should return 0 if they are\n    equal, a negative value if the first comes before the second, and\n    a positive value if the second comes before the first.</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unlink\" c:identifier=\"g_queue_unlink\" version=\"2.4\" introspectable=\"0\" gs:managed-name=\"Unlink\">\n    <doc xml:space=\"preserve\">Unlinks @link_ so that it will no longer be part of @queue.\nThe link is not freed.\n\n@link_ must be part of @queue.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"queue\" transfer-ownership=\"none\" gs:managed-name=\"queue\" gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GQueue</doc>\n        <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.List`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GList link that must be part of @queue</doc>\n        <type name=\"GLib.List\" c:type=\"GList*\" gs:managed-name=\"GLib.List\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <constructor name=\"new\" c:identifier=\"g_queue_new\" introspectable=\"0\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GQueue.</doc>\n    <return-value gs:managed-type=\"Queue\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated #GQueue</doc>\n      <type name=\"Queue\" c:type=\"GQueue*\" gs:managed-name=\"Queue\" />\n    </return-value>\n  </constructor>\n</record>")]
    public partial class Queue : GISharp.Core.OwnedOpaque<GISharp.GLib.Queue>
    {
        /// <summary>
        /// Returns the number of items in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the number of items in @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.UInt32 Length
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Returns %TRUE if the queue is empty.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue.
        /// </param>
        /// <returns>
        /// %TRUE if the queue is empty
        /// </returns>
        public System.Boolean IsEmpty
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public Queue(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GQueue.
        /// </summary>
        /// <returns>
        /// a newly allocated #GQueue
        /// </returns>
        public Queue() : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GQueue.
        /// </summary>
        /// <returns>
        /// a newly allocated #GQueue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_new();

        /// <summary>
        /// Removes all the elements in @queue. If queue elements contain
        /// dynamically-allocated memory, they should be freed first.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_queue_clear(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Removes all the elements in @queue. If queue elements contain
        /// dynamically-allocated memory, they should be freed first.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        [GISharp.Core.Since("2.14")]
        public void Clear()
        {
        }

        /// <summary>
        /// Copies a @queue. Note that is a shallow copy. If the elements in the
        /// queue consist of pointers to data, the pointers are copied, but the
        /// actual data is not.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// a copy of @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_copy(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Copies a @queue. Note that is a shallow copy. If the elements in the
        /// queue consist of pointers to data, the pointers are copied, but the
        /// actual data is not.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// a copy of @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public override GISharp.GLib.Queue Copy()
        {
            return default(GISharp.GLib.Queue);
        }

        /// <summary>
        /// Removes @link_ from @queue and frees it.
        /// </summary>
        /// <remarks>
        /// @link_ must be part of @queue.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a #GList link that must be part of @queue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_delete_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Removes @link_ from @queue and frees it.
        /// </summary>
        /// <remarks>
        /// @link_ must be part of @queue.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a #GList link that must be part of @queue
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void DeleteLink(
            GISharp.Core.List<GISharp.Core.IWrappedNative> link)
        {
        }

        /// <summary>
        /// Finds the first link in @queue which contains @data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// data to find
        /// </param>
        /// <returns>
        /// the first link in @queue which contains @data
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_find(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Finds the first link in @queue which contains @data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// data to find
        /// </param>
        /// <returns>
        /// the first link in @queue which contains @data
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.List<GISharp.Core.IWrappedNative> Find(
            System.IntPtr data)
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Finds an element in a #GQueue, using a supplied function to find the
        /// desired element. It iterates over the queue, calling the given function
        /// which should return 0 when the desired element is found. The function
        /// takes two gconstpointer arguments, the #GQueue element's data as the
        /// first argument and the given user data as the second argument.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// user data passed to @func
        /// </param>
        /// <param name="func">
        /// a #GCompareFunc to call for each element. It should return 0
        ///     when the desired element is found
        /// </param>
        /// <returns>
        /// the found link, or %NULL if it wasn't found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_find_custom(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative func);

        /// <summary>
        /// Finds an element in a #GQueue, using a supplied function to find the
        /// desired element. It iterates over the queue, calling the given function
        /// which should return 0 when the desired element is found. The function
        /// takes two gconstpointer arguments, the #GQueue element's data as the
        /// first argument and the given user data as the second argument.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// user data passed to @func
        /// </param>
        /// <param name="func">
        /// a #GCompareFunc to call for each element. It should return 0
        ///     when the desired element is found
        /// </param>
        /// <returns>
        /// the found link, or %NULL if it wasn't found
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.List<GISharp.Core.IWrappedNative> FindCustom(
            System.IntPtr data,
            GISharp.Core.CompareFuncNative func)
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Calls @func for each element in the queue passing @user_data to the
        /// function.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="func">
        /// the function to call for each element's data
        /// </param>
        /// <param name="userData">
        /// user data to pass to @func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_foreach(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] GISharp.Core.FuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls @func for each element in the queue passing @user_data to the
        /// function.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="func">
        /// the function to call for each element's data
        /// </param>
        /// <param name="userData">
        /// user data to pass to @func
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void Foreach(
            GISharp.Core.FuncNative func)
        {
        }

        /// <summary>
        /// Frees the memory allocated for the #GQueue. Only call this function
        /// if @queue was created with g_queue_new(). If queue elements contain
        /// dynamically-allocated memory, they should be freed first.
        /// </summary>
        /// <remarks>
        /// If queue elements contain dynamically-allocated memory, you should
        /// either use g_queue_free_full() or free them manually first.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_queue_free(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Frees the memory allocated for the #GQueue. Only call this function
        /// if @queue was created with g_queue_new(). If queue elements contain
        /// dynamically-allocated memory, they should be freed first.
        /// </summary>
        /// <remarks>
        /// If queue elements contain dynamically-allocated memory, you should
        /// either use g_queue_free_full() or free them manually first.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        protected override void Free()
        {
        }

        /// <summary>
        /// Convenience method, which frees all the memory used by a #GQueue,
        /// and calls the specified destroy function on every element's data.
        /// </summary>
        /// <param name="queue">
        /// a pointer to a #GQueue
        /// </param>
        /// <param name="freeFunc">
        /// the function to be called to free each element's data
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern void g_queue_free_full(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify freeFunc);

        /// <summary>
        /// Convenience method, which frees all the memory used by a #GQueue,
        /// and calls the specified destroy function on every element's data.
        /// </summary>
        /// <param name="queue">
        /// a pointer to a #GQueue
        /// </param>
        /// <param name="freeFunc">
        /// the function to be called to free each element's data
        /// </param>
        [GISharp.Core.Since("2.32")]
        public void FreeFull(
            GISharp.GLib.DestroyNotify freeFunc)
        {
        }

        /// <summary>
        /// Returns the number of items in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the number of items in @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.UInt32 g_queue_get_length(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Returns the position of the first element in @queue which contains @data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the position of the first element in @queue which
        ///     contains @data, or -1 if no element in @queue contains @data
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.Int32 g_queue_index(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Returns the position of the first element in @queue which contains @data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the position of the first element in @queue which
        ///     contains @data, or -1 if no element in @queue contains @data
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.Int32 Index(
            System.IntPtr data)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// A statically-allocated #GQueue must be initialized with this function
        /// before it can be used. Alternatively you can initialize it with
        /// #G_QUEUE_INIT. It is not necessary to initialize queues created with
        /// g_queue_new().
        /// </summary>
        /// <param name="queue">
        /// an uninitialized #GQueue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_queue_init(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// A statically-allocated #GQueue must be initialized with this function
        /// before it can be used. Alternatively you can initialize it with
        /// #G_QUEUE_INIT. It is not necessary to initialize queues created with
        /// g_queue_new().
        /// </summary>
        /// <param name="queue">
        /// an uninitialized #GQueue
        /// </param>
        [GISharp.Core.Since("2.14")]
        public void Init()
        {
        }

        /// <summary>
        /// Inserts @data into @queue after @sibling
        /// </summary>
        /// <remarks>
        /// @sibling must be part of @queue
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="sibling">
        /// a #GList link that must be part of @queue
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_insert_after(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr sibling,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Inserts @data into @queue after @sibling
        /// </summary>
        /// <remarks>
        /// @sibling must be part of @queue
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="sibling">
        /// a #GList link that must be part of @queue
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void InsertAfter(
            GISharp.Core.List<GISharp.Core.IWrappedNative> sibling,
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Inserts @data into @queue before @sibling.
        /// </summary>
        /// <remarks>
        /// @sibling must be part of @queue.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="sibling">
        /// a #GList link that must be part of @queue
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_insert_before(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr sibling,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Inserts @data into @queue before @sibling.
        /// </summary>
        /// <remarks>
        /// @sibling must be part of @queue.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="sibling">
        /// a #GList link that must be part of @queue
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void InsertBefore(
            GISharp.Core.List<GISharp.Core.IWrappedNative> sibling,
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Inserts @data into @queue using @func to determine the new position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        /// <param name="func">
        /// the #GCompareDataFunc used to compare elements in the queue. It is
        ///     called with two elements of the @queue and @user_data. It should
        ///     return 0 if the elements are equal, a negative value if the first
        ///     element comes before the second, and a positive value if the second
        ///     element comes before the first.
        /// </param>
        /// <param name="userData">
        /// user data passed to @func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_insert_sorted(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Inserts @data into @queue using @func to determine the new position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        /// <param name="func">
        /// the #GCompareDataFunc used to compare elements in the queue. It is
        ///     called with two elements of the @queue and @user_data. It should
        ///     return 0 if the elements are equal, a negative value if the first
        ///     element comes before the second, and a positive value if the second
        ///     element comes before the first.
        /// </param>
        /// <param name="userData">
        /// user data passed to @func
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void InsertSorted(
            System.IntPtr data,
            GISharp.Core.CompareDataFuncNative func)
        {
        }

        /// <summary>
        /// Returns %TRUE if the queue is empty.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue.
        /// </param>
        /// <returns>
        /// %TRUE if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_queue_is_empty(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Returns the position of @link_ in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a #GList link
        /// </param>
        /// <returns>
        /// the position of @link_, or -1 if the link is
        ///     not part of @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.Int32 g_queue_link_index(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Returns the position of @link_ in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a #GList link
        /// </param>
        /// <returns>
        /// the position of @link_, or -1 if the link is
        ///     not part of @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.Int32 LinkIndex(
            GISharp.Core.List<GISharp.Core.IWrappedNative> link)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Returns the first element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the first element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_peek_head(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Returns the first element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the first element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        public System.IntPtr PeekHead()
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Returns the first link in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the first link in @queue, or %NULL if @queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_peek_head_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Returns the first link in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the first link in @queue, or %NULL if @queue is empty
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.List<GISharp.Core.IWrappedNative> PeekHeadLink()
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Returns the @n'th element of @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position of the element
        /// </param>
        /// <returns>
        /// the data for the @n'th element of @queue,
        ///     or %NULL if @n is off the end of @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_peek_nth(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Returns the @n'th element of @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position of the element
        /// </param>
        /// <returns>
        /// the data for the @n'th element of @queue,
        ///     or %NULL if @n is off the end of @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.IntPtr PeekNth(
            System.UInt32 n)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Returns the link at the given position
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position of the link
        /// </param>
        /// <returns>
        /// the link at the @n'th position, or %NULL
        ///     if @n is off the end of the list
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_peek_nth_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Returns the link at the given position
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position of the link
        /// </param>
        /// <returns>
        /// the link at the @n'th position, or %NULL
        ///     if @n is off the end of the list
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.List<GISharp.Core.IWrappedNative> PeekNthLink(
            System.UInt32 n)
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Returns the last element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the last element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_peek_tail(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Returns the last element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the last element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        public System.IntPtr PeekTail()
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Returns the last link in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the last link in @queue, or %NULL if @queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_peek_tail_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Returns the last link in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the last link in @queue, or %NULL if @queue is empty
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.List<GISharp.Core.IWrappedNative> PeekTailLink()
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes the first element of the queue and returns its data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the first element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_pop_head(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Removes the first element of the queue and returns its data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the first element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        public System.IntPtr PopHead()
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Removes and returns the first element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the #GList element at the head of the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_pop_head_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Removes and returns the first element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the #GList element at the head of the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        public GISharp.Core.List<GISharp.Core.IWrappedNative> PopHeadLink()
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes the @n'th element of @queue and returns its data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position of the element
        /// </param>
        /// <returns>
        /// the element's data, or %NULL if @n is off the end of @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_pop_nth(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Removes the @n'th element of @queue and returns its data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position of the element
        /// </param>
        /// <returns>
        /// the element's data, or %NULL if @n is off the end of @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.IntPtr PopNth(
            System.UInt32 n)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Removes and returns the link at the given position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the link's position
        /// </param>
        /// <returns>
        /// the @n'th link, or %NULL if @n is off the end of @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.IntPtr g_queue_pop_nth_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Removes and returns the link at the given position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the link's position
        /// </param>
        /// <returns>
        /// the @n'th link, or %NULL if @n is off the end of @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public GISharp.Core.List<GISharp.Core.IWrappedNative> PopNthLink(
            System.UInt32 n)
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes the last element of the queue and returns its data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the last element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_pop_tail(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Removes the last element of the queue and returns its data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the data of the last element in the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        public System.IntPtr PopTail()
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Removes and returns the last element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the #GList element at the tail of the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_queue_pop_tail_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Removes and returns the last element of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <returns>
        /// the #GList element at the tail of the queue, or %NULL
        ///     if the queue is empty
        /// </returns>
        public GISharp.Core.List<GISharp.Core.IWrappedNative> PopTailLink()
        {
            return default(GISharp.Core.List<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Adds a new element at the head of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue.
        /// </param>
        /// <param name="data">
        /// the data for the new element.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_queue_push_head(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a new element at the head of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue.
        /// </param>
        /// <param name="data">
        /// the data for the new element.
        /// </param>
        public void PushHead(
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Adds a new element at the head of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a single #GList element, not a list with more than one element
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_queue_push_head_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Adds a new element at the head of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a single #GList element, not a list with more than one element
        /// </param>
        public void PushHeadLink(
            GISharp.Core.List<GISharp.Core.IWrappedNative> link)
        {
        }

        /// <summary>
        /// Inserts a new element into @queue at the given position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="n">
        /// the position to insert the new element. If @n is negative or
        ///     larger than the number of elements in the @queue, the element is
        ///     added to the end of the queue.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_push_nth(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] System.Int32 n);

        /// <summary>
        /// Inserts a new element into @queue at the given position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="n">
        /// the position to insert the new element. If @n is negative or
        ///     larger than the number of elements in the @queue, the element is
        ///     added to the end of the queue.
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void PushNth(
            System.IntPtr data,
            System.Int32 n)
        {
        }

        /// <summary>
        /// Inserts @link into @queue at the given position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position to insert the link. If this is negative or larger than
        ///     the number of elements in @queue, the link is added to the end of
        ///     @queue.
        /// </param>
        /// <param name="link">
        /// the link to add to @queue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_push_nth_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.Int32 n,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Inserts @link into @queue at the given position.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="n">
        /// the position to insert the link. If this is negative or larger than
        ///     the number of elements in @queue, the link is added to the end of
        ///     @queue.
        /// </param>
        /// <param name="link">
        /// the link to add to @queue
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void PushNthLink(
            System.Int32 n,
            GISharp.Core.List<GISharp.Core.IWrappedNative> link)
        {
        }

        /// <summary>
        /// Adds a new element at the tail of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_queue_push_tail(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a new element at the tail of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        public void PushTail(
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Adds a new element at the tail of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a single #GList element, not a list with more than one element
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_queue_push_tail_link(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Adds a new element at the tail of the queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a single #GList element, not a list with more than one element
        /// </param>
        public void PushTailLink(
            GISharp.Core.List<GISharp.Core.IWrappedNative> link)
        {
        }

        /// <summary>
        /// Removes the first element in @queue that contains @data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to remove
        /// </param>
        /// <returns>
        /// %TRUE if @data was found and removed from @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.Boolean g_queue_remove(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Removes the first element in @queue that contains @data.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to remove
        /// </param>
        /// <returns>
        /// %TRUE if @data was found and removed from @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.Boolean Remove(
            System.IntPtr data)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Remove all elements whose data equals @data from @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to remove
        /// </param>
        /// <returns>
        /// the number of elements removed from @queue
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern System.UInt32 g_queue_remove_all(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Remove all elements whose data equals @data from @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="data">
        /// the data to remove
        /// </param>
        /// <returns>
        /// the number of elements removed from @queue
        /// </returns>
        [GISharp.Core.Since("2.4")]
        public System.UInt32 RemoveAll(
            System.IntPtr data)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Reverses the order of the items in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_reverse(
            [System.Runtime.InteropServices.In()] System.IntPtr queue);

        /// <summary>
        /// Reverses the order of the items in @queue.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void Reverse()
        {
        }

        /// <summary>
        /// Sorts @queue using @compare_func.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="compareFunc">
        /// the #GCompareDataFunc used to sort @queue. This function
        ///     is passed two elements of the queue and should return 0 if they are
        ///     equal, a negative value if the first comes before the second, and
        ///     a positive value if the second comes before the first.
        /// </param>
        /// <param name="userData">
        /// user data passed to @compare_func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_sort(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative compareFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Sorts @queue using @compare_func.
        /// </summary>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="compareFunc">
        /// the #GCompareDataFunc used to sort @queue. This function
        ///     is passed two elements of the queue and should return 0 if they are
        ///     equal, a negative value if the first comes before the second, and
        ///     a positive value if the second comes before the first.
        /// </param>
        /// <param name="userData">
        /// user data passed to @compare_func
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void Sort(
            GISharp.Core.CompareDataFuncNative compareFunc)
        {
        }

        /// <summary>
        /// Unlinks @link_ so that it will no longer be part of @queue.
        /// The link is not freed.
        /// </summary>
        /// <remarks>
        /// @link_ must be part of @queue.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a #GList link that must be part of @queue
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.4")]
        static extern void g_queue_unlink(
            [System.Runtime.InteropServices.In()] System.IntPtr queue,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Unlinks @link_ so that it will no longer be part of @queue.
        /// The link is not freed.
        /// </summary>
        /// <remarks>
        /// @link_ must be part of @queue.
        /// </remarks>
        /// <param name="queue">
        /// a #GQueue
        /// </param>
        /// <param name="link">
        /// a #GList link that must be part of @queue
        /// </param>
        [GISharp.Core.Since("2.4")]
        public void Unlink(
            GISharp.Core.List<GISharp.Core.IWrappedNative> link)
        {
        }
    }

    /// <summary>
    /// The #GSList struct is used for each element in the singly-linked
    /// list.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"SList\" c:type=\"GSList\" gs:managed-name=\"SList\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The #GSList struct is used for each element in the singly-linked\nlist.</doc>\n  <function name=\"alloc\" c:identifier=\"g_slist_alloc\" introspectable=\"0\" gs:managed-name=\"Alloc\">\n    <doc xml:space=\"preserve\">Allocates space for one #GSList element. It is called by the\ng_slist_append(), g_slist_prepend(), g_slist_insert() and\ng_slist_insert_sorted() functions and so is rarely used on its own.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a pointer to the newly-allocated #GSList element.</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n  </function>\n  <method name=\"append\" c:identifier=\"g_slist_append\" introspectable=\"0\" gs:managed-name=\"Append\">\n    <doc xml:space=\"preserve\">Adds a new element on to the end of the list.\n\nThe return value is the new start of the list, which may\nhave changed, so make sure you store the new value.\n\nNote that g_slist_append() has to traverse the entire list\nto find the end, which is inefficient when adding multiple\nelements. A common idiom to avoid the inefficiency is to prepend\nthe elements and reverse the list when all elements have been added.\n\n|[&lt;!-- language=\"C\" --&gt;\n// Notice that these are initialized to the empty list.\nGSList *list = NULL, *number_list = NULL;\n\n// This is a list of strings.\nlist = g_slist_append (list, \"first\");\nlist = g_slist_append (list, \"second\");\n\n// This is a list of integers.\nnumber_list = g_slist_append (number_list, GINT_TO_POINTER (27));\nnumber_list = g_slist_append (number_list, GINT_TO_POINTER (14));\n]|</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <function name=\"concat\" c:identifier=\"g_slist_concat\" introspectable=\"0\" gs:managed-name=\"Concat\">\n    <doc xml:space=\"preserve\">Adds the second #GSList onto the end of the first #GSList.\nNote that the elements of the second #GSList are not copied.\nThey are used directly.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the start of the new #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <parameter name=\"list1\" transfer-ownership=\"none\" gs:managed-name=\"list1\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"list2\" transfer-ownership=\"none\" gs:managed-name=\"list2\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GSList to add to the end of the first #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"list1\" transfer-ownership=\"none\" gs:managed-name=\"list1\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"list2\" transfer-ownership=\"none\" gs:managed-name=\"list2\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GSList to add to the end of the first #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <method name=\"copy\" c:identifier=\"g_slist_copy\" introspectable=\"0\" gs:managed-name=\"Copy\" gs:special-func=\"copy\">\n    <doc xml:space=\"preserve\">Copies a #GSList.\n\nNote that this is a \"shallow\" copy. If the list elements\nconsist of pointers to data, the pointers are copied but\nthe actual data isn't. See g_slist_copy_deep() if you need\nto copy the data as well.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a copy of @list</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"copy_deep\" c:identifier=\"g_slist_copy_deep\" version=\"2.34\" introspectable=\"0\" gs:managed-name=\"CopyDeep\">\n    <doc xml:space=\"preserve\">Makes a full (deep) copy of a #GSList.\n\nIn contrast with g_slist_copy(), this function uses @func to make a copy of\neach list element, in addition to copying the list container itself.\n\n@func, as a #GCopyFunc, takes two arguments, the data to be copied and a user\npointer. It's safe to pass #NULL as user_data, if the copy function takes only\none argument.\n\nFor instance, if @list holds a list of GObjects, you can do:\n|[&lt;!-- language=\"C\" --&gt;\nanother_list = g_slist_copy_deep (list, (GCopyFunc) g_object_ref, NULL);\n]|\n\nAnd, to entirely free the new list, you could do:\n|[&lt;!-- language=\"C\" --&gt;\ng_slist_free_full (another_list, g_object_unref);\n]|</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a full copy of @list, use #g_slist_free_full to free it</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"CopyFunc\" gs:unmanaged-type=\"CopyFuncNative\">\n        <doc xml:space=\"preserve\">a copy function used to copy every element in the list</doc>\n        <type name=\"CopyFunc\" c:type=\"GCopyFunc\" gs:managed-name=\"CopyFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to the copy function @func, or #NULL</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"CopyFunc\" gs:unmanaged-type=\"CopyFuncNative\">\n        <doc xml:space=\"preserve\">a copy function used to copy every element in the list</doc>\n        <type name=\"CopyFunc\" c:type=\"GCopyFunc\" gs:managed-name=\"CopyFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to the copy function @func, or #NULL</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"delete_link\" c:identifier=\"g_slist_delete_link\" introspectable=\"0\" gs:managed-name=\"DeleteLink\">\n    <doc xml:space=\"preserve\">Removes the node link_ from the list and frees it.\nCompare this to g_slist_remove_link() which removes the node\nwithout freeing it.\n\nRemoving arbitrary nodes from a singly-linked list requires time\nthat is proportional to the length of the list (ie. O(n)). If you\nfind yourself using g_slist_delete_link() frequently, you should\nconsider a different data structure, such as the doubly-linked\n#GList.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new head of @list</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">node to delete</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">node to delete</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find\" c:identifier=\"g_slist_find\" introspectable=\"0\" gs:managed-name=\"Find\">\n    <doc xml:space=\"preserve\">Finds the element in a #GSList which\ncontains the given data.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the found #GSList element,\n    or %NULL if it is not found</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the element data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the element data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find_custom\" c:identifier=\"g_slist_find_custom\" introspectable=\"0\" gs:managed-name=\"FindCustom\">\n    <doc xml:space=\"preserve\">Finds an element in a #GSList, using a supplied function to\nfind the desired element. It iterates over the list, calling\nthe given function which should return 0 when the desired\nelement is found. The function takes two #gconstpointer arguments,\nthe #GSList element's data as the first argument and the\ngiven user data.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the found #GSList element, or %NULL if it is not found</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to the function</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each element.\n    It should return 0 when the desired element is found</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to the function</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each element.\n    It should return 0 when the desired element is found</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"foreach\" c:identifier=\"g_slist_foreach\" introspectable=\"0\" gs:managed-name=\"Foreach\">\n    <doc xml:space=\"preserve\">Calls a function for each element of a #GSList.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call with each element's data</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call with each element's data</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free\" c:identifier=\"g_slist_free\" introspectable=\"0\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees all of the memory used by a #GSList.\nThe freed elements are returned to the slice allocator.\n\nIf list elements contain dynamically-allocated memory,\nyou should either use g_slist_free_full() or free them manually\nfirst.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free_1\" c:identifier=\"g_slist_free_1\" introspectable=\"0\" gs:managed-name=\"Free1\">\n    <doc xml:space=\"preserve\">Frees one #GSList element.\nIt is usually used after g_slist_remove_link().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList element</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free_full\" c:identifier=\"g_slist_free_full\" version=\"2.28\" introspectable=\"0\" gs:managed-name=\"FreeFull\">\n    <doc xml:space=\"preserve\">Convenience method, which frees all the memory used by a #GSList, and\ncalls the specified destroy function on every element's data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"free_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"freeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">the function to be called to free each element's data</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"free_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"freeFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">the function to be called to free each element's data</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"index\" c:identifier=\"g_slist_index\" introspectable=\"0\" gs:managed-name=\"Index\">\n    <doc xml:space=\"preserve\">Gets the position of the element containing\nthe given data (starting from 0).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the index of the element containing the data,\n    or -1 if the data is not found</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to find</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert\" c:identifier=\"g_slist_insert\" introspectable=\"0\" gs:managed-name=\"Insert\">\n    <doc xml:space=\"preserve\">Inserts a new element into the list at the given position.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"position\" transfer-ownership=\"none\" gs:managed-name=\"position\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to insert the element.\n    If this is negative, or is larger than the number\n    of elements in the list, the new element is added on\n    to the end of the list.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"position\" transfer-ownership=\"none\" gs:managed-name=\"position\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the position to insert the element.\n    If this is negative, or is larger than the number\n    of elements in the list, the new element is added on\n    to the end of the list.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_before\" c:identifier=\"g_slist_insert_before\" introspectable=\"0\" gs:managed-name=\"InsertBefore\">\n    <doc xml:space=\"preserve\">Inserts a node before @sibling containing @data.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new head of the list.</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">node to insert @data before</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to put in the newly-inserted node</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"sibling\" transfer-ownership=\"none\" gs:managed-name=\"sibling\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">node to insert @data before</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to put in the newly-inserted node</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_sorted\" c:identifier=\"g_slist_insert_sorted\" introspectable=\"0\" gs:managed-name=\"InsertSorted\">\n    <doc xml:space=\"preserve\">Inserts a new element into the list, using the given\ncomparison function to determine its position.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the function to compare elements in the list.\n    It should return a number &gt; 0 if the first parameter\n    comes after the second parameter in the sort order.</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" gs:managed-name=\"func\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the function to compare elements in the list.\n    It should return a number &gt; 0 if the first parameter\n    comes after the second parameter in the sort order.</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_sorted_with_data\" c:identifier=\"g_slist_insert_sorted_with_data\" version=\"2.10\" introspectable=\"0\" gs:managed-name=\"InsertSortedWithData\">\n    <doc xml:space=\"preserve\">Inserts a new element into the list, using the given\ncomparison function to determine its position.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"func\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function to compare elements in the list.\n    It should return a number &gt; 0 if the first parameter\n    comes after the second parameter in the sort order.</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to comparison function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"func\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function to compare elements in the list.\n    It should return a number &gt; 0 if the first parameter\n    comes after the second parameter in the sort order.</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to comparison function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"last\" c:identifier=\"g_slist_last\" introspectable=\"0\" gs:managed-name=\"Last\">\n    <doc xml:space=\"preserve\">Gets the last element in a #GSList.\n\nThis function iterates over the whole list.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the last element in the #GSList,\n    or %NULL if the #GSList has no elements</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"length\" c:identifier=\"g_slist_length\" introspectable=\"0\" gs:managed-name=\"Length\">\n    <doc xml:space=\"preserve\">Gets the number of elements in a #GSList.\n\nThis function iterates over the whole list to\ncount its elements.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the number of elements in the #GSList</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"nth\" c:identifier=\"g_slist_nth\" introspectable=\"0\" gs:managed-name=\"Nth\">\n    <doc xml:space=\"preserve\">Gets the element at the given position in a #GSList.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the element, or %NULL if the position is off\n    the end of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element, counting from 0</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element, counting from 0</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"nth_data\" c:identifier=\"g_slist_nth_data\" introspectable=\"0\" gs:managed-name=\"NthData\">\n    <doc xml:space=\"preserve\">Gets the data of the element at the given position.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the element's data, or %NULL if the position\n    is off the end of the #GSList</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"n\" transfer-ownership=\"none\" gs:managed-name=\"n\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the position of the element</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"position\" c:identifier=\"g_slist_position\" introspectable=\"0\" gs:managed-name=\"Position\">\n    <doc xml:space=\"preserve\">Gets the position of the given element\nin the #GSList (starting from 0).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the position of the element in the #GSList,\n    or -1 if the element is not found</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"llink\" transfer-ownership=\"none\" gs:managed-name=\"llink\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an element in the #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"llink\" transfer-ownership=\"none\" gs:managed-name=\"llink\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an element in the #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"prepend\" c:identifier=\"g_slist_prepend\" introspectable=\"0\" gs:managed-name=\"Prepend\">\n    <doc xml:space=\"preserve\">Adds a new element on to the start of the list.\n\nThe return value is the new start of the list, which\nmay have changed, so make sure you store the new value.\n\n|[&lt;!-- language=\"C\" --&gt;\n// Notice that it is initialized to the empty list.\nGSList *list = NULL;\nlist = g_slist_prepend (list, \"last\");\nlist = g_slist_prepend (list, \"first\");\n]|</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new element</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove\" c:identifier=\"g_slist_remove\" introspectable=\"0\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes an element from a #GSList.\nIf two elements contain the same data, only the first is removed.\nIf none of the elements contain the data, the #GSList is unchanged.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data of the element to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data of the element to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_all\" c:identifier=\"g_slist_remove_all\" introspectable=\"0\" gs:managed-name=\"RemoveAll\">\n    <doc xml:space=\"preserve\">Removes all list nodes with data equal to @data.\nReturns the new head of the list. Contrast with\ng_slist_remove() which removes only the first node\nmatching the given data.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">new head of @list</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_link\" c:identifier=\"g_slist_remove_link\" introspectable=\"0\" gs:managed-name=\"RemoveLink\">\n    <doc xml:space=\"preserve\">Removes an element from a #GSList, without\nfreeing the element. The removed element's next\nlink is set to %NULL, so that it becomes a\nself-contained list with one element.\n\nRemoving arbitrary nodes from a singly-linked list\nrequires time that is proportional to the length of the list\n(ie. O(n)). If you find yourself using g_slist_remove_link()\nfrequently, you should consider a different data structure,\nsuch as the doubly-linked #GList.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the new start of the #GSList, without the element</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an element in the #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"link_\" transfer-ownership=\"none\" gs:managed-name=\"link\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an element in the #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"reverse\" c:identifier=\"g_slist_reverse\" introspectable=\"0\" gs:managed-name=\"Reverse\">\n    <doc xml:space=\"preserve\">Reverses a #GSList.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the start of the reversed #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"sort\" c:identifier=\"g_slist_sort\" introspectable=\"0\" gs:managed-name=\"Sort\">\n    <doc xml:space=\"preserve\">Sorts a #GSList using the given comparison function.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the start of the sorted #GSList</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the comparison function used to sort the #GSList.\n    This function is passed the data from 2 elements of the #GSList\n    and should return 0 if they are equal, a negative value if the\n    first element comes before the second, or a positive value if\n    the first element comes after the second.</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the comparison function used to sort the #GSList.\n    This function is passed the data from 2 elements of the #GSList\n    and should return 0 if they are equal, a negative value if the\n    first element comes before the second, or a positive value if\n    the first element comes after the second.</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"sort_with_data\" c:identifier=\"g_slist_sort_with_data\" introspectable=\"0\" gs:managed-name=\"SortWithData\">\n    <doc xml:space=\"preserve\">Like g_slist_sort(), but the sort function accepts a user data argument.</doc>\n    <return-value gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">new head of the list</doc>\n      <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </type>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"list\" transfer-ownership=\"none\" gs:managed-name=\"list\" gs:managed-type=\"GLib.SList`1[System.IntPtr]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSList</doc>\n        <type name=\"GLib.SList\" c:type=\"GSList*\" gs:managed-name=\"GLib.SList\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </type>\n      </instance-parameter>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to comparison function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"compare_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"compareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to comparison function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n</record>")]
    public partial class SList : GISharp.Core.OwnedOpaque<GISharp.GLib.SList>
    {
        public SList(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Allocates space for one #GSList element. It is called by the
        /// g_slist_append(), g_slist_prepend(), g_slist_insert() and
        /// g_slist_insert_sorted() functions and so is rarely used on its own.
        /// </summary>
        /// <returns>
        /// a pointer to the newly-allocated #GSList element.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_alloc();

        /// <summary>
        /// Allocates space for one #GSList element. It is called by the
        /// g_slist_append(), g_slist_prepend(), g_slist_insert() and
        /// g_slist_insert_sorted() functions and so is rarely used on its own.
        /// </summary>
        /// <returns>
        /// a pointer to the newly-allocated #GSList element.
        /// </returns>
        public static GISharp.Core.SList<GISharp.Core.IWrappedNative> Alloc()
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Adds the second #GSList onto the end of the first #GSList.
        /// Note that the elements of the second #GSList are not copied.
        /// They are used directly.
        /// </summary>
        /// <param name="list1">
        /// a #GSList
        /// </param>
        /// <param name="list2">
        /// the #GSList to add to the end of the first #GSList
        /// </param>
        /// <returns>
        /// the start of the new #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_concat(
            [System.Runtime.InteropServices.In()] System.IntPtr list1,
            [System.Runtime.InteropServices.In()] System.IntPtr list2);

        /// <summary>
        /// Adds the second #GSList onto the end of the first #GSList.
        /// Note that the elements of the second #GSList are not copied.
        /// They are used directly.
        /// </summary>
        /// <param name="list1">
        /// a #GSList
        /// </param>
        /// <param name="list2">
        /// the #GSList to add to the end of the first #GSList
        /// </param>
        /// <returns>
        /// the start of the new #GSList
        /// </returns>
        public static GISharp.Core.SList<GISharp.Core.IWrappedNative> Concat(
            GISharp.Core.SList<GISharp.Core.IWrappedNative> list1,
            GISharp.Core.SList<GISharp.Core.IWrappedNative> list2)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Adds a new element on to the end of the list.
        /// </summary>
        /// <remarks>
        /// The return value is the new start of the list, which may
        /// have changed, so make sure you store the new value.
        /// 
        /// Note that g_slist_append() has to traverse the entire list
        /// to find the end, which is inefficient when adding multiple
        /// elements. A common idiom to avoid the inefficiency is to prepend
        /// the elements and reverse the list when all elements have been added.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// // Notice that these are initialized to the empty list.
        /// GSList *list = NULL, *number_list = NULL;
        /// 
        /// // This is a list of strings.
        /// list = g_slist_append (list, "first");
        /// list = g_slist_append (list, "second");
        /// 
        /// // This is a list of integers.
        /// number_list = g_slist_append (number_list, GINT_TO_POINTER (27));
        /// number_list = g_slist_append (number_list, GINT_TO_POINTER (14));
        /// ]|
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_append(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a new element on to the end of the list.
        /// </summary>
        /// <remarks>
        /// The return value is the new start of the list, which may
        /// have changed, so make sure you store the new value.
        /// 
        /// Note that g_slist_append() has to traverse the entire list
        /// to find the end, which is inefficient when adding multiple
        /// elements. A common idiom to avoid the inefficiency is to prepend
        /// the elements and reverse the list when all elements have been added.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// // Notice that these are initialized to the empty list.
        /// GSList *list = NULL, *number_list = NULL;
        /// 
        /// // This is a list of strings.
        /// list = g_slist_append (list, "first");
        /// list = g_slist_append (list, "second");
        /// 
        /// // This is a list of integers.
        /// number_list = g_slist_append (number_list, GINT_TO_POINTER (27));
        /// number_list = g_slist_append (number_list, GINT_TO_POINTER (14));
        /// ]|
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Append(
            System.IntPtr data)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Copies a #GSList.
        /// </summary>
        /// <remarks>
        /// Note that this is a "shallow" copy. If the list elements
        /// consist of pointers to data, the pointers are copied but
        /// the actual data isn't. See g_slist_copy_deep() if you need
        /// to copy the data as well.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// a copy of @list
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_copy(
            [System.Runtime.InteropServices.In()] System.IntPtr list);

        /// <summary>
        /// Copies a #GSList.
        /// </summary>
        /// <remarks>
        /// Note that this is a "shallow" copy. If the list elements
        /// consist of pointers to data, the pointers are copied but
        /// the actual data isn't. See g_slist_copy_deep() if you need
        /// to copy the data as well.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// a copy of @list
        /// </returns>
        public override GISharp.Core.SList<GISharp.Core.IWrappedNative> Copy()
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Makes a full (deep) copy of a #GSList.
        /// </summary>
        /// <remarks>
        /// In contrast with g_slist_copy(), this function uses @func to make a copy of
        /// each list element, in addition to copying the list container itself.
        /// 
        /// @func, as a #GCopyFunc, takes two arguments, the data to be copied and a user
        /// pointer. It's safe to pass #NULL as user_data, if the copy function takes only
        /// one argument.
        /// 
        /// For instance, if @list holds a list of GObjects, you can do:
        /// |[&lt;!-- language="C" --&gt;
        /// another_list = g_slist_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
        /// ]|
        /// 
        /// And, to entirely free the new list, you could do:
        /// |[&lt;!-- language="C" --&gt;
        /// g_slist_free_full (another_list, g_object_unref);
        /// ]|
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="func">
        /// a copy function used to copy every element in the list
        /// </param>
        /// <param name="userData">
        /// user data passed to the copy function @func, or #NULL
        /// </param>
        /// <returns>
        /// a full copy of @list, use #g_slist_free_full to free it
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.34")]
        static extern System.IntPtr g_slist_copy_deep(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] GISharp.Core.CopyFuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Makes a full (deep) copy of a #GSList.
        /// </summary>
        /// <remarks>
        /// In contrast with g_slist_copy(), this function uses @func to make a copy of
        /// each list element, in addition to copying the list container itself.
        /// 
        /// @func, as a #GCopyFunc, takes two arguments, the data to be copied and a user
        /// pointer. It's safe to pass #NULL as user_data, if the copy function takes only
        /// one argument.
        /// 
        /// For instance, if @list holds a list of GObjects, you can do:
        /// |[&lt;!-- language="C" --&gt;
        /// another_list = g_slist_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
        /// ]|
        /// 
        /// And, to entirely free the new list, you could do:
        /// |[&lt;!-- language="C" --&gt;
        /// g_slist_free_full (another_list, g_object_unref);
        /// ]|
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="func">
        /// a copy function used to copy every element in the list
        /// </param>
        /// <param name="userData">
        /// user data passed to the copy function @func, or #NULL
        /// </param>
        /// <returns>
        /// a full copy of @list, use #g_slist_free_full to free it
        /// </returns>
        [GISharp.Core.Since("2.34")]
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> CopyDeep(
            GISharp.Core.CopyFuncNative func,
            System.IntPtr userData)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes the node link_ from the list and frees it.
        /// Compare this to g_slist_remove_link() which removes the node
        /// without freeing it.
        /// </summary>
        /// <remarks>
        /// Removing arbitrary nodes from a singly-linked list requires time
        /// that is proportional to the length of the list (ie. O(n)). If you
        /// find yourself using g_slist_delete_link() frequently, you should
        /// consider a different data structure, such as the doubly-linked
        /// #GList.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="link">
        /// node to delete
        /// </param>
        /// <returns>
        /// the new head of @list
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_delete_link(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Removes the node link_ from the list and frees it.
        /// Compare this to g_slist_remove_link() which removes the node
        /// without freeing it.
        /// </summary>
        /// <remarks>
        /// Removing arbitrary nodes from a singly-linked list requires time
        /// that is proportional to the length of the list (ie. O(n)). If you
        /// find yourself using g_slist_delete_link() frequently, you should
        /// consider a different data structure, such as the doubly-linked
        /// #GList.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="link">
        /// node to delete
        /// </param>
        /// <returns>
        /// the new head of @list
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> DeleteLink(
            GISharp.Core.SList<GISharp.Core.IWrappedNative> link)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Finds the element in a #GSList which
        /// contains the given data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the element data to find
        /// </param>
        /// <returns>
        /// the found #GSList element,
        ///     or %NULL if it is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_find(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Finds the element in a #GSList which
        /// contains the given data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the element data to find
        /// </param>
        /// <returns>
        /// the found #GSList element,
        ///     or %NULL if it is not found
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Find(
            System.IntPtr data)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Finds an element in a #GSList, using a supplied function to
        /// find the desired element. It iterates over the list, calling
        /// the given function which should return 0 when the desired
        /// element is found. The function takes two #gconstpointer arguments,
        /// the #GSList element's data as the first argument and the
        /// given user data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// user data passed to the function
        /// </param>
        /// <param name="func">
        /// the function to call for each element.
        ///     It should return 0 when the desired element is found
        /// </param>
        /// <returns>
        /// the found #GSList element, or %NULL if it is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_find_custom(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative func);

        /// <summary>
        /// Finds an element in a #GSList, using a supplied function to
        /// find the desired element. It iterates over the list, calling
        /// the given function which should return 0 when the desired
        /// element is found. The function takes two #gconstpointer arguments,
        /// the #GSList element's data as the first argument and the
        /// given user data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// user data passed to the function
        /// </param>
        /// <param name="func">
        /// the function to call for each element.
        ///     It should return 0 when the desired element is found
        /// </param>
        /// <returns>
        /// the found #GSList element, or %NULL if it is not found
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> FindCustom(
            System.IntPtr data,
            GISharp.Core.CompareFuncNative func)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Calls a function for each element of a #GSList.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="func">
        /// the function to call with each element's data
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_slist_foreach(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] GISharp.Core.FuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls a function for each element of a #GSList.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="func">
        /// the function to call with each element's data
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        public void Foreach(
            GISharp.Core.FuncNative func,
            System.IntPtr userData)
        {
        }

        /// <summary>
        /// Frees all of the memory used by a #GSList.
        /// The freed elements are returned to the slice allocator.
        /// </summary>
        /// <remarks>
        /// If list elements contain dynamically-allocated memory,
        /// you should either use g_slist_free_full() or free them manually
        /// first.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_slist_free(
            [System.Runtime.InteropServices.In()] System.IntPtr list);

        /// <summary>
        /// Frees all of the memory used by a #GSList.
        /// The freed elements are returned to the slice allocator.
        /// </summary>
        /// <remarks>
        /// If list elements contain dynamically-allocated memory,
        /// you should either use g_slist_free_full() or free them manually
        /// first.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        protected override void Free()
        {
        }

        /// <summary>
        /// Frees one #GSList element.
        /// It is usually used after g_slist_remove_link().
        /// </summary>
        /// <param name="list">
        /// a #GSList element
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_slist_free_1(
            [System.Runtime.InteropServices.In()] System.IntPtr list);

        /// <summary>
        /// Frees one #GSList element.
        /// It is usually used after g_slist_remove_link().
        /// </summary>
        /// <param name="list">
        /// a #GSList element
        /// </param>
        public void Free1()
        {
        }

        /// <summary>
        /// Convenience method, which frees all the memory used by a #GSList, and
        /// calls the specified destroy function on every element's data.
        /// </summary>
        /// <param name="list">
        /// a pointer to a #GSList
        /// </param>
        /// <param name="freeFunc">
        /// the function to be called to free each element's data
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern void g_slist_free_full(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify freeFunc);

        /// <summary>
        /// Convenience method, which frees all the memory used by a #GSList, and
        /// calls the specified destroy function on every element's data.
        /// </summary>
        /// <param name="list">
        /// a pointer to a #GSList
        /// </param>
        /// <param name="freeFunc">
        /// the function to be called to free each element's data
        /// </param>
        [GISharp.Core.Since("2.28")]
        public void FreeFull(
            GISharp.GLib.DestroyNotify freeFunc)
        {
        }

        /// <summary>
        /// Gets the position of the element containing
        /// the given data (starting from 0).
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the index of the element containing the data,
        ///     or -1 if the data is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_slist_index(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Gets the position of the element containing
        /// the given data (starting from 0).
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data to find
        /// </param>
        /// <returns>
        /// the index of the element containing the data,
        ///     or -1 if the data is not found
        /// </returns>
        public System.Int32 Index(
            System.IntPtr data)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Inserts a new element into the list at the given position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="position">
        /// the position to insert the element.
        ///     If this is negative, or is larger than the number
        ///     of elements in the list, the new element is added on
        ///     to the end of the list.
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_insert(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] System.Int32 position);

        /// <summary>
        /// Inserts a new element into the list at the given position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="position">
        /// the position to insert the element.
        ///     If this is negative, or is larger than the number
        ///     of elements in the list, the new element is added on
        ///     to the end of the list.
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Insert(
            System.IntPtr data,
            System.Int32 position)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Inserts a node before @sibling containing @data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="sibling">
        /// node to insert @data before
        /// </param>
        /// <param name="data">
        /// data to put in the newly-inserted node
        /// </param>
        /// <returns>
        /// the new head of the list.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_insert_before(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr sibling,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Inserts a node before @sibling containing @data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="sibling">
        /// node to insert @data before
        /// </param>
        /// <param name="data">
        /// data to put in the newly-inserted node
        /// </param>
        /// <returns>
        /// the new head of the list.
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> InsertBefore(
            GISharp.Core.SList<GISharp.Core.IWrappedNative> sibling,
            System.IntPtr data)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Inserts a new element into the list, using the given
        /// comparison function to determine its position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="func">
        /// the function to compare elements in the list.
        ///     It should return a number &gt; 0 if the first parameter
        ///     comes after the second parameter in the sort order.
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_insert_sorted(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative func);

        /// <summary>
        /// Inserts a new element into the list, using the given
        /// comparison function to determine its position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="func">
        /// the function to compare elements in the list.
        ///     It should return a number &gt; 0 if the first parameter
        ///     comes after the second parameter in the sort order.
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> InsertSorted(
            System.IntPtr data,
            GISharp.Core.CompareFuncNative func)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Inserts a new element into the list, using the given
        /// comparison function to determine its position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="func">
        /// the function to compare elements in the list.
        ///     It should return a number &gt; 0 if the first parameter
        ///     comes after the second parameter in the sort order.
        /// </param>
        /// <param name="userData">
        /// data to pass to comparison function
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.10")]
        static extern System.IntPtr g_slist_insert_sorted_with_data(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Inserts a new element into the list, using the given
        /// comparison function to determine its position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <param name="func">
        /// the function to compare elements in the list.
        ///     It should return a number &gt; 0 if the first parameter
        ///     comes after the second parameter in the sort order.
        /// </param>
        /// <param name="userData">
        /// data to pass to comparison function
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [GISharp.Core.Since("2.10")]
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> InsertSortedWithData(
            System.IntPtr data,
            GISharp.Core.CompareDataFuncNative func,
            System.IntPtr userData)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Gets the last element in a #GSList.
        /// </summary>
        /// <remarks>
        /// This function iterates over the whole list.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// the last element in the #GSList,
        ///     or %NULL if the #GSList has no elements
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_last(
            [System.Runtime.InteropServices.In()] System.IntPtr list);

        /// <summary>
        /// Gets the last element in a #GSList.
        /// </summary>
        /// <remarks>
        /// This function iterates over the whole list.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// the last element in the #GSList,
        ///     or %NULL if the #GSList has no elements
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Last()
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Gets the number of elements in a #GSList.
        /// </summary>
        /// <remarks>
        /// This function iterates over the whole list to
        /// count its elements.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// the number of elements in the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_slist_length(
            [System.Runtime.InteropServices.In()] System.IntPtr list);

        /// <summary>
        /// Gets the number of elements in a #GSList.
        /// </summary>
        /// <remarks>
        /// This function iterates over the whole list to
        /// count its elements.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// the number of elements in the #GSList
        /// </returns>
        public System.UInt32 Length()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Gets the element at the given position in a #GSList.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="n">
        /// the position of the element, counting from 0
        /// </param>
        /// <returns>
        /// the element, or %NULL if the position is off
        ///     the end of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_nth(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Gets the element at the given position in a #GSList.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="n">
        /// the position of the element, counting from 0
        /// </param>
        /// <returns>
        /// the element, or %NULL if the position is off
        ///     the end of the #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Nth(
            System.UInt32 n)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Gets the data of the element at the given position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="n">
        /// the position of the element
        /// </param>
        /// <returns>
        /// the element's data, or %NULL if the position
        ///     is off the end of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_nth_data(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.UInt32 n);

        /// <summary>
        /// Gets the data of the element at the given position.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="n">
        /// the position of the element
        /// </param>
        /// <returns>
        /// the element's data, or %NULL if the position
        ///     is off the end of the #GSList
        /// </returns>
        public System.IntPtr NthData(
            System.UInt32 n)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Gets the position of the given element
        /// in the #GSList (starting from 0).
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="llink">
        /// an element in the #GSList
        /// </param>
        /// <returns>
        /// the position of the element in the #GSList,
        ///     or -1 if the element is not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_slist_position(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr llink);

        /// <summary>
        /// Gets the position of the given element
        /// in the #GSList (starting from 0).
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="llink">
        /// an element in the #GSList
        /// </param>
        /// <returns>
        /// the position of the element in the #GSList,
        ///     or -1 if the element is not found
        /// </returns>
        public System.Int32 Position(
            GISharp.Core.SList<GISharp.Core.IWrappedNative> llink)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Adds a new element on to the start of the list.
        /// </summary>
        /// <remarks>
        /// The return value is the new start of the list, which
        /// may have changed, so make sure you store the new value.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// // Notice that it is initialized to the empty list.
        /// GSList *list = NULL;
        /// list = g_slist_prepend (list, "last");
        /// list = g_slist_prepend (list, "first");
        /// ]|
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_prepend(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a new element on to the start of the list.
        /// </summary>
        /// <remarks>
        /// The return value is the new start of the list, which
        /// may have changed, so make sure you store the new value.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// // Notice that it is initialized to the empty list.
        /// GSList *list = NULL;
        /// list = g_slist_prepend (list, "last");
        /// list = g_slist_prepend (list, "first");
        /// ]|
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data for the new element
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Prepend(
            System.IntPtr data)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes an element from a #GSList.
        /// If two elements contain the same data, only the first is removed.
        /// If none of the elements contain the data, the #GSList is unchanged.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data of the element to remove
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_remove(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Removes an element from a #GSList.
        /// If two elements contain the same data, only the first is removed.
        /// If none of the elements contain the data, the #GSList is unchanged.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// the data of the element to remove
        /// </param>
        /// <returns>
        /// the new start of the #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Remove(
            System.IntPtr data)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes all list nodes with data equal to @data.
        /// Returns the new head of the list. Contrast with
        /// g_slist_remove() which removes only the first node
        /// matching the given data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// data to remove
        /// </param>
        /// <returns>
        /// new head of @list
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_remove_all(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Removes all list nodes with data equal to @data.
        /// Returns the new head of the list. Contrast with
        /// g_slist_remove() which removes only the first node
        /// matching the given data.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="data">
        /// data to remove
        /// </param>
        /// <returns>
        /// new head of @list
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> RemoveAll(
            System.IntPtr data)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Removes an element from a #GSList, without
        /// freeing the element. The removed element's next
        /// link is set to %NULL, so that it becomes a
        /// self-contained list with one element.
        /// </summary>
        /// <remarks>
        /// Removing arbitrary nodes from a singly-linked list
        /// requires time that is proportional to the length of the list
        /// (ie. O(n)). If you find yourself using g_slist_remove_link()
        /// frequently, you should consider a different data structure,
        /// such as the doubly-linked #GList.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="link">
        /// an element in the #GSList
        /// </param>
        /// <returns>
        /// the new start of the #GSList, without the element
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_remove_link(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] System.IntPtr link);

        /// <summary>
        /// Removes an element from a #GSList, without
        /// freeing the element. The removed element's next
        /// link is set to %NULL, so that it becomes a
        /// self-contained list with one element.
        /// </summary>
        /// <remarks>
        /// Removing arbitrary nodes from a singly-linked list
        /// requires time that is proportional to the length of the list
        /// (ie. O(n)). If you find yourself using g_slist_remove_link()
        /// frequently, you should consider a different data structure,
        /// such as the doubly-linked #GList.
        /// </remarks>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="link">
        /// an element in the #GSList
        /// </param>
        /// <returns>
        /// the new start of the #GSList, without the element
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> RemoveLink(
            GISharp.Core.SList<GISharp.Core.IWrappedNative> link)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Reverses a #GSList.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// the start of the reversed #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_reverse(
            [System.Runtime.InteropServices.In()] System.IntPtr list);

        /// <summary>
        /// Reverses a #GSList.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <returns>
        /// the start of the reversed #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Reverse()
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Sorts a #GSList using the given comparison function.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="compareFunc">
        /// the comparison function used to sort the #GSList.
        ///     This function is passed the data from 2 elements of the #GSList
        ///     and should return 0 if they are equal, a negative value if the
        ///     first element comes before the second, or a positive value if
        ///     the first element comes after the second.
        /// </param>
        /// <returns>
        /// the start of the sorted #GSList
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_sort(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative compareFunc);

        /// <summary>
        /// Sorts a #GSList using the given comparison function.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="compareFunc">
        /// the comparison function used to sort the #GSList.
        ///     This function is passed the data from 2 elements of the #GSList
        ///     and should return 0 if they are equal, a negative value if the
        ///     first element comes before the second, or a positive value if
        ///     the first element comes after the second.
        /// </param>
        /// <returns>
        /// the start of the sorted #GSList
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> Sort(
            GISharp.Core.CompareFuncNative compareFunc)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }

        /// <summary>
        /// Like g_slist_sort(), but the sort function accepts a user data argument.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to comparison function
        /// </param>
        /// <returns>
        /// new head of the list
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_slist_sort_with_data(
            [System.Runtime.InteropServices.In()] System.IntPtr list,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative compareFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Like g_slist_sort(), but the sort function accepts a user data argument.
        /// </summary>
        /// <param name="list">
        /// a #GSList
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to comparison function
        /// </param>
        /// <returns>
        /// new head of the list
        /// </returns>
        public GISharp.Core.SList<GISharp.Core.IWrappedNative> SortWithData(
            GISharp.Core.CompareDataFuncNative compareFunc,
            System.IntPtr userData)
        {
            return default(GISharp.Core.SList<GISharp.Core.IWrappedNative>);
        }
    }

    /// <summary>
    /// An enumeration specifying the base position for a
    /// g_io_channel_seek_position() operation.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"SeekType\" c:type=\"GSeekType\" gs:managed-name=\"SeekType\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">An enumeration specifying the base position for a\ng_io_channel_seek_position() operation.</doc>\n  <member name=\"cur\" value=\"0\" c:identifier=\"G_SEEK_CUR\" gs:managed-name=\"Cur\">\n    <doc xml:space=\"preserve\">the current position in the file.</doc>\n  </member>\n  <member name=\"set\" value=\"1\" c:identifier=\"G_SEEK_SET\" gs:managed-name=\"Set\">\n    <doc xml:space=\"preserve\">the start of the file.</doc>\n  </member>\n  <member name=\"end\" value=\"2\" c:identifier=\"G_SEEK_END\" gs:managed-name=\"End\">\n    <doc xml:space=\"preserve\">the end of the file.</doc>\n  </member>\n</enumeration>")]
    public enum SeekType
    {
        /// <summary>
        /// the current position in the file.
        /// </summary>
        Cur = 0,
        /// <summary>
        /// the start of the file.
        /// </summary>
        Set = 1,
        /// <summary>
        /// the end of the file.
        /// </summary>
        End = 2
    }

    /// <summary>
    /// The #GSequence struct is an opaque data type representing a
    /// [sequence][glib-Sequences] data type.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Sequence\" c:type=\"GSequence\" disguised=\"1\" gs:managed-name=\"Sequence\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The #GSequence struct is an opaque data type representing a\n[sequence][glib-Sequences] data type.</doc>\n  <method name=\"append\" c:identifier=\"g_sequence_append\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Append\">\n    <doc xml:space=\"preserve\">Adds a new item to the end of @seq.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an iterator pointing to the new item</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"foreach\" c:identifier=\"g_sequence_foreach\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Foreach\">\n    <doc xml:space=\"preserve\">Calls @func for each item in the sequence passing @user_data\nto the function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each item in @seq</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each item in @seq</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"free\" c:identifier=\"g_sequence_free\" version=\"2.14\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees the memory allocated for @seq. If @seq has a data destroy\nfunction associated with it, that function is called on all items\nin @seq.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_begin_iter\" c:identifier=\"g_sequence_get_begin_iter\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"get_BeginIter\" gs:property=\"BeginIter\">\n    <doc xml:space=\"preserve\">Returns the begin iterator for @seq.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the begin iterator for @seq.</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_end_iter\" c:identifier=\"g_sequence_get_end_iter\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"get_EndIter\" gs:property=\"EndIter\">\n    <doc xml:space=\"preserve\">Returns the end iterator for @seg</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the end iterator for @seq</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_iter_at_pos\" c:identifier=\"g_sequence_get_iter_at_pos\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"GetIterAtPos\">\n    <doc xml:space=\"preserve\">Returns the iterator at position @pos. If @pos is negative or larger\nthan the number of items in @seq, the end iterator is returned.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">The #GSequenceIter at position @pos</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"pos\" transfer-ownership=\"none\" gs:managed-name=\"pos\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">a position in @seq, or -1 for the end</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"pos\" transfer-ownership=\"none\" gs:managed-name=\"pos\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">a position in @seq, or -1 for the end</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_length\" c:identifier=\"g_sequence_get_length\" version=\"2.14\" gs:managed-name=\"get_Length\" gs:property=\"Length\">\n    <doc xml:space=\"preserve\">Returns the length of @seq</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the length of @seq</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"insert_sorted\" c:identifier=\"g_sequence_insert_sorted\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"InsertSorted\">\n    <doc xml:space=\"preserve\">Inserts @data into @sequence using @func to determine the new\nposition. The sequence must already be sorted according to @cmp_func;\notherwise the new position of @data is undefined.\n\n@cmp_func is called with two items of the @seq and @user_data.\nIt should return 0 if the items are equal, a negative value\nif the first item comes before the second, and a positive value\nif the second  item comes before the first.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter pointing to the new item.</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_sorted_iter\" c:identifier=\"g_sequence_insert_sorted_iter\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"InsertSortedIter\">\n    <doc xml:space=\"preserve\">Like g_sequence_insert_sorted(), but uses\na #GSequenceIterCompareFunc instead of a #GCompareDataFunc as\nthe compare function.\n\n@iter_cmp is called with two iterators pointing into @seq.\nIt should return 0 if the iterators are equal, a negative\nvalue if the first iterator comes before the second, and a\npositive value if the second iterator comes before the first.\n\nIt is called with two iterators pointing into @seq. It should\nreturn 0 if the iterators are equal, a negative value if the\nfirst iterator comes before the second, and a positive value\nif the second iterator comes before the first.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter pointing to the new item</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"lookup\" c:identifier=\"g_sequence_lookup\" version=\"2.28\" introspectable=\"0\" gs:managed-name=\"Lookup\">\n    <doc xml:space=\"preserve\">Returns an iterator pointing to the position of the first item found\nequal to @data according to @cmp_func and @cmp_data. If more than one\nitem is equal, it is not guaranteed that it is the first which is\nreturned. In that case, you can use g_sequence_iter_next() and\ng_sequence_iter_prev() to get others.\n\n@cmp_func is called with two items of the @seq and @user_data.\nIt should return 0 if the items are equal, a negative value if\nthe first item comes before the second, and a positive value if\nthe second item comes before the first.\n\nThis function will fail if the data contained in the sequence is\nunsorted.  Use g_sequence_insert_sorted() or\ng_sequence_insert_sorted_iter() to add data to your sequence or, if\nyou want to add a large amount of data, call g_sequence_sort() after\ndoing unsorted insertions.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an #GSequenceIter pointing to the position of the\n    first item found equal to @data according to @cmp_func and\n    @cmp_data, or %NULL if no such item exists</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to lookup</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to lookup</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"lookup_iter\" c:identifier=\"g_sequence_lookup_iter\" version=\"2.28\" introspectable=\"0\" gs:managed-name=\"LookupIter\">\n    <doc xml:space=\"preserve\">Like g_sequence_lookup(), but uses a #GSequenceIterCompareFunc\ninstead of a #GCompareDataFunc as the compare function.\n\n@iter_cmp is called with two iterators pointing into @seq.\nIt should return 0 if the iterators are equal, a negative value\nif the first iterator comes before the second, and a positive\nvalue if the second iterator comes before the first.\n\nThis function will fail if the data contained in the sequence is\nunsorted.  Use g_sequence_insert_sorted() or\ng_sequence_insert_sorted_iter() to add data to your sequence or, if\nyou want to add a large amount of data, call g_sequence_sort() after\ndoing unsorted insertions.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an #GSequenceIter pointing to the position of\n    the first item found equal to @data according to @cmp_func\n    and @cmp_data, or %NULL if no such item exists</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to lookup</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @iter_cmp</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to lookup</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"prepend\" c:identifier=\"g_sequence_prepend\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Prepend\">\n    <doc xml:space=\"preserve\">Adds a new item to the front of @seq</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an iterator pointing to the new item</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"search\" c:identifier=\"g_sequence_search\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Search\">\n    <doc xml:space=\"preserve\">Returns an iterator pointing to the position where @data would\nbe inserted according to @cmp_func and @cmp_data.\n\n@cmp_func is called with two items of the @seq and @user_data.\nIt should return 0 if the items are equal, a negative value if\nthe first item comes before the second, and a positive value if\nthe second item comes before the first.\n\nIf you are simply searching for an existing element of the sequence,\nconsider using g_sequence_lookup().\n\nThis function will fail if the data contained in the sequence is\nunsorted.  Use g_sequence_insert_sorted() or\ng_sequence_insert_sorted_iter() to add data to your sequence or, if\nyou want to add a large amount of data, call g_sequence_sort() after\ndoing unsorted insertions.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an #GSequenceIter pointing to the position where @data\n    would have been inserted according to @cmp_func and @cmp_data</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"search_iter\" c:identifier=\"g_sequence_search_iter\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"SearchIter\">\n    <doc xml:space=\"preserve\">Like g_sequence_search(), but uses a #GSequenceIterCompareFunc\ninstead of a #GCompareDataFunc as the compare function.\n\n@iter_cmp is called with two iterators pointing into @seq.\nIt should return 0 if the iterators are equal, a negative value\nif the first iterator comes before the second, and a positive\nvalue if the second iterator comes before the first.\n\nIf you are simply searching for an existing element of the sequence,\nconsider using g_sequence_lookup_iter().\n\nThis function will fail if the data contained in the sequence is\nunsorted.  Use g_sequence_insert_sorted() or\ng_sequence_insert_sorted_iter() to add data to your sequence or, if\nyou want to add a large amount of data, call g_sequence_sort() after\ndoing unsorted insertions.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter pointing to the position in @seq\n    where @data would have been inserted according to @iter_cmp\n    and @cmp_data</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @iter_cmp</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"sort\" c:identifier=\"g_sequence_sort\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Sort\">\n    <doc xml:space=\"preserve\">Sorts @seq using @cmp_func.\n\n@cmp_func is passed two items of @seq and should\nreturn 0 if they are equal, a negative value if the\nfirst comes before the second, and a positive value\nif the second comes before the first.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to sort the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to sort the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"sort_iter\" c:identifier=\"g_sequence_sort_iter\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"SortIter\">\n    <doc xml:space=\"preserve\">Like g_sequence_sort(), but uses a #GSequenceIterCompareFunc instead\nof a GCompareDataFunc as the compare function\n\n@cmp_func is called with two iterators pointing into @seq. It should\nreturn 0 if the iterators are equal, a negative value if the first\niterator comes before the second, and a positive value if the second\niterator comes before the first.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"seq\" transfer-ownership=\"none\" gs:managed-name=\"seq\" gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequence</doc>\n        <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n      </instance-parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <function name=\"foreach_range\" c:identifier=\"g_sequence_foreach_range\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"ForeachRange\">\n    <doc xml:space=\"preserve\">Calls @func for each item in the range (@begin, @end) passing\n@user_data to the function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">a #GFunc</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"func\" gs:managed-type=\"Func\" gs:unmanaged-type=\"FuncNative\">\n        <doc xml:space=\"preserve\">a #GFunc</doc>\n        <type name=\"Func\" c:type=\"GFunc\" gs:managed-name=\"Func\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"get\" c:identifier=\"g_sequence_get\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Get\">\n    <doc xml:space=\"preserve\">Returns the data that @iter points to.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the data that @iter points to</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"insert_before\" c:identifier=\"g_sequence_insert_before\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"InsertBefore\">\n    <doc xml:space=\"preserve\">Inserts a new item just before the item pointed to by @iter.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an iterator pointing to the new item</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the new item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"move\" c:identifier=\"g_sequence_move\" version=\"2.14\" gs:managed-name=\"Move\">\n    <doc xml:space=\"preserve\">Moves the item pointed to by @src to the position indicated by @dest.\nAfter calling this function @dest will point to the position immediately\nafter @src. It is allowed for @src and @dest to point into different\nsequences.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"src\" transfer-ownership=\"none\" gs:managed-name=\"src\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter pointing to the item to move</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"dest\" transfer-ownership=\"none\" gs:managed-name=\"dest\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter pointing to the position to which\n    the item is moved</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"src\" transfer-ownership=\"none\" gs:managed-name=\"src\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter pointing to the item to move</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"dest\" transfer-ownership=\"none\" gs:managed-name=\"dest\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter pointing to the position to which\n    the item is moved</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"move_range\" c:identifier=\"g_sequence_move_range\" version=\"2.14\" gs:managed-name=\"MoveRange\">\n    <doc xml:space=\"preserve\">Inserts the (@begin, @end) range at the destination pointed to by ptr.\nThe @begin and @end iters must point into the same sequence. It is\nallowed for @dest to point to a different sequence than the one pointed\ninto by @begin and @end.\n\nIf @dest is NULL, the range indicated by @begin and @end is\nremoved from the sequence. If @dest iter points to a place within\nthe (@begin, @end) range, the range does not move.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"dest\" transfer-ownership=\"none\" gs:managed-name=\"dest\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"dest\" transfer-ownership=\"none\" gs:managed-name=\"dest\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <constructor name=\"new\" c:identifier=\"g_sequence_new\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new GSequence. The @data_destroy function, if non-%NULL will\nbe called on all items when the sequence is destroyed and on items that\nare removed from the sequence.</doc>\n    <return-value gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GSequence</doc>\n      <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"data_destroy\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"dataDestroy\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a #GDestroyNotify function, or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data_destroy\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"dataDestroy\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a #GDestroyNotify function, or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <function name=\"range_get_midpoint\" c:identifier=\"g_sequence_range_get_midpoint\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"RangeGetMidpoint\">\n    <doc xml:space=\"preserve\">Finds an iterator somewhere in the range (@begin, @end). This\niterator will be close to the middle of the range, but is not\nguaranteed to be exactly in the middle.\n\nThe @begin and @end iterators must both point to the same sequence\nand @begin must come before or be equal to @end in the sequence.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter pointing somewhere in the\n   (@begin, @end) range</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"remove\" c:identifier=\"g_sequence_remove\" version=\"2.14\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes the item pointed to by @iter. It is an error to pass the\nend iterator to this function.\n\nIf the sequence has a data destroy function associated with it, this\nfunction is called on the data for the removed item.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"remove_range\" c:identifier=\"g_sequence_remove_range\" version=\"2.14\" gs:managed-name=\"RemoveRange\">\n    <doc xml:space=\"preserve\">Removes all items in the (@begin, @end) range.\n\nIf the sequence has a data destroy function associated with it, this\nfunction is called on the data for the removed items.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"begin\" transfer-ownership=\"none\" gs:managed-name=\"begin\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"end\" transfer-ownership=\"none\" gs:managed-name=\"end\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"set\" c:identifier=\"g_sequence_set\" version=\"2.14\" gs:managed-name=\"Set\">\n    <doc xml:space=\"preserve\">Changes the data for the item pointed to by @iter to be @data. If\nthe sequence has a data destroy function associated with it, that\nfunction is called on the existing data that @iter pointed to.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">new data for the item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">new data for the item</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"sort_changed\" c:identifier=\"g_sequence_sort_changed\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"SortChanged\">\n    <doc xml:space=\"preserve\">Moves the data pointed to a new position as indicated by @cmp_func. This\nfunction should be called for items in a sequence already sorted according\nto @cmp_func whenever some aspect of an item changes so that @cmp_func\nmay return different values for that item.\n\n@cmp_func is called with two items of the @seq and @user_data.\nIt should return 0 if the items are equal, a negative value if\nthe first item comes before the second, and a positive value if\nthe second item comes before the first.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">A #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"cmp_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"cmpFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare items in the sequence</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"sort_changed_iter\" c:identifier=\"g_sequence_sort_changed_iter\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"SortChangedIter\">\n    <doc xml:space=\"preserve\">Like g_sequence_sort_changed(), but uses\na #GSequenceIterCompareFunc instead of a #GCompareDataFunc as\nthe compare function.\n\n@iter_cmp is called with two iterators pointing into @seq. It should\nreturn 0 if the iterators are equal, a negative value if the first\niterator comes before the second, and a positive value if the second\niterator comes before the first.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n      <parameter name=\"cmp_data\" transfer-ownership=\"none\" gs:managed-name=\"cmpData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data passed to @cmp_func</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"iter_cmp\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"iterCmp\" gs:managed-type=\"SequenceIterCompareFunc\" gs:unmanaged-type=\"SequenceIterCompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to compare iterators in the sequence</doc>\n        <type name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"swap\" c:identifier=\"g_sequence_swap\" version=\"2.14\" gs:managed-name=\"Swap\">\n    <doc xml:space=\"preserve\">Swaps the items pointed to by @a and @b. It is allowed for @a and @b\nto point into difference sequences.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n      <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    public partial class Sequence : GISharp.Core.OwnedOpaque<GISharp.GLib.Sequence>
    {
        /// <summary>
        /// Returns the begin iterator for @seq.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <returns>
        /// the begin iterator for @seq.
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter BeginIter
        {
            get
            {
                return default(GISharp.GLib.SequenceIter);
            }
        }

        /// <summary>
        /// Returns the end iterator for @seg
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <returns>
        /// the end iterator for @seq
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter EndIter
        {
            get
            {
                return default(GISharp.GLib.SequenceIter);
            }
        }

        /// <summary>
        /// Returns the length of @seq
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <returns>
        /// the length of @seq
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public System.Int32 Length
        {
            get
            {
                return default(System.Int32);
            }
        }

        public Sequence(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new GSequence. The @data_destroy function, if non-%NULL will
        /// be called on all items when the sequence is destroyed and on items that
        /// are removed from the sequence.
        /// </summary>
        /// <param name="dataDestroy">
        /// a #GDestroyNotify function, or %NULL
        /// </param>
        /// <returns>
        /// a new #GSequence
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public Sequence(
            GISharp.GLib.DestroyNotify dataDestroy) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new GSequence. The @data_destroy function, if non-%NULL will
        /// be called on all items when the sequence is destroyed and on items that
        /// are removed from the sequence.
        /// </summary>
        /// <param name="dataDestroy">
        /// a #GDestroyNotify function, or %NULL
        /// </param>
        /// <returns>
        /// a new #GSequence
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_new(
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify dataDestroy);

        /// <summary>
        /// Calls @func for each item in the range (@begin, @end) passing
        /// @user_data to the function.
        /// </summary>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        /// <param name="func">
        /// a #GFunc
        /// </param>
        /// <param name="userData">
        /// user data passed to @func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_foreach_range(
            [System.Runtime.InteropServices.In()] System.IntPtr begin,
            [System.Runtime.InteropServices.In()] System.IntPtr end,
            [System.Runtime.InteropServices.In()] GISharp.Core.FuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls @func for each item in the range (@begin, @end) passing
        /// @user_data to the function.
        /// </summary>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        /// <param name="func">
        /// a #GFunc
        /// </param>
        /// <param name="userData">
        /// user data passed to @func
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void ForeachRange(
            GISharp.GLib.SequenceIter begin,
            GISharp.GLib.SequenceIter end,
            GISharp.Core.FuncNative func)
        {
        }

        /// <summary>
        /// Returns the data that @iter points to.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// the data that @iter points to
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_get(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns the data that @iter points to.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// the data that @iter points to
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public static System.IntPtr Get(
            GISharp.GLib.SequenceIter iter)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Inserts a new item just before the item pointed to by @iter.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="data">
        /// the data for the new item
        /// </param>
        /// <returns>
        /// an iterator pointing to the new item
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_insert_before(
            [System.Runtime.InteropServices.In()] System.IntPtr iter,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Inserts a new item just before the item pointed to by @iter.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="data">
        /// the data for the new item
        /// </param>
        /// <returns>
        /// an iterator pointing to the new item
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public static GISharp.GLib.SequenceIter InsertBefore(
            GISharp.GLib.SequenceIter iter,
            System.IntPtr data)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Moves the item pointed to by @src to the position indicated by @dest.
        /// After calling this function @dest will point to the position immediately
        /// after @src. It is allowed for @src and @dest to point into different
        /// sequences.
        /// </summary>
        /// <param name="src">
        /// a #GSequenceIter pointing to the item to move
        /// </param>
        /// <param name="dest">
        /// a #GSequenceIter pointing to the position to which
        ///     the item is moved
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_move(
            [System.Runtime.InteropServices.In()] System.IntPtr src,
            [System.Runtime.InteropServices.In()] System.IntPtr dest);

        /// <summary>
        /// Moves the item pointed to by @src to the position indicated by @dest.
        /// After calling this function @dest will point to the position immediately
        /// after @src. It is allowed for @src and @dest to point into different
        /// sequences.
        /// </summary>
        /// <param name="src">
        /// a #GSequenceIter pointing to the item to move
        /// </param>
        /// <param name="dest">
        /// a #GSequenceIter pointing to the position to which
        ///     the item is moved
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void Move(
            GISharp.GLib.SequenceIter src,
            GISharp.GLib.SequenceIter dest)
        {
        }

        /// <summary>
        /// Inserts the (@begin, @end) range at the destination pointed to by ptr.
        /// The @begin and @end iters must point into the same sequence. It is
        /// allowed for @dest to point to a different sequence than the one pointed
        /// into by @begin and @end.
        /// </summary>
        /// <remarks>
        /// If @dest is NULL, the range indicated by @begin and @end is
        /// removed from the sequence. If @dest iter points to a place within
        /// the (@begin, @end) range, the range does not move.
        /// </remarks>
        /// <param name="dest">
        /// a #GSequenceIter
        /// </param>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_move_range(
            [System.Runtime.InteropServices.In()] System.IntPtr dest,
            [System.Runtime.InteropServices.In()] System.IntPtr begin,
            [System.Runtime.InteropServices.In()] System.IntPtr end);

        /// <summary>
        /// Inserts the (@begin, @end) range at the destination pointed to by ptr.
        /// The @begin and @end iters must point into the same sequence. It is
        /// allowed for @dest to point to a different sequence than the one pointed
        /// into by @begin and @end.
        /// </summary>
        /// <remarks>
        /// If @dest is NULL, the range indicated by @begin and @end is
        /// removed from the sequence. If @dest iter points to a place within
        /// the (@begin, @end) range, the range does not move.
        /// </remarks>
        /// <param name="dest">
        /// a #GSequenceIter
        /// </param>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void MoveRange(
            GISharp.GLib.SequenceIter dest,
            GISharp.GLib.SequenceIter begin,
            GISharp.GLib.SequenceIter end)
        {
        }

        /// <summary>
        /// Finds an iterator somewhere in the range (@begin, @end). This
        /// iterator will be close to the middle of the range, but is not
        /// guaranteed to be exactly in the middle.
        /// </summary>
        /// <remarks>
        /// The @begin and @end iterators must both point to the same sequence
        /// and @begin must come before or be equal to @end in the sequence.
        /// </remarks>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing somewhere in the
        ///    (@begin, @end) range
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_range_get_midpoint(
            [System.Runtime.InteropServices.In()] System.IntPtr begin,
            [System.Runtime.InteropServices.In()] System.IntPtr end);

        /// <summary>
        /// Finds an iterator somewhere in the range (@begin, @end). This
        /// iterator will be close to the middle of the range, but is not
        /// guaranteed to be exactly in the middle.
        /// </summary>
        /// <remarks>
        /// The @begin and @end iterators must both point to the same sequence
        /// and @begin must come before or be equal to @end in the sequence.
        /// </remarks>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing somewhere in the
        ///    (@begin, @end) range
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public static GISharp.GLib.SequenceIter RangeGetMidpoint(
            GISharp.GLib.SequenceIter begin,
            GISharp.GLib.SequenceIter end)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Removes the item pointed to by @iter. It is an error to pass the
        /// end iterator to this function.
        /// </summary>
        /// <remarks>
        /// If the sequence has a data destroy function associated with it, this
        /// function is called on the data for the removed item.
        /// </remarks>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_remove(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Removes the item pointed to by @iter. It is an error to pass the
        /// end iterator to this function.
        /// </summary>
        /// <remarks>
        /// If the sequence has a data destroy function associated with it, this
        /// function is called on the data for the removed item.
        /// </remarks>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void Remove(
            GISharp.GLib.SequenceIter iter)
        {
        }

        /// <summary>
        /// Removes all items in the (@begin, @end) range.
        /// </summary>
        /// <remarks>
        /// If the sequence has a data destroy function associated with it, this
        /// function is called on the data for the removed items.
        /// </remarks>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_remove_range(
            [System.Runtime.InteropServices.In()] System.IntPtr begin,
            [System.Runtime.InteropServices.In()] System.IntPtr end);

        /// <summary>
        /// Removes all items in the (@begin, @end) range.
        /// </summary>
        /// <remarks>
        /// If the sequence has a data destroy function associated with it, this
        /// function is called on the data for the removed items.
        /// </remarks>
        /// <param name="begin">
        /// a #GSequenceIter
        /// </param>
        /// <param name="end">
        /// a #GSequenceIter
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void RemoveRange(
            GISharp.GLib.SequenceIter begin,
            GISharp.GLib.SequenceIter end)
        {
        }

        /// <summary>
        /// Changes the data for the item pointed to by @iter to be @data. If
        /// the sequence has a data destroy function associated with it, that
        /// function is called on the existing data that @iter pointed to.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="data">
        /// new data for the item
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_set(
            [System.Runtime.InteropServices.In()] System.IntPtr iter,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Changes the data for the item pointed to by @iter to be @data. If
        /// the sequence has a data destroy function associated with it, that
        /// function is called on the existing data that @iter pointed to.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="data">
        /// new data for the item
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void Set(
            GISharp.GLib.SequenceIter iter,
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Moves the data pointed to a new position as indicated by @cmp_func. This
        /// function should be called for items in a sequence already sorted according
        /// to @cmp_func whenever some aspect of an item changes so that @cmp_func
        /// may return different values for that item.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value if
        /// the first item comes before the second, and a positive value if
        /// the second item comes before the first.
        /// </remarks>
        /// <param name="iter">
        /// A #GSequenceIter
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_sort_changed(
            [System.Runtime.InteropServices.In()] System.IntPtr iter,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative cmpFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Moves the data pointed to a new position as indicated by @cmp_func. This
        /// function should be called for items in a sequence already sorted according
        /// to @cmp_func whenever some aspect of an item changes so that @cmp_func
        /// may return different values for that item.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value if
        /// the first item comes before the second, and a positive value if
        /// the second item comes before the first.
        /// </remarks>
        /// <param name="iter">
        /// A #GSequenceIter
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func.
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void SortChanged(
            GISharp.GLib.SequenceIter iter,
            GISharp.Core.CompareDataFuncNative cmpFunc)
        {
        }

        /// <summary>
        /// Like g_sequence_sort_changed(), but uses
        /// a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
        /// the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq. It should
        /// return 0 if the iterators are equal, a negative value if the first
        /// iterator comes before the second, and a positive value if the second
        /// iterator comes before the first.
        /// </remarks>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_sort_changed_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr iter,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SequenceIterCompareFunc iterCmp,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Like g_sequence_sort_changed(), but uses
        /// a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
        /// the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq. It should
        /// return 0 if the iterators are equal, a negative value if the first
        /// iterator comes before the second, and a positive value if the second
        /// iterator comes before the first.
        /// </remarks>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void SortChangedIter(
            GISharp.GLib.SequenceIter iter,
            GISharp.GLib.SequenceIterCompareFunc iterCmp)
        {
        }

        /// <summary>
        /// Swaps the items pointed to by @a and @b. It is allowed for @a and @b
        /// to point into difference sequences.
        /// </summary>
        /// <param name="a">
        /// a #GSequenceIter
        /// </param>
        /// <param name="b">
        /// a #GSequenceIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_swap(
            [System.Runtime.InteropServices.In()] System.IntPtr a,
            [System.Runtime.InteropServices.In()] System.IntPtr b);

        /// <summary>
        /// Swaps the items pointed to by @a and @b. It is allowed for @a and @b
        /// to point into difference sequences.
        /// </summary>
        /// <param name="a">
        /// a #GSequenceIter
        /// </param>
        /// <param name="b">
        /// a #GSequenceIter
        /// </param>
        [GISharp.Core.Since("2.14")]
        public static void Swap(
            GISharp.GLib.SequenceIter a,
            GISharp.GLib.SequenceIter b)
        {
        }

        /// <summary>
        /// Adds a new item to the end of @seq.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// the data for the new item
        /// </param>
        /// <returns>
        /// an iterator pointing to the new item
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_append(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a new item to the end of @seq.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// the data for the new item
        /// </param>
        /// <returns>
        /// an iterator pointing to the new item
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter Append(
            System.IntPtr data)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Calls @func for each item in the sequence passing @user_data
        /// to the function.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="func">
        /// the function to call for each item in @seq
        /// </param>
        /// <param name="userData">
        /// user data passed to @func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_foreach(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] GISharp.Core.FuncNative func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls @func for each item in the sequence passing @user_data
        /// to the function.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="func">
        /// the function to call for each item in @seq
        /// </param>
        /// <param name="userData">
        /// user data passed to @func
        /// </param>
        [GISharp.Core.Since("2.14")]
        public void Foreach(
            GISharp.Core.FuncNative func)
        {
        }

        /// <summary>
        /// Frees the memory allocated for @seq. If @seq has a data destroy
        /// function associated with it, that function is called on all items
        /// in @seq.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_free(
            [System.Runtime.InteropServices.In()] System.IntPtr seq);

        /// <summary>
        /// Frees the memory allocated for @seq. If @seq has a data destroy
        /// function associated with it, that function is called on all items
        /// in @seq.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        [GISharp.Core.Since("2.14")]
        protected override void Free()
        {
        }

        /// <summary>
        /// Returns the begin iterator for @seq.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <returns>
        /// the begin iterator for @seq.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_get_begin_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr seq);

        /// <summary>
        /// Returns the end iterator for @seg
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <returns>
        /// the end iterator for @seq
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_get_end_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr seq);

        /// <summary>
        /// Returns the iterator at position @pos. If @pos is negative or larger
        /// than the number of items in @seq, the end iterator is returned.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="pos">
        /// a position in @seq, or -1 for the end
        /// </param>
        /// <returns>
        /// The #GSequenceIter at position @pos
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_get_iter_at_pos(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.Int32 pos);

        /// <summary>
        /// Returns the iterator at position @pos. If @pos is negative or larger
        /// than the number of items in @seq, the end iterator is returned.
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="pos">
        /// a position in @seq, or -1 for the end
        /// </param>
        /// <returns>
        /// The #GSequenceIter at position @pos
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter GetIterAtPos(
            System.Int32 pos)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Returns the length of @seq
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <returns>
        /// the length of @seq
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.Int32 g_sequence_get_length(
            [System.Runtime.InteropServices.In()] System.IntPtr seq);

        /// <summary>
        /// Inserts @data into @sequence using @func to determine the new
        /// position. The sequence must already be sorted according to @cmp_func;
        /// otherwise the new position of @data is undefined.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value
        /// if the first item comes before the second, and a positive value
        /// if the second  item comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func.
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the new item.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_insert_sorted(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative cmpFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Inserts @data into @sequence using @func to determine the new
        /// position. The sequence must already be sorted according to @cmp_func;
        /// otherwise the new position of @data is undefined.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value
        /// if the first item comes before the second, and a positive value
        /// if the second  item comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// the data to insert
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func.
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the new item.
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter InsertSorted(
            System.IntPtr data,
            GISharp.Core.CompareDataFuncNative cmpFunc)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Like g_sequence_insert_sorted(), but uses
        /// a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
        /// the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq.
        /// It should return 0 if the iterators are equal, a negative
        /// value if the first iterator comes before the second, and a
        /// positive value if the second iterator comes before the first.
        /// 
        /// It is called with two iterators pointing into @seq. It should
        /// return 0 if the iterators are equal, a negative value if the
        /// first iterator comes before the second, and a positive value
        /// if the second iterator comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data for the new item
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the new item
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_insert_sorted_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SequenceIterCompareFunc iterCmp,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Like g_sequence_insert_sorted(), but uses
        /// a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
        /// the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq.
        /// It should return 0 if the iterators are equal, a negative
        /// value if the first iterator comes before the second, and a
        /// positive value if the second iterator comes before the first.
        /// 
        /// It is called with two iterators pointing into @seq. It should
        /// return 0 if the iterators are equal, a negative value if the
        /// first iterator comes before the second, and a positive value
        /// if the second iterator comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data for the new item
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the new item
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter InsertSortedIter(
            System.IntPtr data,
            GISharp.GLib.SequenceIterCompareFunc iterCmp)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Returns an iterator pointing to the position of the first item found
        /// equal to @data according to @cmp_func and @cmp_data. If more than one
        /// item is equal, it is not guaranteed that it is the first which is
        /// returned. In that case, you can use g_sequence_iter_next() and
        /// g_sequence_iter_prev() to get others.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value if
        /// the first item comes before the second, and a positive value if
        /// the second item comes before the first.
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data to lookup
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        /// <returns>
        /// an #GSequenceIter pointing to the position of the
        ///     first item found equal to @data according to @cmp_func and
        ///     @cmp_data, or %NULL if no such item exists
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern System.IntPtr g_sequence_lookup(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative cmpFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Returns an iterator pointing to the position of the first item found
        /// equal to @data according to @cmp_func and @cmp_data. If more than one
        /// item is equal, it is not guaranteed that it is the first which is
        /// returned. In that case, you can use g_sequence_iter_next() and
        /// g_sequence_iter_prev() to get others.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value if
        /// the first item comes before the second, and a positive value if
        /// the second item comes before the first.
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data to lookup
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        /// <returns>
        /// an #GSequenceIter pointing to the position of the
        ///     first item found equal to @data according to @cmp_func and
        ///     @cmp_data, or %NULL if no such item exists
        /// </returns>
        [GISharp.Core.Since("2.28")]
        public GISharp.GLib.SequenceIter Lookup(
            System.IntPtr data,
            GISharp.Core.CompareDataFuncNative cmpFunc)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Like g_sequence_lookup(), but uses a #GSequenceIterCompareFunc
        /// instead of a #GCompareDataFunc as the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq.
        /// It should return 0 if the iterators are equal, a negative value
        /// if the first iterator comes before the second, and a positive
        /// value if the second iterator comes before the first.
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data to lookup
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @iter_cmp
        /// </param>
        /// <returns>
        /// an #GSequenceIter pointing to the position of
        ///     the first item found equal to @data according to @cmp_func
        ///     and @cmp_data, or %NULL if no such item exists
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern System.IntPtr g_sequence_lookup_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SequenceIterCompareFunc iterCmp,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Like g_sequence_lookup(), but uses a #GSequenceIterCompareFunc
        /// instead of a #GCompareDataFunc as the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq.
        /// It should return 0 if the iterators are equal, a negative value
        /// if the first iterator comes before the second, and a positive
        /// value if the second iterator comes before the first.
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data to lookup
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @iter_cmp
        /// </param>
        /// <returns>
        /// an #GSequenceIter pointing to the position of
        ///     the first item found equal to @data according to @cmp_func
        ///     and @cmp_data, or %NULL if no such item exists
        /// </returns>
        [GISharp.Core.Since("2.28")]
        public GISharp.GLib.SequenceIter LookupIter(
            System.IntPtr data,
            GISharp.GLib.SequenceIterCompareFunc iterCmp)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Adds a new item to the front of @seq
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// the data for the new item
        /// </param>
        /// <returns>
        /// an iterator pointing to the new item
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_prepend(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Adds a new item to the front of @seq
        /// </summary>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// the data for the new item
        /// </param>
        /// <returns>
        /// an iterator pointing to the new item
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter Prepend(
            System.IntPtr data)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Returns an iterator pointing to the position where @data would
        /// be inserted according to @cmp_func and @cmp_data.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value if
        /// the first item comes before the second, and a positive value if
        /// the second item comes before the first.
        /// 
        /// If you are simply searching for an existing element of the sequence,
        /// consider using g_sequence_lookup().
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data for the new item
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        /// <returns>
        /// an #GSequenceIter pointing to the position where @data
        ///     would have been inserted according to @cmp_func and @cmp_data
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_search(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative cmpFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Returns an iterator pointing to the position where @data would
        /// be inserted according to @cmp_func and @cmp_data.
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two items of the @seq and @user_data.
        /// It should return 0 if the items are equal, a negative value if
        /// the first item comes before the second, and a positive value if
        /// the second item comes before the first.
        /// 
        /// If you are simply searching for an existing element of the sequence,
        /// consider using g_sequence_lookup().
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data for the new item
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare items in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        /// <returns>
        /// an #GSequenceIter pointing to the position where @data
        ///     would have been inserted according to @cmp_func and @cmp_data
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter Search(
            System.IntPtr data,
            GISharp.Core.CompareDataFuncNative cmpFunc)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Like g_sequence_search(), but uses a #GSequenceIterCompareFunc
        /// instead of a #GCompareDataFunc as the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq.
        /// It should return 0 if the iterators are equal, a negative value
        /// if the first iterator comes before the second, and a positive
        /// value if the second iterator comes before the first.
        /// 
        /// If you are simply searching for an existing element of the sequence,
        /// consider using g_sequence_lookup_iter().
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data for the new item
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @iter_cmp
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the position in @seq
        ///     where @data would have been inserted according to @iter_cmp
        ///     and @cmp_data
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_search_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SequenceIterCompareFunc iterCmp,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Like g_sequence_search(), but uses a #GSequenceIterCompareFunc
        /// instead of a #GCompareDataFunc as the compare function.
        /// </summary>
        /// <remarks>
        /// @iter_cmp is called with two iterators pointing into @seq.
        /// It should return 0 if the iterators are equal, a negative value
        /// if the first iterator comes before the second, and a positive
        /// value if the second iterator comes before the first.
        /// 
        /// If you are simply searching for an existing element of the sequence,
        /// consider using g_sequence_lookup_iter().
        /// 
        /// This function will fail if the data contained in the sequence is
        /// unsorted.  Use g_sequence_insert_sorted() or
        /// g_sequence_insert_sorted_iter() to add data to your sequence or, if
        /// you want to add a large amount of data, call g_sequence_sort() after
        /// doing unsorted insertions.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="data">
        /// data for the new item
        /// </param>
        /// <param name="iterCmp">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @iter_cmp
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the position in @seq
        ///     where @data would have been inserted according to @iter_cmp
        ///     and @cmp_data
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter SearchIter(
            System.IntPtr data,
            GISharp.GLib.SequenceIterCompareFunc iterCmp)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Sorts @seq using @cmp_func.
        /// </summary>
        /// <remarks>
        /// @cmp_func is passed two items of @seq and should
        /// return 0 if they are equal, a negative value if the
        /// first comes before the second, and a positive value
        /// if the second comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to sort the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_sort(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative cmpFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Sorts @seq using @cmp_func.
        /// </summary>
        /// <remarks>
        /// @cmp_func is passed two items of @seq and should
        /// return 0 if they are equal, a negative value if the
        /// first comes before the second, and a positive value
        /// if the second comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to sort the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        [GISharp.Core.Since("2.14")]
        public void Sort(
            GISharp.Core.CompareDataFuncNative cmpFunc)
        {
        }

        /// <summary>
        /// Like g_sequence_sort(), but uses a #GSequenceIterCompareFunc instead
        /// of a GCompareDataFunc as the compare function
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two iterators pointing into @seq. It should
        /// return 0 if the iterators are equal, a negative value if the first
        /// iterator comes before the second, and a positive value if the second
        /// iterator comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern void g_sequence_sort_iter(
            [System.Runtime.InteropServices.In()] System.IntPtr seq,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SequenceIterCompareFunc cmpFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr cmpData);

        /// <summary>
        /// Like g_sequence_sort(), but uses a #GSequenceIterCompareFunc instead
        /// of a GCompareDataFunc as the compare function
        /// </summary>
        /// <remarks>
        /// @cmp_func is called with two iterators pointing into @seq. It should
        /// return 0 if the iterators are equal, a negative value if the first
        /// iterator comes before the second, and a positive value if the second
        /// iterator comes before the first.
        /// </remarks>
        /// <param name="seq">
        /// a #GSequence
        /// </param>
        /// <param name="cmpFunc">
        /// the function used to compare iterators in the sequence
        /// </param>
        /// <param name="cmpData">
        /// user data passed to @cmp_func
        /// </param>
        [GISharp.Core.Since("2.14")]
        public void SortIter(
            GISharp.GLib.SequenceIterCompareFunc cmpFunc)
        {
        }
    }

    /// <summary>
    /// The #GSequenceIter struct is an opaque data type representing an
    /// iterator pointing into a #GSequence.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"SequenceIter\" c:type=\"GSequenceIter\" disguised=\"1\" gs:opaque=\"owned\" gs:managed-name=\"SequenceIter\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The #GSequenceIter struct is an opaque data type representing an\niterator pointing into a #GSequence.</doc>\n  <method name=\"compare\" c:identifier=\"g_sequence_iter_compare\" version=\"2.14\" gs:managed-name=\"CompareTo\" gs:special-func=\"compare\">\n    <doc xml:space=\"preserve\">Returns a negative number if @a comes before @b, 0 if they are equal,\nand a positive number if @a comes after @b.\n\nThe @a and @b iterators must point into the same sequence.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">a negative number if @a comes before @b, 0 if they are\n    equal, and a positive number if @a comes after @b</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n      <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_position\" c:identifier=\"g_sequence_iter_get_position\" version=\"2.14\" gs:managed-name=\"get_Position\" gs:property=\"Position\">\n    <doc xml:space=\"preserve\">Returns the position of @iter</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the position of @iter</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_sequence\" c:identifier=\"g_sequence_iter_get_sequence\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"get_Sequence\" gs:property=\"Sequence\">\n    <doc xml:space=\"preserve\">Returns the #GSequence that @iter points into.</doc>\n    <return-value gs:managed-type=\"Sequence\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GSequence that @iter points into</doc>\n      <type name=\"Sequence\" c:type=\"GSequence*\" gs:managed-name=\"Sequence\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_begin\" c:identifier=\"g_sequence_iter_is_begin\" version=\"2.14\" gs:managed-name=\"get_IsBegin\" gs:property=\"IsBegin\">\n    <doc xml:space=\"preserve\">Returns whether @iter is the begin iterator</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">whether @iter is the begin iterator</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_end\" c:identifier=\"g_sequence_iter_is_end\" version=\"2.14\" gs:managed-name=\"get_IsEnd\" gs:property=\"IsEnd\">\n    <doc xml:space=\"preserve\">Returns whether @iter is the end iterator</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">Whether @iter is the end iterator</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"move\" c:identifier=\"g_sequence_iter_move\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Move\">\n    <doc xml:space=\"preserve\">Returns the #GSequenceIter which is @delta positions away from @iter.\nIf @iter is closer than -@delta positions to the beginning of the sequence,\nthe begin iterator is returned. If @iter is closer than @delta positions\nto the end of the sequence, the end iterator is returned.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter which is @delta positions away from @iter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n      <parameter name=\"delta\" transfer-ownership=\"none\" gs:managed-name=\"delta\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">A positive or negative number indicating how many positions away\n   from @iter the returned #GSequenceIter will be</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"delta\" transfer-ownership=\"none\" gs:managed-name=\"delta\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">A positive or negative number indicating how many positions away\n   from @iter the returned #GSequenceIter will be</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"next\" c:identifier=\"g_sequence_iter_next\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Next\">\n    <doc xml:space=\"preserve\">Returns an iterator pointing to the next position after @iter.\nIf @iter is the end iterator, the end iterator is returned.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter pointing to the next position after @iter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"prev\" c:identifier=\"g_sequence_iter_prev\" version=\"2.14\" introspectable=\"0\" gs:managed-name=\"Prev\">\n    <doc xml:space=\"preserve\">Returns an iterator pointing to the previous position before @iter.\nIf @iter is the begin iterator, the begin iterator is returned.</doc>\n    <return-value gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter pointing to the previous position\n    before @iter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n        <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    public partial class SequenceIter : GISharp.Core.OwnedOpaque<GISharp.GLib.SequenceIter>,
        System.IComparable<GISharp.GLib.SequenceIter>
    {
        /// <summary>
        /// Returns the position of @iter
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// the position of @iter
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public System.Int32 Position
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Returns the #GSequence that @iter points into.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// the #GSequence that @iter points into
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.Sequence Sequence
        {
            get
            {
                return default(GISharp.GLib.Sequence);
            }
        }

        /// <summary>
        /// Returns whether @iter is the begin iterator
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// whether @iter is the begin iterator
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public System.Boolean IsBegin
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Returns whether @iter is the end iterator
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// Whether @iter is the end iterator
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public System.Boolean IsEnd
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public SequenceIter(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Returns a negative number if @a comes before @b, 0 if they are equal,
        /// and a positive number if @a comes after @b.
        /// </summary>
        /// <remarks>
        /// The @a and @b iterators must point into the same sequence.
        /// </remarks>
        /// <param name="a">
        /// a #GSequenceIter
        /// </param>
        /// <param name="b">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a negative number if @a comes before @b, 0 if they are
        ///     equal, and a positive number if @a comes after @b
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.Int32 g_sequence_iter_compare(
            [System.Runtime.InteropServices.In()] System.IntPtr a,
            [System.Runtime.InteropServices.In()] System.IntPtr b);

        /// <summary>
        /// Returns a negative number if @a comes before @b, 0 if they are equal,
        /// and a positive number if @a comes after @b.
        /// </summary>
        /// <remarks>
        /// The @a and @b iterators must point into the same sequence.
        /// </remarks>
        /// <param name="a">
        /// a #GSequenceIter
        /// </param>
        /// <param name="b">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a negative number if @a comes before @b, 0 if they are
        ///     equal, and a positive number if @a comes after @b
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public System.Int32 CompareTo(
            GISharp.GLib.SequenceIter b)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Returns the position of @iter
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// the position of @iter
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.Int32 g_sequence_iter_get_position(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns the #GSequence that @iter points into.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// the #GSequence that @iter points into
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_iter_get_sequence(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns whether @iter is the begin iterator
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// whether @iter is the begin iterator
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.Boolean g_sequence_iter_is_begin(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns whether @iter is the end iterator
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// Whether @iter is the end iterator
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.Boolean g_sequence_iter_is_end(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns the #GSequenceIter which is @delta positions away from @iter.
        /// If @iter is closer than -@delta positions to the beginning of the sequence,
        /// the begin iterator is returned. If @iter is closer than @delta positions
        /// to the end of the sequence, the end iterator is returned.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="delta">
        /// A positive or negative number indicating how many positions away
        ///    from @iter the returned #GSequenceIter will be
        /// </param>
        /// <returns>
        /// a #GSequenceIter which is @delta positions away from @iter
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_iter_move(
            [System.Runtime.InteropServices.In()] System.IntPtr iter,
            [System.Runtime.InteropServices.In()] System.Int32 delta);

        /// <summary>
        /// Returns the #GSequenceIter which is @delta positions away from @iter.
        /// If @iter is closer than -@delta positions to the beginning of the sequence,
        /// the begin iterator is returned. If @iter is closer than @delta positions
        /// to the end of the sequence, the end iterator is returned.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <param name="delta">
        /// A positive or negative number indicating how many positions away
        ///    from @iter the returned #GSequenceIter will be
        /// </param>
        /// <returns>
        /// a #GSequenceIter which is @delta positions away from @iter
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter Move(
            System.Int32 delta)
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Returns an iterator pointing to the next position after @iter.
        /// If @iter is the end iterator, the end iterator is returned.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the next position after @iter
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_iter_next(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns an iterator pointing to the next position after @iter.
        /// If @iter is the end iterator, the end iterator is returned.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the next position after @iter
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter Next()
        {
            return default(GISharp.GLib.SequenceIter);
        }

        /// <summary>
        /// Returns an iterator pointing to the previous position before @iter.
        /// If @iter is the begin iterator, the begin iterator is returned.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the previous position
        ///     before @iter
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_sequence_iter_prev(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Returns an iterator pointing to the previous position before @iter.
        /// If @iter is the begin iterator, the begin iterator is returned.
        /// </summary>
        /// <param name="iter">
        /// a #GSequenceIter
        /// </param>
        /// <returns>
        /// a #GSequenceIter pointing to the previous position
        ///     before @iter
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public GISharp.GLib.SequenceIter Prev()
        {
            return default(GISharp.GLib.SequenceIter);
        }

        public static bool operator <(GISharp.GLib.SequenceIter one, GISharp.GLib.SequenceIter two)
        {
            return one.CompareTo(two) < 0;
        }

        public static bool operator <=(GISharp.GLib.SequenceIter one, GISharp.GLib.SequenceIter two)
        {
            return one.CompareTo(two) <= 0;
        }

        public static bool operator >=(GISharp.GLib.SequenceIter one, GISharp.GLib.SequenceIter two)
        {
            return one.CompareTo(two) >= 0;
        }

        public static bool operator >(GISharp.GLib.SequenceIter one, GISharp.GLib.SequenceIter two)
        {
            return one.CompareTo(two) > 0;
        }
    }

    /// <summary>
    /// A #GSequenceIterCompareFunc is a function used to compare iterators.
    /// It must return zero if the iterators compare equal, a negative value
    /// if @a comes before @b, and a positive value if @b comes before @a.
    /// </summary>
    /// <param name="a">
    /// a #GSequenceIter
    /// </param>
    /// <param name="b">
    /// a #GSequenceIter
    /// </param>
    /// <param name="data">
    /// user data
    /// </param>
    /// <returns>
    /// zero if the iterators are equal, a negative value if @a
    ///     comes before @b, and a positive value if @b comes before @a.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A #GSequenceIterCompareFunc is a function used to compare iterators.\nIt must return zero if the iterators compare equal, a negative value\nif @a comes before @b, and a positive value if @b comes before @a.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <doc xml:space=\"preserve\">zero if the iterators are equal, a negative value if @a\n    comes before @b, and a positive value if @b comes before @a.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.Int32 SequenceIterCompareFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr a,
        [System.Runtime.InteropServices.In()] System.IntPtr b,
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// A #GSequenceIterCompareFunc is a function used to compare iterators.
    /// It must return zero if the iterators compare equal, a negative value
    /// if @a comes before @b, and a positive value if @b comes before @a.
    /// </summary>
    /// <param name="a">
    /// a #GSequenceIter
    /// </param>
    /// <param name="b">
    /// a #GSequenceIter
    /// </param>
    /// <param name="data">
    /// user data
    /// </param>
    /// <returns>
    /// zero if the iterators are equal, a negative value if @a
    ///     comes before @b, and a positive value if @b comes before @a.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"SequenceIterCompareFunc\" c:type=\"GSequenceIterCompareFunc\" gs:managed-name=\"SequenceIterCompareFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A #GSequenceIterCompareFunc is a function used to compare iterators.\nIt must return zero if the iterators compare equal, a negative value\nif @a comes before @b, and a positive value if @b comes before @a.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n    <doc xml:space=\"preserve\">zero if the iterators are equal, a negative value if @a\n    comes before @b, and a positive value if @b comes before @a.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"a\" transfer-ownership=\"none\" gs:managed-name=\"a\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"b\" transfer-ownership=\"none\" gs:managed-name=\"b\" gs:managed-type=\"SequenceIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GSequenceIter</doc>\n      <type name=\"SequenceIter\" c:type=\"GSequenceIter*\" gs:managed-name=\"SequenceIter\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate System.Int32 SequenceIterCompareFunc(
        GISharp.GLib.SequenceIter a,
        GISharp.GLib.SequenceIter b,
        System.IntPtr data);

    /// <summary>
    /// The `GSource` struct is an opaque data type
    /// representing an event source.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Source\" c:type=\"GSource\" glib:type-name=\"GSource\" glib:get-type=\"g_source_get_type\" c:symbol-prefix=\"source\" gs:managed-name=\"Source\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The `GSource` struct is an opaque data type\nrepresenting an event source.</doc>\n  <constructor name=\"new\" c:identifier=\"g_source_new\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GSource structure. The size is specified to\nallow creating structures derived from #GSource that contain\nadditional data. The size passed in must be at least\n`sizeof (GSource)`.\n\nThe source will not initially be associated with any #GMainContext\nand must be added to one with g_source_attach() before it will be\nexecuted.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly-created #GSource.</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"source_funcs\" transfer-ownership=\"none\" gs:managed-name=\"sourceFuncs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">structure containing functions that implement\n               the sources behavior.</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n      <parameter name=\"struct_size\" transfer-ownership=\"none\" gs:managed-name=\"structSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">size of the #GSource structure to create.</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"source_funcs\" transfer-ownership=\"none\" gs:managed-name=\"sourceFuncs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">structure containing functions that implement\n               the sources behavior.</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n      <parameter name=\"struct_size\" transfer-ownership=\"none\" gs:managed-name=\"structSize\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">size of the #GSource structure to create.</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"add_child_source\" c:identifier=\"g_source_add_child_source\" version=\"2.28\" gs:managed-name=\"AddChildSource\">\n    <doc xml:space=\"preserve\">Adds @child_source to @source as a \"polled\" source; when @source is\nadded to a #GMainContext, @child_source will be automatically added\nwith the same priority, when @child_source is triggered, it will\ncause @source to dispatch (in addition to calling its own\ncallback), and when @source is destroyed, it will destroy\n@child_source as well. (@source will also still be dispatched if\nits own prepare/check functions indicate that it is ready.)\n\nIf you don't need @child_source to do anything on its own when it\ntriggers, you can call g_source_set_dummy_callback() on it to set a\ncallback that does nothing (except return %TRUE if appropriate).\n\n@source will hold a reference on @child_source while @child_source\nis attached to it.\n\nThis API is only intended to be used by implementations of #GSource.\nDo not call this API on a #GSource that you did not create.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"child_source\" transfer-ownership=\"none\" gs:managed-name=\"childSource\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a second #GSource that @source should \"poll\"</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"child_source\" transfer-ownership=\"none\" gs:managed-name=\"childSource\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a second #GSource that @source should \"poll\"</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"add_poll\" c:identifier=\"g_source_add_poll\" gs:managed-name=\"AddPoll\">\n    <doc xml:space=\"preserve\">Adds a file descriptor to the set of file descriptors polled for\nthis source. This is usually combined with g_source_new() to add an\nevent source. The event source's check function will typically test\nthe @revents field in the #GPollFD struct and return %TRUE if events need\nto be processed.\n\nThis API is only intended to be used by implementations of #GSource.\nDo not call this API on a #GSource that you did not create.\n\nUsing this API forces the linear scanning of event sources on each\nmain loop iteration.  Newly-written event sources should try to use\ng_source_add_unix_fd() instead of this API.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD structure holding information about a file\n     descriptor to watch.</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD structure holding information about a file\n     descriptor to watch.</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"attach\" c:identifier=\"g_source_attach\" gs:managed-name=\"Attach\">\n    <doc xml:space=\"preserve\">Adds a #GSource to a @context so that it will be executed within\nthat context. Remove it by calling g_source_destroy().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the ID (greater than 0) for the source within the\n  #GMainContext.</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (if %NULL, the default context will be used)</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"context\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"context\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GMainContext (if %NULL, the default context will be used)</doc>\n        <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"destroy\" c:identifier=\"g_source_destroy\" gs:managed-name=\"Destroy\">\n    <doc xml:space=\"preserve\">Removes a source from its #GMainContext, if any, and mark it as\ndestroyed.  The source cannot be subsequently added to another\ncontext. It is safe to call this on sources which have already been\nremoved from their context.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_can_recurse\" c:identifier=\"g_source_get_can_recurse\" gs:managed-name=\"get_CanRecurse\" gs:property=\"CanRecurse\">\n    <doc xml:space=\"preserve\">Checks whether a source is allowed to be called recursively.\nsee g_source_set_can_recurse().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">whether recursion is allowed.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_context\" c:identifier=\"g_source_get_context\" gs:managed-name=\"get_Context\" gs:property=\"Context\">\n    <doc xml:space=\"preserve\">Gets the #GMainContext with which the source is associated.\n\nYou can call this on a source that has been destroyed, provided\nthat the #GMainContext it was attached to still exists (in which\ncase it will return that #GMainContext). In particular, you can\nalways call this function on the source returned from\ng_main_current_source(). But calling this function on a source\nwhose #GMainContext has been destroyed is an error.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"MainContext\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the #GMainContext with which the\n              source is associated, or %NULL if the context has not\n              yet been added to a source.</doc>\n      <type name=\"MainContext\" c:type=\"GMainContext*\" gs:managed-name=\"MainContext\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_current_time\" c:identifier=\"g_source_get_current_time\" deprecated=\"1\" deprecated-version=\"2.28\" gs:managed-name=\"GetCurrentTime\">\n    <doc xml:space=\"preserve\">This function ignores @source and is otherwise the same as\ng_get_current_time().</doc>\n    <doc-deprecated xml:space=\"preserve\">use g_source_get_time() instead</doc-deprecated>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"timeval\" transfer-ownership=\"none\" gs:managed-name=\"timeval\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">#GTimeVal structure in which to store current time.</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"timeval\" transfer-ownership=\"none\" gs:managed-name=\"timeval\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">#GTimeVal structure in which to store current time.</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_id\" c:identifier=\"g_source_get_id\" gs:managed-name=\"get_Id\" gs:property=\"Id\">\n    <doc xml:space=\"preserve\">Returns the numeric ID for a particular source. The ID of a source\nis a positive integer which is unique within a particular main loop\ncontext. The reverse\nmapping from ID to source is done by g_main_context_find_source_by_id().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the ID (greater than 0) for the source</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_name\" c:identifier=\"g_source_get_name\" version=\"2.26\" gs:managed-name=\"get_Name\" gs:property=\"Name\">\n    <doc xml:space=\"preserve\">Gets a name for the source, used in debugging and profiling.  The\nname may be #NULL if it has never been set with g_source_set_name().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the name of the source</doc>\n      <type name=\"utf8\" c:type=\"const char*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_priority\" c:identifier=\"g_source_get_priority\" gs:managed-name=\"get_Priority\" gs:property=\"Priority\">\n    <doc xml:space=\"preserve\">Gets the priority of a source.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the priority of the source</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_ready_time\" c:identifier=\"g_source_get_ready_time\" gs:managed-name=\"get_ReadyTime\" gs:property=\"ReadyTime\">\n    <doc xml:space=\"preserve\">Gets the \"ready time\" of @source, as set by\ng_source_set_ready_time().\n\nAny time before the current monotonic time (including 0) is an\nindication that the source will fire immediately.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n      <doc xml:space=\"preserve\">the monotonic ready time, -1 for \"never\"</doc>\n      <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_time\" c:identifier=\"g_source_get_time\" version=\"2.28\" gs:managed-name=\"get_Time\" gs:property=\"Time\">\n    <doc xml:space=\"preserve\">Gets the time to be used when checking this source. The advantage of\ncalling this function over calling g_get_monotonic_time() directly is\nthat when checking multiple sources, GLib can cache a single value\ninstead of having to repeatedly get the system monotonic time.\n\nThe time here is the system monotonic time, if available, or some\nother reasonable alternative otherwise.  See g_get_monotonic_time().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n      <doc xml:space=\"preserve\">the monotonic time in microseconds</doc>\n      <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_destroyed\" c:identifier=\"g_source_is_destroyed\" version=\"2.12\" gs:managed-name=\"get_IsDestroyed\" gs:property=\"IsDestroyed\">\n    <doc xml:space=\"preserve\">Returns whether @source has been destroyed.\n\nThis is important when you operate upon your objects\nfrom within idle handlers, but may have freed the object\nbefore the dispatch of your idle handler.\n\n|[&lt;!-- language=\"C\" --&gt;\nstatic gboolean\nidle_callback (gpointer data)\n{\n  SomeWidget *self = data;\n   \n  GDK_THREADS_ENTER ();\n  // do stuff with self\n  self-&gt;idle_id = 0;\n  GDK_THREADS_LEAVE ();\n   \n  return G_SOURCE_REMOVE;\n}\n \nstatic void\nsome_widget_do_stuff_later (SomeWidget *self)\n{\n  self-&gt;idle_id = g_idle_add (idle_callback, self);\n}\n \nstatic void\nsome_widget_finalize (GObject *object)\n{\n  SomeWidget *self = SOME_WIDGET (object);\n   \n  if (self-&gt;idle_id)\n    g_source_remove (self-&gt;idle_id);\n   \n  G_OBJECT_CLASS (parent_class)-&gt;finalize (object);\n}\n]|\n\nThis will fail in a multi-threaded application if the\nwidget is destroyed before the idle handler fires due\nto the use after free in the callback. A solution, to\nthis particular problem, is to check to if the source\nhas already been destroy within the callback.\n\n|[&lt;!-- language=\"C\" --&gt;\nstatic gboolean\nidle_callback (gpointer data)\n{\n  SomeWidget *self = data;\n  \n  GDK_THREADS_ENTER ();\n  if (!g_source_is_destroyed (g_main_current_source ()))\n    {\n      // do stuff with self\n    }\n  GDK_THREADS_LEAVE ();\n  \n  return FALSE;\n}\n]|</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the source has been destroyed</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"ref\" c:identifier=\"g_source_ref\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count on a source by one.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">@source</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove_child_source\" c:identifier=\"g_source_remove_child_source\" version=\"2.28\" gs:managed-name=\"RemoveChildSource\">\n    <doc xml:space=\"preserve\">Detaches @child_source from @source and destroys it.\n\nThis API is only intended to be used by implementations of #GSource.\nDo not call this API on a #GSource that you did not create.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"child_source\" transfer-ownership=\"none\" gs:managed-name=\"childSource\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource previously passed to\n    g_source_add_child_source().</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"child_source\" transfer-ownership=\"none\" gs:managed-name=\"childSource\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource previously passed to\n    g_source_add_child_source().</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_poll\" c:identifier=\"g_source_remove_poll\" gs:managed-name=\"RemovePoll\">\n    <doc xml:space=\"preserve\">Removes a file descriptor from the set of file descriptors polled for\nthis source.\n\nThis API is only intended to be used by implementations of #GSource.\nDo not call this API on a #GSource that you did not create.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD structure previously passed to g_source_add_poll().</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"fd\" transfer-ownership=\"none\" gs:managed-name=\"fd\" gs:managed-type=\"PollFD\" gs:unmanaged-type=\"PollFD\">\n        <doc xml:space=\"preserve\">a #GPollFD structure previously passed to g_source_add_poll().</doc>\n        <type name=\"PollFD\" c:type=\"GPollFD*\" gs:managed-name=\"PollFD\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"remove_unix_fd\" c:identifier=\"g_source_remove_unix_fd\" version=\"2.36\" gs:managed-name=\"RemoveUnixFd\">\n    <doc xml:space=\"preserve\">Reverses the effect of a previous call to g_source_add_unix_fd().\n\nYou only need to call this if you want to remove an fd from being\nwatched while keeping the same source around.  In the normal case you\nwill just want to destroy the source.\n\nThis API is only intended to be used by implementations of #GSource.\nDo not call this API on a #GSource that you did not create.\n\nAs the name suggests, this function is not available on Windows.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"tag\" transfer-ownership=\"none\" gs:managed-name=\"tag\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the tag from g_source_add_unix_fd()</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tag\" transfer-ownership=\"none\" gs:managed-name=\"tag\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the tag from g_source_add_unix_fd()</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_callback\" c:identifier=\"g_source_set_callback\" gs:managed-name=\"SetCallback\">\n    <doc xml:space=\"preserve\">Sets the callback function for a source. The callback for a source is\ncalled from the source's dispatch function.\n\nThe exact type of @func depends on the type of source; ie. you\nshould not count on @func being called with @data as its first\nparameter.\n\nTypically, you won't use this function. Instead use functions specific\nto the type of source you are using.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the source</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" scope=\"notified\" closure=\"1\" destroy=\"2\" gs:managed-name=\"func\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">a callback function</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data to pass to callback function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a function to call when @data is no longer in use, or %NULL.</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" scope=\"notified\" closure=\"1\" destroy=\"2\" gs:managed-name=\"func\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">a callback function</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_callback_indirect\" c:identifier=\"g_source_set_callback_indirect\" gs:managed-name=\"SetCallbackIndirect\">\n    <doc xml:space=\"preserve\">Sets the callback function storing the data as a refcounted callback\n\"object\". This is used internally. Note that calling\ng_source_set_callback_indirect() assumes\nan initial reference count on @callback_data, and thus\n@callback_funcs-&gt;unref will eventually be called once more\nthan @callback_funcs-&gt;ref.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the source</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"callback_data\" transfer-ownership=\"none\" gs:managed-name=\"callbackData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">pointer to callback data \"object\"</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"callback_funcs\" transfer-ownership=\"none\" gs:managed-name=\"callbackFuncs\" gs:managed-type=\"SourceCallbackFuncs\" gs:unmanaged-type=\"SourceCallbackFuncs\">\n        <doc xml:space=\"preserve\">functions for reference counting @callback_data\n                 and getting the callback and data</doc>\n        <type name=\"SourceCallbackFuncs\" c:type=\"GSourceCallbackFuncs*\" gs:managed-name=\"SourceCallbackFuncs\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"callback_data\" transfer-ownership=\"none\" gs:managed-name=\"callbackData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">pointer to callback data \"object\"</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"callback_funcs\" transfer-ownership=\"none\" gs:managed-name=\"callbackFuncs\" gs:managed-type=\"SourceCallbackFuncs\" gs:unmanaged-type=\"SourceCallbackFuncs\">\n        <doc xml:space=\"preserve\">functions for reference counting @callback_data\n                 and getting the callback and data</doc>\n        <type name=\"SourceCallbackFuncs\" c:type=\"GSourceCallbackFuncs*\" gs:managed-name=\"SourceCallbackFuncs\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_can_recurse\" c:identifier=\"g_source_set_can_recurse\" gs:managed-name=\"set_CanRecurse\" gs:property=\"CanRecurse\">\n    <doc xml:space=\"preserve\">Sets whether a source can be called recursively. If @can_recurse is\n%TRUE, then while the source is being dispatched then this source\nwill be processed normally. Otherwise, all processing of this\nsource is blocked until the dispatch function returns.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"can_recurse\" transfer-ownership=\"none\" gs:managed-name=\"canRecurse\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">whether recursion is allowed for this source</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"can_recurse\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">whether recursion is allowed for this source</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_funcs\" c:identifier=\"g_source_set_funcs\" version=\"2.12\" gs:managed-name=\"SetFuncs\">\n    <doc xml:space=\"preserve\">Sets the source functions (can be used to override\ndefault implementations) of an unattached source.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"funcs\" transfer-ownership=\"none\" gs:managed-name=\"funcs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">the new #GSourceFuncs</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"funcs\" transfer-ownership=\"none\" gs:managed-name=\"funcs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">the new #GSourceFuncs</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_name\" c:identifier=\"g_source_set_name\" version=\"2.26\" gs:managed-name=\"set_Name\" gs:property=\"Name\">\n    <doc xml:space=\"preserve\">Sets a name for the source, used in debugging and profiling.\nThe name defaults to #NULL.\n\nThe source name should describe in a human-readable way\nwhat the source does. For example, \"X11 event queue\"\nor \"GTK+ repaint idle handler\" or whatever it is.\n\nIt is permitted to call this function multiple times, but is not\nrecommended due to the potential performance impact.  For example,\none could change the name in the \"check\" function of a #GSourceFuncs\nto include details like the event type in the source name.\n\nUse caution if changing the name while another thread may be\naccessing it with g_source_get_name(); that function does not copy\nthe value, and changing the value will free it while the other thread\nmay be attempting to use it.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"name\" transfer-ownership=\"none\" gs:managed-name=\"name\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">debug name for the source</doc>\n        <type name=\"utf8\" c:type=\"const char*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"name\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">debug name for the source</doc>\n        <type name=\"utf8\" c:type=\"const char*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_priority\" c:identifier=\"g_source_set_priority\" gs:managed-name=\"set_Priority\" gs:property=\"Priority\">\n    <doc xml:space=\"preserve\">Sets the priority of a source. While the main loop is being run, a\nsource will be dispatched if it is ready to be dispatched and no\nsources at a higher (numerically smaller) priority are ready to be\ndispatched.\n\nA child source always has the same priority as its parent.  It is not\npermitted to change the priority of a source once it has been added\nas a child of another source.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the new priority.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the new priority.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"set_ready_time\" c:identifier=\"g_source_set_ready_time\" version=\"2.36\" gs:managed-name=\"set_ReadyTime\" gs:property=\"ReadyTime\">\n    <doc xml:space=\"preserve\">Sets a #GSource to be dispatched when the given monotonic time is\nreached (or passed).  If the monotonic time is in the past (as it\nalways will be if @ready_time is 0) then the source will be\ndispatched immediately.\n\nIf @ready_time is -1 then the source is never woken up on the basis\nof the passage of time.\n\nDispatching the source does not reset the ready time.  You should do\nso yourself, from the source dispatch function.\n\nNote that if you have a pair of sources where the ready time of one\nsuggests that it will be delivered first but the priority for the\nother suggests that it would be delivered first, and the ready time\nfor both sources is reached during the same main context iteration\nthen the order of dispatch is undefined.\n\nThis API is only intended to be used by implementations of #GSource.\nDo not call this API on a #GSource that you did not create.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n      <parameter name=\"ready_time\" transfer-ownership=\"none\" gs:managed-name=\"readyTime\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the monotonic time at which the source will be ready,\n             0 for \"immediately\", -1 for \"never\"</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"ready_time\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the monotonic time at which the source will be ready,\n             0 for \"immediately\", -1 for \"never\"</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_source_unref\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count of a source by one. If the\nresulting reference count is zero the source and associated\nmemory will be destroyed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GSource</doc>\n        <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"remove_by_tag\" c:identifier=\"g_source_remove\" gs:managed-name=\"RemoveByTag\">\n    <doc xml:space=\"preserve\">Removes the source with the given id from the default main context.\n\nThe id of a #GSource is given by g_source_get_id(), or will be\nreturned by the functions g_source_attach(), g_idle_add(),\ng_idle_add_full(), g_timeout_add(), g_timeout_add_full(),\ng_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and\ng_io_add_watch_full().\n\nSee also g_source_destroy(). You must use g_source_destroy() for sources\nadded to a non-default main context.\n\nIt is a programmer error to attempt to remove a non-existent source.\n\nMore specifically: source IDs can be reissued after a source has been\ndestroyed and therefore it is never valid to use this function with a\nsource ID which may have already been removed.  An example is when\nscheduling an idle to run in another thread with g_idle_add(): the\nidle may already have run and been removed by the time this function\nis called on its (now invalid) source ID.  This source ID may have\nbeen reissued, leading to the operation being performed against the\nwrong source.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">For historical reasons, this function always returns %TRUE</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"tag\" transfer-ownership=\"none\" gs:managed-name=\"tag\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the ID of the source to remove.</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tag\" transfer-ownership=\"none\" gs:managed-name=\"tag\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the ID of the source to remove.</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"remove_by_funcs_user_data\" c:identifier=\"g_source_remove_by_funcs_user_data\" gs:managed-name=\"RemoveByFuncsUserData\">\n    <doc xml:space=\"preserve\">Removes a source from the default main loop context given the\nsource functions and user data. If multiple sources exist with the\nsame source functions and user data, only one will be destroyed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a source was found and removed.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"funcs\" transfer-ownership=\"none\" gs:managed-name=\"funcs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">The @source_funcs passed to g_source_new()</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user data for the callback</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"funcs\" transfer-ownership=\"none\" gs:managed-name=\"funcs\" gs:managed-type=\"SourceFuncs\" gs:unmanaged-type=\"SourceFuncs\">\n        <doc xml:space=\"preserve\">The @source_funcs passed to g_source_new()</doc>\n        <type name=\"SourceFuncs\" c:type=\"GSourceFuncs*\" gs:managed-name=\"SourceFuncs\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user data for the callback</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"remove_by_user_data\" c:identifier=\"g_source_remove_by_user_data\" gs:managed-name=\"RemoveByUserData\">\n    <doc xml:space=\"preserve\">Removes a source from the default main loop context given the user\ndata for the callback. If multiple sources exist with the same user\ndata, only one will be destroyed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a source was found and removed.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user_data for the callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the user_data for the callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"set_name_by_id\" c:identifier=\"g_source_set_name_by_id\" version=\"2.26\" gs:managed-name=\"SetNameById\">\n    <doc xml:space=\"preserve\">Sets the name of a source using its ID.\n\nThis is a convenience utility to set source names from the return\nvalue of g_idle_add(), g_timeout_add(), etc.\n\nIt is a programmer error to attempt to set the name of a non-existent\nsource.\n\nMore specifically: source IDs can be reissued after a source has been\ndestroyed and therefore it is never valid to use this function with a\nsource ID which may have already been removed.  An example is when\nscheduling an idle to run in another thread with g_idle_add(): the\nidle may already have run and been removed by the time this function\nis called on its (now invalid) source ID.  This source ID may have\nbeen reissued, leading to the operation being performed against the\nwrong source.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"tag\" transfer-ownership=\"none\" gs:managed-name=\"tag\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">a #GSource ID</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"name\" transfer-ownership=\"none\" gs:managed-name=\"name\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">debug name for the source</doc>\n        <type name=\"utf8\" c:type=\"const char*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"tag\" transfer-ownership=\"none\" gs:managed-name=\"tag\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">a #GSource ID</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"name\" transfer-ownership=\"none\" gs:managed-name=\"name\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">debug name for the source</doc>\n        <type name=\"utf8\" c:type=\"const char*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <constant name=\"CONTINUE\" value=\"true\" c:type=\"G_SOURCE_CONTINUE\" version=\"2.32\" gs:managed-name=\"Continue\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">Use this macro as the return value of a #GSourceFunc to leave\nthe #GSource in the main loop.</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </constant>\n  <constant name=\"REMOVE\" value=\"false\" c:type=\"G_SOURCE_REMOVE\" version=\"2.32\" gs:managed-name=\"Remove\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">Use this macro as the return value of a #GSourceFunc to remove\nthe #GSource from the main loop.</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </constant>\n  <function name=\"main_current_source\" c:identifier=\"g_main_current_source\" version=\"2.12\" gs:managed-name=\"MainCurrentSource\">\n    <doc xml:space=\"preserve\">Returns the currently firing source for this thread.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">The currently firing source or %NULL.</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n  </function>\n</record>")]
    public partial class Source : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.Source>
    {
        /// <summary>
        /// Use this macro as the return value of a #GSourceFunc to leave
        /// the #GSource in the main loop.
        /// </summary>
        [GISharp.Core.Since("2.32")]
        public const System.Boolean Continue = true;

        /// <summary>
        /// Use this macro as the return value of a #GSourceFunc to remove
        /// the #GSource from the main loop.
        /// </summary>
        [GISharp.Core.Since("2.32")]
        public const System.Boolean Remove = false;

        /// <summary>
        /// Checks whether a source is allowed to be called recursively.
        /// see g_source_set_can_recurse().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// whether recursion is allowed.
        /// </returns>
        public System.Boolean CanRecurse
        {
            get
            {
                return default(System.Boolean);
            }

            set
            {
            }
        }

        /// <summary>
        /// Gets the #GMainContext with which the source is associated.
        /// </summary>
        /// <remarks>
        /// You can call this on a source that has been destroyed, provided
        /// that the #GMainContext it was attached to still exists (in which
        /// case it will return that #GMainContext). In particular, you can
        /// always call this function on the source returned from
        /// g_main_current_source(). But calling this function on a source
        /// whose #GMainContext has been destroyed is an error.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the #GMainContext with which the
        ///               source is associated, or %NULL if the context has not
        ///               yet been added to a source.
        /// </returns>
        public GISharp.GLib.MainContext Context
        {
            get
            {
                return default(GISharp.GLib.MainContext);
            }
        }

        /// <summary>
        /// Returns the numeric ID for a particular source. The ID of a source
        /// is a positive integer which is unique within a particular main loop
        /// context. The reverse
        /// mapping from ID to source is done by g_main_context_find_source_by_id().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the ID (greater than 0) for the source
        /// </returns>
        public System.UInt32 Id
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Gets a name for the source, used in debugging and profiling.  The
        /// name may be #NULL if it has never been set with g_source_set_name().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the name of the source
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.String Name
        {
            get
            {
                return default(System.String);
            }

            set
            {
            }
        }

        /// <summary>
        /// Gets the priority of a source.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the priority of the source
        /// </returns>
        public System.Int32 Priority
        {
            get
            {
                return default(System.Int32);
            }

            set
            {
            }
        }

        /// <summary>
        /// Gets the "ready time" of @source, as set by
        /// g_source_set_ready_time().
        /// </summary>
        /// <remarks>
        /// Any time before the current monotonic time (including 0) is an
        /// indication that the source will fire immediately.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the monotonic ready time, -1 for "never"
        /// </returns>
        public System.Int64 ReadyTime
        {
            get
            {
                return default(System.Int64);
            }

            set
            {
            }
        }

        /// <summary>
        /// Gets the time to be used when checking this source. The advantage of
        /// calling this function over calling g_get_monotonic_time() directly is
        /// that when checking multiple sources, GLib can cache a single value
        /// instead of having to repeatedly get the system monotonic time.
        /// </summary>
        /// <remarks>
        /// The time here is the system monotonic time, if available, or some
        /// other reasonable alternative otherwise.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the monotonic time in microseconds
        /// </returns>
        [GISharp.Core.Since("2.28")]
        public System.Int64 Time
        {
            get
            {
                return default(System.Int64);
            }
        }

        /// <summary>
        /// Returns whether @source has been destroyed.
        /// </summary>
        /// <remarks>
        /// This is important when you operate upon your objects
        /// from within idle handlers, but may have freed the object
        /// before the dispatch of your idle handler.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static gboolean
        /// idle_callback (gpointer data)
        /// {
        ///   SomeWidget *self = data;
        ///    
        ///   GDK_THREADS_ENTER ();
        ///   // do stuff with self
        ///   self-&gt;idle_id = 0;
        ///   GDK_THREADS_LEAVE ();
        ///    
        ///   return G_SOURCE_REMOVE;
        /// }
        ///  
        /// static void
        /// some_widget_do_stuff_later (SomeWidget *self)
        /// {
        ///   self-&gt;idle_id = g_idle_add (idle_callback, self);
        /// }
        ///  
        /// static void
        /// some_widget_finalize (GObject *object)
        /// {
        ///   SomeWidget *self = SOME_WIDGET (object);
        ///    
        ///   if (self-&gt;idle_id)
        ///     g_source_remove (self-&gt;idle_id);
        ///    
        ///   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
        /// }
        /// ]|
        /// 
        /// This will fail in a multi-threaded application if the
        /// widget is destroyed before the idle handler fires due
        /// to the use after free in the callback. A solution, to
        /// this particular problem, is to check to if the source
        /// has already been destroy within the callback.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static gboolean
        /// idle_callback (gpointer data)
        /// {
        ///   SomeWidget *self = data;
        ///   
        ///   GDK_THREADS_ENTER ();
        ///   if (!g_source_is_destroyed (g_main_current_source ()))
        ///     {
        ///       // do stuff with self
        ///     }
        ///   GDK_THREADS_LEAVE ();
        ///   
        ///   return FALSE;
        /// }
        /// ]|
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// %TRUE if the source has been destroyed
        /// </returns>
        [GISharp.Core.Since("2.12")]
        public System.Boolean IsDestroyed
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public Source(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GSource structure. The size is specified to
        /// allow creating structures derived from #GSource that contain
        /// additional data. The size passed in must be at least
        /// `sizeof (GSource)`.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// </remarks>
        /// <param name="sourceFuncs">
        /// structure containing functions that implement
        ///                the sources behavior.
        /// </param>
        /// <param name="structSize">
        /// size of the #GSource structure to create.
        /// </param>
        /// <returns>
        /// the newly-created #GSource.
        /// </returns>
        public Source(
            GISharp.GLib.SourceFuncs sourceFuncs,
            System.UInt32 structSize) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GSource structure. The size is specified to
        /// allow creating structures derived from #GSource that contain
        /// additional data. The size passed in must be at least
        /// `sizeof (GSource)`.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// </remarks>
        /// <param name="sourceFuncs">
        /// structure containing functions that implement
        ///                the sources behavior.
        /// </param>
        /// <param name="structSize">
        /// size of the #GSource structure to create.
        /// </param>
        /// <returns>
        /// the newly-created #GSource.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_source_new(
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFuncs sourceFuncs,
            [System.Runtime.InteropServices.In()] System.UInt32 structSize);

        /// <summary>
        /// Removes the source with the given id from the default main context.
        /// </summary>
        /// <remarks>
        /// The id of a #GSource is given by g_source_get_id(), or will be
        /// returned by the functions g_source_attach(), g_idle_add(),
        /// g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
        /// g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
        /// g_io_add_watch_full().
        /// 
        /// See also g_source_destroy(). You must use g_source_destroy() for sources
        /// added to a non-default main context.
        /// 
        /// It is a programmer error to attempt to remove a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="tag">
        /// the ID of the source to remove.
        /// </param>
        /// <returns>
        /// For historical reasons, this function always returns %TRUE
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_source_remove(
            [System.Runtime.InteropServices.In()] System.UInt32 tag);

        /// <summary>
        /// Removes the source with the given id from the default main context.
        /// </summary>
        /// <remarks>
        /// The id of a #GSource is given by g_source_get_id(), or will be
        /// returned by the functions g_source_attach(), g_idle_add(),
        /// g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
        /// g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
        /// g_io_add_watch_full().
        /// 
        /// See also g_source_destroy(). You must use g_source_destroy() for sources
        /// added to a non-default main context.
        /// 
        /// It is a programmer error to attempt to remove a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="tag">
        /// the ID of the source to remove.
        /// </param>
        /// <returns>
        /// For historical reasons, this function always returns %TRUE
        /// </returns>
        public static System.Boolean RemoveByTag(
            System.UInt32 tag)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes a source from the default main loop context given the
        /// source functions and user data. If multiple sources exist with the
        /// same source functions and user data, only one will be destroyed.
        /// </summary>
        /// <param name="funcs">
        /// The @source_funcs passed to g_source_new()
        /// </param>
        /// <param name="userData">
        /// the user data for the callback
        /// </param>
        /// <returns>
        /// %TRUE if a source was found and removed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_source_remove_by_funcs_user_data(
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFuncs funcs,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Removes a source from the default main loop context given the
        /// source functions and user data. If multiple sources exist with the
        /// same source functions and user data, only one will be destroyed.
        /// </summary>
        /// <param name="funcs">
        /// The @source_funcs passed to g_source_new()
        /// </param>
        /// <param name="userData">
        /// the user data for the callback
        /// </param>
        /// <returns>
        /// %TRUE if a source was found and removed.
        /// </returns>
        public static System.Boolean RemoveByFuncsUserData(
            GISharp.GLib.SourceFuncs funcs,
            System.IntPtr userData)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Removes a source from the default main loop context given the user
        /// data for the callback. If multiple sources exist with the same user
        /// data, only one will be destroyed.
        /// </summary>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// %TRUE if a source was found and removed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_source_remove_by_user_data(
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Removes a source from the default main loop context given the user
        /// data for the callback. If multiple sources exist with the same user
        /// data, only one will be destroyed.
        /// </summary>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// %TRUE if a source was found and removed.
        /// </returns>
        public static System.Boolean RemoveByUserData(
            System.IntPtr userData)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Sets the name of a source using its ID.
        /// </summary>
        /// <remarks>
        /// This is a convenience utility to set source names from the return
        /// value of g_idle_add(), g_timeout_add(), etc.
        /// 
        /// It is a programmer error to attempt to set the name of a non-existent
        /// source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="tag">
        /// a #GSource ID
        /// </param>
        /// <param name="name">
        /// debug name for the source
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_source_set_name_by_id(
            [System.Runtime.InteropServices.In()] System.UInt32 tag,
            [System.Runtime.InteropServices.In()] System.IntPtr name);

        /// <summary>
        /// Sets the name of a source using its ID.
        /// </summary>
        /// <remarks>
        /// This is a convenience utility to set source names from the return
        /// value of g_idle_add(), g_timeout_add(), etc.
        /// 
        /// It is a programmer error to attempt to set the name of a non-existent
        /// source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="tag">
        /// a #GSource ID
        /// </param>
        /// <param name="name">
        /// debug name for the source
        /// </param>
        [GISharp.Core.Since("2.26")]
        public static void SetNameById(
            System.UInt32 tag,
            System.String name)
        {
        }

        /// <summary>
        /// Returns the currently firing source for this thread.
        /// </summary>
        /// <returns>
        /// The currently firing source or %NULL.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern System.IntPtr g_main_current_source();

        /// <summary>
        /// Returns the currently firing source for this thread.
        /// </summary>
        /// <returns>
        /// The currently firing source or %NULL.
        /// </returns>
        [GISharp.Core.Since("2.12")]
        public static GISharp.GLib.Source MainCurrentSource()
        {
            return default(GISharp.GLib.Source);
        }

        /// <summary>
        /// Adds @child_source to @source as a "polled" source; when @source is
        /// added to a #GMainContext, @child_source will be automatically added
        /// with the same priority, when @child_source is triggered, it will
        /// cause @source to dispatch (in addition to calling its own
        /// callback), and when @source is destroyed, it will destroy
        /// @child_source as well. (@source will also still be dispatched if
        /// its own prepare/check functions indicate that it is ready.)
        /// </summary>
        /// <remarks>
        /// If you don't need @child_source to do anything on its own when it
        /// triggers, you can call g_source_set_dummy_callback() on it to set a
        /// callback that does nothing (except return %TRUE if appropriate).
        /// 
        /// @source will hold a reference on @child_source while @child_source
        /// is attached to it.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="childSource">
        /// a second #GSource that @source should "poll"
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern void g_source_add_child_source(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.IntPtr childSource);

        /// <summary>
        /// Adds @child_source to @source as a "polled" source; when @source is
        /// added to a #GMainContext, @child_source will be automatically added
        /// with the same priority, when @child_source is triggered, it will
        /// cause @source to dispatch (in addition to calling its own
        /// callback), and when @source is destroyed, it will destroy
        /// @child_source as well. (@source will also still be dispatched if
        /// its own prepare/check functions indicate that it is ready.)
        /// </summary>
        /// <remarks>
        /// If you don't need @child_source to do anything on its own when it
        /// triggers, you can call g_source_set_dummy_callback() on it to set a
        /// callback that does nothing (except return %TRUE if appropriate).
        /// 
        /// @source will hold a reference on @child_source while @child_source
        /// is attached to it.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="childSource">
        /// a second #GSource that @source should "poll"
        /// </param>
        [GISharp.Core.Since("2.28")]
        public void AddChildSource(
            GISharp.GLib.Source childSource)
        {
        }

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this source. This is usually combined with g_source_new() to add an
        /// event source. The event source's check function will typically test
        /// the @revents field in the #GPollFD struct and return %TRUE if events need
        /// to be processed.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// Using this API forces the linear scanning of event sources on each
        /// main loop iteration.  Newly-written event sources should try to use
        /// g_source_add_unix_fd() instead of this API.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_add_poll(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] GISharp.GLib.PollFD fd);

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this source. This is usually combined with g_source_new() to add an
        /// event source. The event source's check function will typically test
        /// the @revents field in the #GPollFD struct and return %TRUE if events need
        /// to be processed.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// Using this API forces the linear scanning of event sources on each
        /// main loop iteration.  Newly-written event sources should try to use
        /// g_source_add_unix_fd() instead of this API.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        public void AddPoll(
            GISharp.GLib.PollFD fd)
        {
        }

        /// <summary>
        /// Adds a #GSource to a @context so that it will be executed within
        /// that context. Remove it by calling g_source_destroy().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// the ID (greater than 0) for the source within the
        ///   #GMainContext.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_source_attach(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.IntPtr context);

        /// <summary>
        /// Adds a #GSource to a @context so that it will be executed within
        /// that context. Remove it by calling g_source_destroy().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// the ID (greater than 0) for the source within the
        ///   #GMainContext.
        /// </returns>
        public System.UInt32 Attach(
            GISharp.GLib.MainContext context)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Removes a source from its #GMainContext, if any, and mark it as
        /// destroyed.  The source cannot be subsequently added to another
        /// context. It is safe to call this on sources which have already been
        /// removed from their context.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_destroy(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Removes a source from its #GMainContext, if any, and mark it as
        /// destroyed.  The source cannot be subsequently added to another
        /// context. It is safe to call this on sources which have already been
        /// removed from their context.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        public void Destroy()
        {
        }

        /// <summary>
        /// Checks whether a source is allowed to be called recursively.
        /// see g_source_set_can_recurse().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// whether recursion is allowed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_source_get_can_recurse(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Gets the #GMainContext with which the source is associated.
        /// </summary>
        /// <remarks>
        /// You can call this on a source that has been destroyed, provided
        /// that the #GMainContext it was attached to still exists (in which
        /// case it will return that #GMainContext). In particular, you can
        /// always call this function on the source returned from
        /// g_main_current_source(). But calling this function on a source
        /// whose #GMainContext has been destroyed is an error.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the #GMainContext with which the
        ///               source is associated, or %NULL if the context has not
        ///               yet been added to a source.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_source_get_context(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// This function ignores @source and is otherwise the same as
        /// g_get_current_time().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="timeval">
        /// #GTimeVal structure in which to store current time.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [System.Obsolete("use g_source_get_time() instead")]
        static extern void g_source_get_current_time(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal timeval);

        /// <summary>
        /// This function ignores @source and is otherwise the same as
        /// g_get_current_time().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="timeval">
        /// #GTimeVal structure in which to store current time.
        /// </param>
        [System.Obsolete("use g_source_get_time() instead")]
        public void GetCurrentTime(
            GISharp.GLib.TimeVal timeval)
        {
        }

        /// <summary>
        /// Returns the numeric ID for a particular source. The ID of a source
        /// is a positive integer which is unique within a particular main loop
        /// context. The reverse
        /// mapping from ID to source is done by g_main_context_find_source_by_id().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the ID (greater than 0) for the source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_source_get_id(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Gets a name for the source, used in debugging and profiling.  The
        /// name may be #NULL if it has never been set with g_source_set_name().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the name of the source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_source_get_name(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Gets the priority of a source.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the priority of the source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_source_get_priority(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Gets the "ready time" of @source, as set by
        /// g_source_set_ready_time().
        /// </summary>
        /// <remarks>
        /// Any time before the current monotonic time (including 0) is an
        /// indication that the source will fire immediately.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the monotonic ready time, -1 for "never"
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int64 g_source_get_ready_time(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Gets the time to be used when checking this source. The advantage of
        /// calling this function over calling g_get_monotonic_time() directly is
        /// that when checking multiple sources, GLib can cache a single value
        /// instead of having to repeatedly get the system monotonic time.
        /// </summary>
        /// <remarks>
        /// The time here is the system monotonic time, if available, or some
        /// other reasonable alternative otherwise.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the monotonic time in microseconds
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern System.Int64 g_source_get_time(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Returns whether @source has been destroyed.
        /// </summary>
        /// <remarks>
        /// This is important when you operate upon your objects
        /// from within idle handlers, but may have freed the object
        /// before the dispatch of your idle handler.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static gboolean
        /// idle_callback (gpointer data)
        /// {
        ///   SomeWidget *self = data;
        ///    
        ///   GDK_THREADS_ENTER ();
        ///   // do stuff with self
        ///   self-&gt;idle_id = 0;
        ///   GDK_THREADS_LEAVE ();
        ///    
        ///   return G_SOURCE_REMOVE;
        /// }
        ///  
        /// static void
        /// some_widget_do_stuff_later (SomeWidget *self)
        /// {
        ///   self-&gt;idle_id = g_idle_add (idle_callback, self);
        /// }
        ///  
        /// static void
        /// some_widget_finalize (GObject *object)
        /// {
        ///   SomeWidget *self = SOME_WIDGET (object);
        ///    
        ///   if (self-&gt;idle_id)
        ///     g_source_remove (self-&gt;idle_id);
        ///    
        ///   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
        /// }
        /// ]|
        /// 
        /// This will fail in a multi-threaded application if the
        /// widget is destroyed before the idle handler fires due
        /// to the use after free in the callback. A solution, to
        /// this particular problem, is to check to if the source
        /// has already been destroy within the callback.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static gboolean
        /// idle_callback (gpointer data)
        /// {
        ///   SomeWidget *self = data;
        ///   
        ///   GDK_THREADS_ENTER ();
        ///   if (!g_source_is_destroyed (g_main_current_source ()))
        ///     {
        ///       // do stuff with self
        ///     }
        ///   GDK_THREADS_LEAVE ();
        ///   
        ///   return FALSE;
        /// }
        /// ]|
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// %TRUE if the source has been destroyed
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern System.Boolean g_source_is_destroyed(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Increases the reference count on a source by one.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// @source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_source_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Increases the reference count on a source by one.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// @source
        /// </returns>
        public override void Ref()
        {
        }

        /// <summary>
        /// Detaches @child_source from @source and destroys it.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="childSource">
        /// a #GSource previously passed to
        ///     g_source_add_child_source().
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern void g_source_remove_child_source(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.IntPtr childSource);

        /// <summary>
        /// Detaches @child_source from @source and destroys it.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="childSource">
        /// a #GSource previously passed to
        ///     g_source_add_child_source().
        /// </param>
        [GISharp.Core.Since("2.28")]
        public void RemoveChildSource(
            GISharp.GLib.Source childSource)
        {
        }

        /// <summary>
        /// Removes a file descriptor from the set of file descriptors polled for
        /// this source.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure previously passed to g_source_add_poll().
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_remove_poll(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] GISharp.GLib.PollFD fd);

        /// <summary>
        /// Removes a file descriptor from the set of file descriptors polled for
        /// this source.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure previously passed to g_source_add_poll().
        /// </param>
        public void RemovePoll(
            GISharp.GLib.PollFD fd)
        {
        }

        /// <summary>
        /// Reverses the effect of a previous call to g_source_add_unix_fd().
        /// </summary>
        /// <remarks>
        /// You only need to call this if you want to remove an fd from being
        /// watched while keeping the same source around.  In the normal case you
        /// will just want to destroy the source.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// As the name suggests, this function is not available on Windows.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="tag">
        /// the tag from g_source_add_unix_fd()
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.36")]
        static extern void g_source_remove_unix_fd(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.IntPtr tag);

        /// <summary>
        /// Reverses the effect of a previous call to g_source_add_unix_fd().
        /// </summary>
        /// <remarks>
        /// You only need to call this if you want to remove an fd from being
        /// watched while keeping the same source around.  In the normal case you
        /// will just want to destroy the source.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// As the name suggests, this function is not available on Windows.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="tag">
        /// the tag from g_source_add_unix_fd()
        /// </param>
        [GISharp.Core.Since("2.36")]
        public void RemoveUnixFd(
            System.IntPtr tag)
        {
        }

        /// <summary>
        /// Sets the callback function for a source. The callback for a source is
        /// called from the source's dispatch function.
        /// </summary>
        /// <remarks>
        /// The exact type of @func depends on the type of source; ie. you
        /// should not count on @func being called with @data as its first
        /// parameter.
        /// 
        /// Typically, you won't use this function. Instead use functions specific
        /// to the type of source you are using.
        /// </remarks>
        /// <param name="source">
        /// the source
        /// </param>
        /// <param name="func">
        /// a callback function
        /// </param>
        /// <param name="data">
        /// the data to pass to callback function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_set_callback(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc func,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify);

        /// <summary>
        /// Sets the callback function for a source. The callback for a source is
        /// called from the source's dispatch function.
        /// </summary>
        /// <remarks>
        /// The exact type of @func depends on the type of source; ie. you
        /// should not count on @func being called with @data as its first
        /// parameter.
        /// 
        /// Typically, you won't use this function. Instead use functions specific
        /// to the type of source you are using.
        /// </remarks>
        /// <param name="source">
        /// the source
        /// </param>
        /// <param name="func">
        /// a callback function
        /// </param>
        /// <param name="data">
        /// the data to pass to callback function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        public void SetCallback(
            GISharp.GLib.SourceFunc func)
        {
        }

        /// <summary>
        /// Sets the callback function storing the data as a refcounted callback
        /// "object". This is used internally. Note that calling
        /// g_source_set_callback_indirect() assumes
        /// an initial reference count on @callback_data, and thus
        /// @callback_funcs-&gt;unref will eventually be called once more
        /// than @callback_funcs-&gt;ref.
        /// </summary>
        /// <param name="source">
        /// the source
        /// </param>
        /// <param name="callbackData">
        /// pointer to callback data "object"
        /// </param>
        /// <param name="callbackFuncs">
        /// functions for reference counting @callback_data
        ///                  and getting the callback and data
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_set_callback_indirect(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.IntPtr callbackData,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceCallbackFuncs callbackFuncs);

        /// <summary>
        /// Sets the callback function storing the data as a refcounted callback
        /// "object". This is used internally. Note that calling
        /// g_source_set_callback_indirect() assumes
        /// an initial reference count on @callback_data, and thus
        /// @callback_funcs-&gt;unref will eventually be called once more
        /// than @callback_funcs-&gt;ref.
        /// </summary>
        /// <param name="source">
        /// the source
        /// </param>
        /// <param name="callbackData">
        /// pointer to callback data "object"
        /// </param>
        /// <param name="callbackFuncs">
        /// functions for reference counting @callback_data
        ///                  and getting the callback and data
        /// </param>
        public void SetCallbackIndirect(
            System.IntPtr callbackData,
            GISharp.GLib.SourceCallbackFuncs callbackFuncs)
        {
        }

        /// <summary>
        /// Sets whether a source can be called recursively. If @can_recurse is
        /// %TRUE, then while the source is being dispatched then this source
        /// will be processed normally. Otherwise, all processing of this
        /// source is blocked until the dispatch function returns.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="canRecurse">
        /// whether recursion is allowed for this source
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_set_can_recurse(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.Boolean canRecurse);

        /// <summary>
        /// Sets the source functions (can be used to override
        /// default implementations) of an unattached source.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="funcs">
        /// the new #GSourceFuncs
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern void g_source_set_funcs(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFuncs funcs);

        /// <summary>
        /// Sets the source functions (can be used to override
        /// default implementations) of an unattached source.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="funcs">
        /// the new #GSourceFuncs
        /// </param>
        [GISharp.Core.Since("2.12")]
        public void SetFuncs(
            GISharp.GLib.SourceFuncs funcs)
        {
        }

        /// <summary>
        /// Sets a name for the source, used in debugging and profiling.
        /// The name defaults to #NULL.
        /// </summary>
        /// <remarks>
        /// The source name should describe in a human-readable way
        /// what the source does. For example, "X11 event queue"
        /// or "GTK+ repaint idle handler" or whatever it is.
        /// 
        /// It is permitted to call this function multiple times, but is not
        /// recommended due to the potential performance impact.  For example,
        /// one could change the name in the "check" function of a #GSourceFuncs
        /// to include details like the event type in the source name.
        /// 
        /// Use caution if changing the name while another thread may be
        /// accessing it with g_source_get_name(); that function does not copy
        /// the value, and changing the value will free it while the other thread
        /// may be attempting to use it.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="name">
        /// debug name for the source
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_source_set_name(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.IntPtr name);

        /// <summary>
        /// Sets the priority of a source. While the main loop is being run, a
        /// source will be dispatched if it is ready to be dispatched and no
        /// sources at a higher (numerically smaller) priority are ready to be
        /// dispatched.
        /// </summary>
        /// <remarks>
        /// A child source always has the same priority as its parent.  It is not
        /// permitted to change the priority of a source once it has been added
        /// as a child of another source.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="priority">
        /// the new priority.
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_set_priority(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.Int32 priority);

        /// <summary>
        /// Sets a #GSource to be dispatched when the given monotonic time is
        /// reached (or passed).  If the monotonic time is in the past (as it
        /// always will be if @ready_time is 0) then the source will be
        /// dispatched immediately.
        /// </summary>
        /// <remarks>
        /// If @ready_time is -1 then the source is never woken up on the basis
        /// of the passage of time.
        /// 
        /// Dispatching the source does not reset the ready time.  You should do
        /// so yourself, from the source dispatch function.
        /// 
        /// Note that if you have a pair of sources where the ready time of one
        /// suggests that it will be delivered first but the priority for the
        /// other suggests that it would be delivered first, and the ready time
        /// for both sources is reached during the same main context iteration
        /// then the order of dispatch is undefined.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="readyTime">
        /// the monotonic time at which the source will be ready,
        ///              0 for "immediately", -1 for "never"
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.36")]
        static extern void g_source_set_ready_time(
            [System.Runtime.InteropServices.In()] System.IntPtr source,
            [System.Runtime.InteropServices.In()] System.Int64 readyTime);

        /// <summary>
        /// Decreases the reference count of a source by one. If the
        /// resulting reference count is zero the source and associated
        /// memory will be destroyed.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_source_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr source);

        /// <summary>
        /// Decreases the reference count of a source by one. If the
        /// resulting reference count is zero the source and associated
        /// memory will be destroyed.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// The `GSourceCallbackFuncs` struct contains
    /// functions for managing callback objects.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"SourceCallbackFuncs\" c:type=\"GSourceCallbackFuncs\" gs:managed-name=\"SourceCallbackFuncs\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The `GSourceCallbackFuncs` struct contains\nfunctions for managing callback objects.</doc>\n  <field name=\"ref\" gs:managed-name=\"Ref\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"ref\" gs:managed-name=\"Ref\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n        <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"cb_data\" transfer-ownership=\"none\" gs:managed-name=\"cbData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"cb_data\" transfer-ownership=\"none\" gs:managed-name=\"cbData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n  <field name=\"unref\" gs:managed-name=\"Unref\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"unref\" gs:managed-name=\"Unref\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n        <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"cb_data\" transfer-ownership=\"none\" gs:managed-name=\"cbData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"cb_data\" transfer-ownership=\"none\" gs:managed-name=\"cbData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n  <field name=\"get\" introspectable=\"0\" gs:managed-name=\"Get\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"get\" introspectable=\"0\" gs:managed-name=\"Get\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n        <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"cb_data\" transfer-ownership=\"none\" gs:managed-name=\"cbData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n        <parameter name=\"func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"func\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n          <type name=\"SourceFunc\" c:type=\"GSourceFunc*\" gs:managed-name=\"SourceFunc\" />\n        </parameter>\n        <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"cb_data\" transfer-ownership=\"none\" gs:managed-name=\"cbData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n        <parameter name=\"func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"func\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n          <type name=\"SourceFunc\" c:type=\"GSourceFunc*\" gs:managed-name=\"SourceFunc\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n</record>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SourceCallbackFuncs
    {
        public System.IntPtr Ref;
        public System.IntPtr Unref;
        public System.IntPtr Get;
    }

    /// <summary>
    /// This is just a placeholder for #GClosureMarshal,
    /// which cannot be used here for dependency reasons.
    /// </summary>
    [GISharp.Core.GirXml("<callback name=\"SourceDummyMarshal\" c:type=\"GSourceDummyMarshal\" gs:managed-name=\"SourceDummyMarshal\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">This is just a placeholder for #GClosureMarshal,\nwhich cannot be used here for dependency reasons.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void SourceDummyMarshalNative();

    /// <summary>
    /// This is just a placeholder for #GClosureMarshal,
    /// which cannot be used here for dependency reasons.
    /// </summary>
    [GISharp.Core.GirXml("<callback name=\"SourceDummyMarshal\" c:type=\"GSourceDummyMarshal\" gs:managed-name=\"SourceDummyMarshal\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">This is just a placeholder for #GClosureMarshal,\nwhich cannot be used here for dependency reasons.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n</callback>")]
    public delegate void SourceDummyMarshal();

    /// <summary>
    /// Specifies the type of function passed to g_timeout_add(),
    /// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
    /// </summary>
    /// <param name="userData">
    /// data passed to the function, set when the source was
    ///     created with one of the above functions
    /// </param>
    /// <returns>
    /// %FALSE if the source should be removed. #G_SOURCE_CONTINUE and
    /// #G_SOURCE_REMOVE are more memorable names for the return value.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_timeout_add(),\ng_timeout_add_full(), g_idle_add(), and g_idle_add_full().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">%FALSE if the source should be removed. #G_SOURCE_CONTINUE and\n#G_SOURCE_REMOVE are more memorable names for the return value.</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"0\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">data passed to the function, set when the source was\n    created with one of the above functions</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters />\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.Boolean SourceFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr userData);

    /// <summary>
    /// Specifies the type of function passed to g_timeout_add(),
    /// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
    /// </summary>
    /// <param name="userData">
    /// data passed to the function, set when the source was
    ///     created with one of the above functions
    /// </param>
    /// <returns>
    /// %FALSE if the source should be removed. #G_SOURCE_CONTINUE and
    /// #G_SOURCE_REMOVE are more memorable names for the return value.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_timeout_add(),\ng_timeout_add_full(), g_idle_add(), and g_idle_add_full().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">%FALSE if the source should be removed. #G_SOURCE_CONTINUE and\n#G_SOURCE_REMOVE are more memorable names for the return value.</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"0\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">data passed to the function, set when the source was\n    created with one of the above functions</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters />\n</callback>")]
    public delegate System.Boolean SourceFunc();

    /// <summary>
    /// The `GSourceFuncs` struct contains a table of
    /// functions used to handle event sources in a generic manner.
    /// </summary>
    /// <remarks>
    /// For idle sources, the prepare and check functions always return %TRUE
    /// to indicate that the source is always ready to be processed. The prepare
    /// function also returns a timeout value of 0 to ensure that the poll() call
    /// doesn't block (since that would be time wasted which could have been spent
    /// running the idle function).
    /// 
    /// For timeout sources, the prepare and check functions both return %TRUE
    /// if the timeout interval has expired. The prepare function also returns
    /// a timeout value to ensure that the poll() call doesn't block too long
    /// and miss the next timeout.
    /// 
    /// For file descriptor sources, the prepare function typically returns %FALSE,
    /// since it must wait until poll() has been called before it knows whether
    /// any events need to be processed. It sets the returned timeout to -1 to
    /// indicate that it doesn't mind how long the poll() call blocks. In the
    /// check function, it tests the results of the poll() call to see if the
    /// required condition has been met, and returns %TRUE if so.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"SourceFuncs\" c:type=\"GSourceFuncs\" gs:managed-name=\"SourceFuncs\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The `GSourceFuncs` struct contains a table of\nfunctions used to handle event sources in a generic manner.\n\nFor idle sources, the prepare and check functions always return %TRUE\nto indicate that the source is always ready to be processed. The prepare\nfunction also returns a timeout value of 0 to ensure that the poll() call\ndoesn't block (since that would be time wasted which could have been spent\nrunning the idle function).\n\nFor timeout sources, the prepare and check functions both return %TRUE\nif the timeout interval has expired. The prepare function also returns\na timeout value to ensure that the poll() call doesn't block too long\nand miss the next timeout.\n\nFor file descriptor sources, the prepare function typically returns %FALSE,\nsince it must wait until poll() has been called before it knows whether\nany events need to be processed. It sets the returned timeout to -1 to\nindicate that it doesn't mind how long the poll() call blocks. In the\ncheck function, it tests the results of the poll() call to see if the\nrequired condition has been met, and returns %TRUE if so.</doc>\n  <field name=\"prepare\" gs:managed-name=\"Prepare\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"prepare\" gs:managed-name=\"Prepare\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n        <parameter name=\"timeout_\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n          <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n        <parameter name=\"timeout_\" transfer-ownership=\"none\" gs:managed-name=\"timeout\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n          <type name=\"gint\" c:type=\"gint*\" gs:managed-name=\"Gint\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n  <field name=\"check\" gs:managed-name=\"Check\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"check\" gs:managed-name=\"Check\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n  <field name=\"dispatch\" introspectable=\"0\" gs:managed-name=\"Dispatch\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"dispatch\" introspectable=\"0\" gs:managed-name=\"Dispatch\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n        <parameter name=\"callback\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"callback\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n          <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n        </parameter>\n        <parameter name=\"user_data\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n        <parameter name=\"callback\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"callback\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n          <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n  <field name=\"finalize\" gs:managed-name=\"Finalize\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n    <callback name=\"finalize\" gs:managed-name=\"Finalize\">\n      <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n        <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n      </return-value>\n      <parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n      </parameters>\n      <gs:managed-parameters>\n        <parameter name=\"source\" transfer-ownership=\"none\" gs:managed-name=\"source\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n        </parameter>\n      </gs:managed-parameters>\n    </callback>\n  </field>\n  <field name=\"closure_callback\" readable=\"0\" private=\"1\" gs:managed-name=\"ClosureCallback\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n    <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n  </field>\n  <field name=\"closure_marshal\" readable=\"0\" private=\"1\" gs:managed-name=\"ClosureMarshal\" gs:managed-type=\"SourceDummyMarshal\" gs:unmanaged-type=\"SourceDummyMarshalNative\">\n    <type name=\"SourceDummyMarshal\" c:type=\"GSourceDummyMarshal\" gs:managed-name=\"SourceDummyMarshal\" />\n  </field>\n</record>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SourceFuncs
    {
        public System.IntPtr Prepare;
        public System.IntPtr Check;
        public System.IntPtr Dispatch;
        public System.IntPtr Finalize;
        public GISharp.GLib.SourceFunc ClosureCallback;
        public GISharp.GLib.SourceDummyMarshal ClosureMarshal;
    }

    /// <summary>
    /// Disambiguates a given time in two ways.
    /// </summary>
    /// <remarks>
    /// First, specifies if the given time is in universal or local time.
    /// 
    /// Second, if the time is in local time, specifies if it is local
    /// standard time or local daylight time.  This is important for the case
    /// where the same local time occurs twice (during daylight savings time
    /// transitions, for example).
    /// </remarks>
    [GISharp.Core.GirXml("<enumeration name=\"TimeType\" c:type=\"GTimeType\" gs:managed-name=\"TimeType\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Disambiguates a given time in two ways.\n\nFirst, specifies if the given time is in universal or local time.\n\nSecond, if the time is in local time, specifies if it is local\nstandard time or local daylight time.  This is important for the case\nwhere the same local time occurs twice (during daylight savings time\ntransitions, for example).</doc>\n  <member name=\"standard\" value=\"0\" c:identifier=\"G_TIME_TYPE_STANDARD\" gs:managed-name=\"Standard\">\n    <doc xml:space=\"preserve\">the time is in local standard time</doc>\n  </member>\n  <member name=\"daylight\" value=\"1\" c:identifier=\"G_TIME_TYPE_DAYLIGHT\" gs:managed-name=\"Daylight\">\n    <doc xml:space=\"preserve\">the time is in local daylight time</doc>\n  </member>\n  <member name=\"universal\" value=\"2\" c:identifier=\"G_TIME_TYPE_UNIVERSAL\" gs:managed-name=\"Universal\">\n    <doc xml:space=\"preserve\">the time is in UTC</doc>\n  </member>\n</enumeration>")]
    public enum TimeType
    {
        /// <summary>
        /// the time is in local standard time
        /// </summary>
        Standard = 0,
        /// <summary>
        /// the time is in local daylight time
        /// </summary>
        Daylight = 1,
        /// <summary>
        /// the time is in UTC
        /// </summary>
        Universal = 2
    }

    /// <summary>
    /// Represents a precise time, with seconds and microseconds.
    /// Similar to the struct timeval returned by the gettimeofday()
    /// UNIX system call.
    /// </summary>
    /// <remarks>
    /// GLib is attempting to unify around the use of 64bit integers to
    /// represent microsecond-precision time. As such, this type will be
    /// removed from a future version of GLib.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"TimeVal\" c:type=\"GTimeVal\" gs:managed-name=\"TimeVal\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Represents a precise time, with seconds and microseconds.\nSimilar to the struct timeval returned by the gettimeofday()\nUNIX system call.\n\nGLib is attempting to unify around the use of 64bit integers to\nrepresent microsecond-precision time. As such, this type will be\nremoved from a future version of GLib.</doc>\n  <field name=\"tv_sec\" writable=\"1\" gs:managed-name=\"TvSec\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">seconds</doc>\n    <type name=\"glong\" c:type=\"glong\" gs:managed-name=\"Glong\" />\n  </field>\n  <field name=\"tv_usec\" writable=\"1\" gs:managed-name=\"TvUsec\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n    <doc xml:space=\"preserve\">microseconds</doc>\n    <type name=\"glong\" c:type=\"glong\" gs:managed-name=\"Glong\" />\n  </field>\n  <method name=\"add\" c:identifier=\"g_time_val_add\" gs:managed-name=\"Add\">\n    <doc xml:space=\"preserve\">Adds the given number of microseconds to @time_. @microseconds can\nalso be negative to decrease the value of @time_.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"time_\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </instance-parameter>\n      <parameter name=\"microseconds\" transfer-ownership=\"none\" gs:managed-name=\"microseconds\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">number of microseconds to add to @time</doc>\n        <type name=\"glong\" c:type=\"glong\" gs:managed-name=\"Glong\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"microseconds\" transfer-ownership=\"none\" gs:managed-name=\"microseconds\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">number of microseconds to add to @time</doc>\n        <type name=\"glong\" c:type=\"glong\" gs:managed-name=\"Glong\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"to_iso8601\" c:identifier=\"g_time_val_to_iso8601\" version=\"2.12\" gs:managed-name=\"ToIso8601\">\n    <doc xml:space=\"preserve\">Converts @time_ into an RFC 3339 encoded string, relative to the\nCoordinated Universal Time (UTC). This is one of the many formats\nallowed by ISO 8601.\n\nISO 8601 allows a large number of date/time formats, with or without\npunctuation and optional elements. The format returned by this function\nis a complete date and time, with optional punctuation included, the\nUTC time zone represented as \"Z\", and the @tv_usec part included if\nand only if it is nonzero, i.e. either\n\"YYYY-MM-DDTHH:MM:SSZ\" or \"YYYY-MM-DDTHH:MM:SS.fffffZ\".\n\nThis corresponds to the Internet date/time format defined by\n[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt),\nand to either of the two most-precise formats defined by\nthe W3C Note\n[Date and Time Formats](http://www.w3.org/TR/NOTE-datetime-19980827).\nBoth of these documents are profiles of ISO 8601.\n\nUse g_date_time_format() or g_strdup_printf() if a different\nvariation of ISO 8601 format is required.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated string containing an ISO 8601 date</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"time_\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"from_iso8601\" c:identifier=\"g_time_val_from_iso8601\" version=\"2.12\" gs:managed-name=\"FromIso8601\">\n    <doc xml:space=\"preserve\">Converts a string containing an ISO 8601 encoded date and time\nto a #GTimeVal and puts it into @time_.\n\n@iso_date must include year, month, day, hours, minutes, and\nseconds. It can optionally include fractions of a second and a time\nzone indicator. (In the absence of any time zone indication, the\ntimestamp is assumed to be in local time.)</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the conversion was successful.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"iso_date\" transfer-ownership=\"none\" gs:managed-name=\"isoDate\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an ISO 8601 encoded date string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"time_\" direction=\"out\" caller-allocates=\"1\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"iso_date\" transfer-ownership=\"none\" gs:managed-name=\"isoDate\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an ISO 8601 encoded date string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"time_\" direction=\"out\" caller-allocates=\"1\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"TimeVal\" gs:unmanaged-type=\"TimeVal\">\n        <doc xml:space=\"preserve\">a #GTimeVal</doc>\n        <type name=\"TimeVal\" c:type=\"GTimeVal*\" gs:managed-name=\"TimeVal\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TimeVal
    {
        /// <summary>
        /// seconds
        /// </summary>
        public System.Int64 TvSec;

        /// <summary>
        /// microseconds
        /// </summary>
        public System.Int64 TvUsec;

        /// <summary>
        /// Converts a string containing an ISO 8601 encoded date and time
        /// to a #GTimeVal and puts it into @time_.
        /// </summary>
        /// <remarks>
        /// @iso_date must include year, month, day, hours, minutes, and
        /// seconds. It can optionally include fractions of a second and a time
        /// zone indicator. (In the absence of any time zone indication, the
        /// timestamp is assumed to be in local time.)
        /// </remarks>
        /// <param name="isoDate">
        /// an ISO 8601 encoded date string
        /// </param>
        /// <param name="time">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// %TRUE if the conversion was successful.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern System.Boolean g_time_val_from_iso8601(
            [System.Runtime.InteropServices.In()] System.IntPtr isoDate,
            [System.Runtime.InteropServices.Out()] out GISharp.GLib.TimeVal time);

        /// <summary>
        /// Converts a string containing an ISO 8601 encoded date and time
        /// to a #GTimeVal and puts it into @time_.
        /// </summary>
        /// <remarks>
        /// @iso_date must include year, month, day, hours, minutes, and
        /// seconds. It can optionally include fractions of a second and a time
        /// zone indicator. (In the absence of any time zone indication, the
        /// timestamp is assumed to be in local time.)
        /// </remarks>
        /// <param name="isoDate">
        /// an ISO 8601 encoded date string
        /// </param>
        /// <param name="time">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// %TRUE if the conversion was successful.
        /// </returns>
        [GISharp.Core.Since("2.12")]
        public static System.Boolean FromIso8601(
            System.String isoDate,
            out GISharp.GLib.TimeVal time)
        {
            time = default(GISharp.GLib.TimeVal);
            return default(System.Boolean);
        }

        /// <summary>
        /// Adds the given number of microseconds to @time_. @microseconds can
        /// also be negative to decrease the value of @time_.
        /// </summary>
        /// <param name="time">
        /// a #GTimeVal
        /// </param>
        /// <param name="microseconds">
        /// number of microseconds to add to @time
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_time_val_add(
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal time,
            [System.Runtime.InteropServices.In()] System.Int64 microseconds);

        /// <summary>
        /// Adds the given number of microseconds to @time_. @microseconds can
        /// also be negative to decrease the value of @time_.
        /// </summary>
        /// <param name="time">
        /// a #GTimeVal
        /// </param>
        /// <param name="microseconds">
        /// number of microseconds to add to @time
        /// </param>
        public void Add(
            System.Int64 microseconds)
        {
        }

        /// <summary>
        /// Converts @time_ into an RFC 3339 encoded string, relative to the
        /// Coordinated Universal Time (UTC). This is one of the many formats
        /// allowed by ISO 8601.
        /// </summary>
        /// <remarks>
        /// ISO 8601 allows a large number of date/time formats, with or without
        /// punctuation and optional elements. The format returned by this function
        /// is a complete date and time, with optional punctuation included, the
        /// UTC time zone represented as "Z", and the @tv_usec part included if
        /// and only if it is nonzero, i.e. either
        /// "YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".
        /// 
        /// This corresponds to the Internet date/time format defined by
        /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt),
        /// and to either of the two most-precise formats defined by
        /// the W3C Note
        /// [Date and Time Formats](http://www.w3.org/TR/NOTE-datetime-19980827).
        /// Both of these documents are profiles of ISO 8601.
        /// 
        /// Use g_date_time_format() or g_strdup_printf() if a different
        /// variation of ISO 8601 format is required.
        /// </remarks>
        /// <param name="time">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// a newly allocated string containing an ISO 8601 date
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.12")]
        static extern System.IntPtr g_time_val_to_iso8601(
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeVal time);

        /// <summary>
        /// Converts @time_ into an RFC 3339 encoded string, relative to the
        /// Coordinated Universal Time (UTC). This is one of the many formats
        /// allowed by ISO 8601.
        /// </summary>
        /// <remarks>
        /// ISO 8601 allows a large number of date/time formats, with or without
        /// punctuation and optional elements. The format returned by this function
        /// is a complete date and time, with optional punctuation included, the
        /// UTC time zone represented as "Z", and the @tv_usec part included if
        /// and only if it is nonzero, i.e. either
        /// "YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".
        /// 
        /// This corresponds to the Internet date/time format defined by
        /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt),
        /// and to either of the two most-precise formats defined by
        /// the W3C Note
        /// [Date and Time Formats](http://www.w3.org/TR/NOTE-datetime-19980827).
        /// Both of these documents are profiles of ISO 8601.
        /// 
        /// Use g_date_time_format() or g_strdup_printf() if a different
        /// variation of ISO 8601 format is required.
        /// </remarks>
        /// <param name="time">
        /// a #GTimeVal
        /// </param>
        /// <returns>
        /// a newly allocated string containing an ISO 8601 date
        /// </returns>
        [GISharp.Core.Since("2.12")]
        public System.String ToIso8601()
        {
            return default(System.String);
        }
    }

    /// <summary>
    /// #GTimeZone is an opaque structure whose members cannot be accessed
    /// directly.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"TimeZone\" c:type=\"GTimeZone\" version=\"2.26\" glib:type-name=\"GTimeZone\" glib:get-type=\"g_time_zone_get_type\" c:symbol-prefix=\"time_zone\" gs:managed-name=\"TimeZone\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">#GTimeZone is an opaque structure whose members cannot be accessed\ndirectly.</doc>\n  <constructor name=\"new\" c:identifier=\"g_time_zone_new\" version=\"2.26\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a #GTimeZone corresponding to @identifier.\n\n@identifier can either be an RFC3339/ISO 8601 time offset or\nsomething that would pass as a valid value for the `TZ` environment\nvariable (including %NULL).\n\nIn Windows, @identifier can also be the unlocalized name of a time\nzone for standard time, for example \"Pacific Standard Time\".\n\nValid RFC3339 time offsets are `\"Z\"` (for UTC) or\n`\"±hh:mm\"`.  ISO 8601 additionally specifies\n`\"±hhmm\"` and `\"±hh\"`.  Offsets are\ntime values to be added to Coordinated Universal Time (UTC) to get\nthe local time.\n\nIn UNIX, the `TZ` environment variable typically corresponds\nto the name of a file in the zoneinfo database, or string in\n\"std offset [dst [offset],start[/time],end[/time]]\" (POSIX) format.\nThere  are  no spaces in the specification. The name of standard\nand daylight savings time zone must be three or more alphabetic\ncharacters. Offsets are time values to be added to local time to\nget Coordinated Universal Time (UTC) and should be\n`\"[±]hh[[:]mm[:ss]]\"`.  Dates are either\n`\"Jn\"` (Julian day with n between 1 and 365, leap\nyears not counted), `\"n\"` (zero-based Julian day\nwith n between 0 and 365) or `\"Mm.w.d\"` (day d\n(0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day\n0 is a Sunday).  Times are in local wall clock time, the default is\n02:00:00.\n\nIn Windows, the \"tzn[+|–]hh[:mm[:ss]][dzn]\" format is used, but also\naccepts POSIX format.  The Windows format uses US rules for all time\nzones; daylight savings time is 60 minutes behind the standard time\nwith date and time of change taken from Pacific Standard Time.\nOffsets are time values to be added to the local time to get\nCoordinated Universal Time (UTC).\n\ng_time_zone_new_local() calls this function with the value of the\n`TZ` environment variable. This function itself is independent of\nthe value of `TZ`, but if @identifier is %NULL then `/etc/localtime`\nwill be consulted to discover the correct time zone on UNIX and the\nregistry will be consulted or GetTimeZoneInformation() will be used\nto get the local time zone on Windows.\n\nIf intervals are not available, only time zone rules from `TZ`\nenvironment variable or other means, then they will be computed\nfrom year 1900 to 2037.  If the maximum year for the rules is\navailable and it is greater than 2037, then it will followed\ninstead.\n\nSee\n[RFC3339 §5.6](http://tools.ietf.org/html/rfc3339#section-5.6)\nfor a precise definition of valid RFC3339 time offsets\n(the `time-offset` expansion) and ISO 8601 for the\nfull list of valid time offsets.  See\n[The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)\nfor an explanation of the possible\nvalues of the `TZ` environment variable. See\n[Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)\nfor the list of time zones on Windows.\n\nYou should release the return value by calling g_time_zone_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the requested timezone</doc>\n      <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"identifier\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"identifier\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a timezone identifier</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"identifier\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"identifier\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a timezone identifier</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <function name=\"local\" c:identifier=\"g_time_zone_new_local\" version=\"2.26\" gs:managed-name=\"Local\">\n    <doc xml:space=\"preserve\">Creates a #GTimeZone corresponding to local time.  The local time\nzone may change between invocations to this function; for example,\nif the system administrator changes it.\n\nThis is equivalent to calling g_time_zone_new() with the value of\nthe `TZ` environment variable (including the possibility of %NULL).\n\nYou should release the return value by calling g_time_zone_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the local timezone</doc>\n      <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n    </return-value>\n  </function>\n  <function name=\"utc\" c:identifier=\"g_time_zone_new_utc\" version=\"2.26\" gs:managed-name=\"Utc\">\n    <doc xml:space=\"preserve\">Creates a #GTimeZone corresponding to UTC.\n\nThis is equivalent to calling g_time_zone_new() with a value like\n\"Z\", \"UTC\", \"+00\", etc.\n\nYou should release the return value by calling g_time_zone_unref()\nwhen you are done with it.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the universal timezone</doc>\n      <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n    </return-value>\n  </function>\n  <method name=\"adjust_time\" c:identifier=\"g_time_zone_adjust_time\" version=\"2.26\" gs:managed-name=\"AdjustTime\">\n    <doc xml:space=\"preserve\">Finds an interval within @tz that corresponds to the given @time_,\npossibly adjusting @time_ if required to fit into an interval.\nThe meaning of @time_ depends on @type.\n\nThis function is similar to g_time_zone_find_interval(), with the\ndifference that it always succeeds (by making the adjustments\ndescribed below).\n\nIn any of the cases where g_time_zone_find_interval() succeeds then\nthis function returns the same value, without modifying @time_.\n\nThis function may, however, modify @time_ in order to deal with\nnon-existent times.  If the non-existent local @time_ of 02:30 were\nrequested on March 14th 2010 in Toronto then this function would\nadjust @time_ to be 03:00 and return the interval containing the\nadjusted time.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the interval containing @time_, never -1</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"TimeType\" gs:unmanaged-type=\"TimeType\">\n        <doc xml:space=\"preserve\">the #GTimeType of @time_</doc>\n        <type name=\"TimeType\" c:type=\"GTimeType\" gs:managed-name=\"TimeType\" />\n      </parameter>\n      <parameter name=\"time_\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">a pointer to a number of seconds since January 1, 1970</doc>\n        <type name=\"gint64\" c:type=\"gint64*\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"TimeType\" gs:unmanaged-type=\"TimeType\">\n        <doc xml:space=\"preserve\">the #GTimeType of @time_</doc>\n        <type name=\"TimeType\" c:type=\"GTimeType\" gs:managed-name=\"TimeType\" />\n      </parameter>\n      <parameter name=\"time_\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">a pointer to a number of seconds since January 1, 1970</doc>\n        <type name=\"gint64\" c:type=\"gint64*\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"find_interval\" c:identifier=\"g_time_zone_find_interval\" version=\"2.26\" gs:managed-name=\"FindInterval\">\n    <doc xml:space=\"preserve\">Finds an the interval within @tz that corresponds to the given @time_.\nThe meaning of @time_ depends on @type.\n\nIf @type is %G_TIME_TYPE_UNIVERSAL then this function will always\nsucceed (since universal time is monotonic and continuous).\n\nOtherwise @time_ is treated as local time.  The distinction between\n%G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in\nthe case that the given @time_ is ambiguous.  In Toronto, for example,\n01:30 on November 7th 2010 occurred twice (once inside of daylight\nsavings time and the next, an hour later, outside of daylight savings\ntime).  In this case, the different value of @type would result in a\ndifferent interval being returned.\n\nIt is still possible for this function to fail.  In Toronto, for\nexample, 02:00 on March 14th 2010 does not exist (due to the leap\nforward to begin daylight savings time).  -1 is returned in that\ncase.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the interval containing @time_, or -1 in case of failure</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"TimeType\" gs:unmanaged-type=\"TimeType\">\n        <doc xml:space=\"preserve\">the #GTimeType of @time_</doc>\n        <type name=\"TimeType\" c:type=\"GTimeType\" gs:managed-name=\"TimeType\" />\n      </parameter>\n      <parameter name=\"time_\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">a number of seconds since January 1, 1970</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"TimeType\" gs:unmanaged-type=\"TimeType\">\n        <doc xml:space=\"preserve\">the #GTimeType of @time_</doc>\n        <type name=\"TimeType\" c:type=\"GTimeType\" gs:managed-name=\"TimeType\" />\n      </parameter>\n      <parameter name=\"time_\" transfer-ownership=\"none\" gs:managed-name=\"time\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">a number of seconds since January 1, 1970</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_abbreviation\" c:identifier=\"g_time_zone_get_abbreviation\" version=\"2.26\" gs:managed-name=\"GetAbbreviation\">\n    <doc xml:space=\"preserve\">Determines the time zone abbreviation to be used during a particular\n@interval of time in the time zone @tz.\n\nFor example, in Toronto this is currently \"EST\" during the winter\nmonths and \"EDT\" during the summer months when daylight savings time\nis in effect.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the time zone abbreviation, which belongs to @tz</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an interval within the timezone</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an interval within the timezone</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_offset\" c:identifier=\"g_time_zone_get_offset\" version=\"2.26\" gs:managed-name=\"GetOffset\">\n    <doc xml:space=\"preserve\">Determines the offset to UTC in effect during a particular @interval\nof time in the time zone @tz.\n\nThe offset is the number of seconds that you add to UTC time to\narrive at local time for @tz (ie: negative numbers for time zones\nwest of GMT, positive numbers for east).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the number of seconds that should be added to UTC to get the\n         local time in @tz</doc>\n      <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an interval within the timezone</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an interval within the timezone</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"is_dst\" c:identifier=\"g_time_zone_is_dst\" version=\"2.26\" gs:managed-name=\"IsDst\">\n    <doc xml:space=\"preserve\">Determines if daylight savings time is in effect during a particular\n@interval of time in the time zone @tz.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if daylight savings time is in effect</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an interval within the timezone</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">an interval within the timezone</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_time_zone_ref\" version=\"2.26\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count on @tz.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new reference to @tz.</doc>\n      <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref\" c:identifier=\"g_time_zone_unref\" version=\"2.26\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count on @tz.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tz\" transfer-ownership=\"none\" gs:managed-name=\"tz\" gs:managed-type=\"TimeZone\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTimeZone</doc>\n        <type name=\"TimeZone\" c:type=\"GTimeZone*\" gs:managed-name=\"TimeZone\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    [GISharp.Core.Since("2.26")]
    public partial class TimeZone : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.TimeZone>
    {
        public TimeZone(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a #GTimeZone corresponding to @identifier.
        /// </summary>
        /// <remarks>
        /// @identifier can either be an RFC3339/ISO 8601 time offset or
        /// something that would pass as a valid value for the `TZ` environment
        /// variable (including %NULL).
        /// 
        /// In Windows, @identifier can also be the unlocalized name of a time
        /// zone for standard time, for example "Pacific Standard Time".
        /// 
        /// Valid RFC3339 time offsets are `"Z"` (for UTC) or
        /// `"±hh:mm"`.  ISO 8601 additionally specifies
        /// `"±hhmm"` and `"±hh"`.  Offsets are
        /// time values to be added to Coordinated Universal Time (UTC) to get
        /// the local time.
        /// 
        /// In UNIX, the `TZ` environment variable typically corresponds
        /// to the name of a file in the zoneinfo database, or string in
        /// "std offset [dst [offset],start[/time],end[/time]]" (POSIX) format.
        /// There  are  no spaces in the specification. The name of standard
        /// and daylight savings time zone must be three or more alphabetic
        /// characters. Offsets are time values to be added to local time to
        /// get Coordinated Universal Time (UTC) and should be
        /// `"[±]hh[[:]mm[:ss]]"`.  Dates are either
        /// `"Jn"` (Julian day with n between 1 and 365, leap
        /// years not counted), `"n"` (zero-based Julian day
        /// with n between 0 and 365) or `"Mm.w.d"` (day d
        /// (0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
        /// 0 is a Sunday).  Times are in local wall clock time, the default is
        /// 02:00:00.
        /// 
        /// In Windows, the "tzn[+|–]hh[:mm[:ss]][dzn]" format is used, but also
        /// accepts POSIX format.  The Windows format uses US rules for all time
        /// zones; daylight savings time is 60 minutes behind the standard time
        /// with date and time of change taken from Pacific Standard Time.
        /// Offsets are time values to be added to the local time to get
        /// Coordinated Universal Time (UTC).
        /// 
        /// g_time_zone_new_local() calls this function with the value of the
        /// `TZ` environment variable. This function itself is independent of
        /// the value of `TZ`, but if @identifier is %NULL then `/etc/localtime`
        /// will be consulted to discover the correct time zone on UNIX and the
        /// registry will be consulted or GetTimeZoneInformation() will be used
        /// to get the local time zone on Windows.
        /// 
        /// If intervals are not available, only time zone rules from `TZ`
        /// environment variable or other means, then they will be computed
        /// from year 1900 to 2037.  If the maximum year for the rules is
        /// available and it is greater than 2037, then it will followed
        /// instead.
        /// 
        /// See
        /// [RFC3339 §5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
        /// for a precise definition of valid RFC3339 time offsets
        /// (the `time-offset` expansion) and ISO 8601 for the
        /// full list of valid time offsets.  See
        /// [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
        /// for an explanation of the possible
        /// values of the `TZ` environment variable. See
        /// [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
        /// for the list of time zones on Windows.
        /// 
        /// You should release the return value by calling g_time_zone_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="identifier">
        /// a timezone identifier
        /// </param>
        /// <returns>
        /// the requested timezone
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public TimeZone(
            System.String identifier) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a #GTimeZone corresponding to @identifier.
        /// </summary>
        /// <remarks>
        /// @identifier can either be an RFC3339/ISO 8601 time offset or
        /// something that would pass as a valid value for the `TZ` environment
        /// variable (including %NULL).
        /// 
        /// In Windows, @identifier can also be the unlocalized name of a time
        /// zone for standard time, for example "Pacific Standard Time".
        /// 
        /// Valid RFC3339 time offsets are `"Z"` (for UTC) or
        /// `"±hh:mm"`.  ISO 8601 additionally specifies
        /// `"±hhmm"` and `"±hh"`.  Offsets are
        /// time values to be added to Coordinated Universal Time (UTC) to get
        /// the local time.
        /// 
        /// In UNIX, the `TZ` environment variable typically corresponds
        /// to the name of a file in the zoneinfo database, or string in
        /// "std offset [dst [offset],start[/time],end[/time]]" (POSIX) format.
        /// There  are  no spaces in the specification. The name of standard
        /// and daylight savings time zone must be three or more alphabetic
        /// characters. Offsets are time values to be added to local time to
        /// get Coordinated Universal Time (UTC) and should be
        /// `"[±]hh[[:]mm[:ss]]"`.  Dates are either
        /// `"Jn"` (Julian day with n between 1 and 365, leap
        /// years not counted), `"n"` (zero-based Julian day
        /// with n between 0 and 365) or `"Mm.w.d"` (day d
        /// (0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
        /// 0 is a Sunday).  Times are in local wall clock time, the default is
        /// 02:00:00.
        /// 
        /// In Windows, the "tzn[+|–]hh[:mm[:ss]][dzn]" format is used, but also
        /// accepts POSIX format.  The Windows format uses US rules for all time
        /// zones; daylight savings time is 60 minutes behind the standard time
        /// with date and time of change taken from Pacific Standard Time.
        /// Offsets are time values to be added to the local time to get
        /// Coordinated Universal Time (UTC).
        /// 
        /// g_time_zone_new_local() calls this function with the value of the
        /// `TZ` environment variable. This function itself is independent of
        /// the value of `TZ`, but if @identifier is %NULL then `/etc/localtime`
        /// will be consulted to discover the correct time zone on UNIX and the
        /// registry will be consulted or GetTimeZoneInformation() will be used
        /// to get the local time zone on Windows.
        /// 
        /// If intervals are not available, only time zone rules from `TZ`
        /// environment variable or other means, then they will be computed
        /// from year 1900 to 2037.  If the maximum year for the rules is
        /// available and it is greater than 2037, then it will followed
        /// instead.
        /// 
        /// See
        /// [RFC3339 §5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
        /// for a precise definition of valid RFC3339 time offsets
        /// (the `time-offset` expansion) and ISO 8601 for the
        /// full list of valid time offsets.  See
        /// [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
        /// for an explanation of the possible
        /// values of the `TZ` environment variable. See
        /// [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
        /// for the list of time zones on Windows.
        /// 
        /// You should release the return value by calling g_time_zone_unref()
        /// when you are done with it.
        /// </remarks>
        /// <param name="identifier">
        /// a timezone identifier
        /// </param>
        /// <returns>
        /// the requested timezone
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_time_zone_new(
            [System.Runtime.InteropServices.In()] System.IntPtr identifier);

        /// <summary>
        /// Creates a #GTimeZone corresponding to local time.  The local time
        /// zone may change between invocations to this function; for example,
        /// if the system administrator changes it.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_time_zone_new() with the value of
        /// the `TZ` environment variable (including the possibility of %NULL).
        /// 
        /// You should release the return value by calling g_time_zone_unref()
        /// when you are done with it.
        /// </remarks>
        /// <returns>
        /// the local timezone
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_time_zone_new_local();

        /// <summary>
        /// Creates a #GTimeZone corresponding to local time.  The local time
        /// zone may change between invocations to this function; for example,
        /// if the system administrator changes it.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_time_zone_new() with the value of
        /// the `TZ` environment variable (including the possibility of %NULL).
        /// 
        /// You should release the return value by calling g_time_zone_unref()
        /// when you are done with it.
        /// </remarks>
        /// <returns>
        /// the local timezone
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.TimeZone Local()
        {
            return default(GISharp.GLib.TimeZone);
        }

        /// <summary>
        /// Creates a #GTimeZone corresponding to UTC.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_time_zone_new() with a value like
        /// "Z", "UTC", "+00", etc.
        /// 
        /// You should release the return value by calling g_time_zone_unref()
        /// when you are done with it.
        /// </remarks>
        /// <returns>
        /// the universal timezone
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_time_zone_new_utc();

        /// <summary>
        /// Creates a #GTimeZone corresponding to UTC.
        /// </summary>
        /// <remarks>
        /// This is equivalent to calling g_time_zone_new() with a value like
        /// "Z", "UTC", "+00", etc.
        /// 
        /// You should release the return value by calling g_time_zone_unref()
        /// when you are done with it.
        /// </remarks>
        /// <returns>
        /// the universal timezone
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public static GISharp.GLib.TimeZone Utc()
        {
            return default(GISharp.GLib.TimeZone);
        }

        /// <summary>
        /// Finds an interval within @tz that corresponds to the given @time_,
        /// possibly adjusting @time_ if required to fit into an interval.
        /// The meaning of @time_ depends on @type.
        /// </summary>
        /// <remarks>
        /// This function is similar to g_time_zone_find_interval(), with the
        /// difference that it always succeeds (by making the adjustments
        /// described below).
        /// 
        /// In any of the cases where g_time_zone_find_interval() succeeds then
        /// this function returns the same value, without modifying @time_.
        /// 
        /// This function may, however, modify @time_ in order to deal with
        /// non-existent times.  If the non-existent local @time_ of 02:30 were
        /// requested on March 14th 2010 in Toronto then this function would
        /// adjust @time_ to be 03:00 and return the interval containing the
        /// adjusted time.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="type">
        /// the #GTimeType of @time_
        /// </param>
        /// <param name="time">
        /// a pointer to a number of seconds since January 1, 1970
        /// </param>
        /// <returns>
        /// the interval containing @time_, never -1
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_time_zone_adjust_time(
            [System.Runtime.InteropServices.In()] System.IntPtr tz,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeType type,
            [System.Runtime.InteropServices.In()] System.Int64 time);

        /// <summary>
        /// Finds an interval within @tz that corresponds to the given @time_,
        /// possibly adjusting @time_ if required to fit into an interval.
        /// The meaning of @time_ depends on @type.
        /// </summary>
        /// <remarks>
        /// This function is similar to g_time_zone_find_interval(), with the
        /// difference that it always succeeds (by making the adjustments
        /// described below).
        /// 
        /// In any of the cases where g_time_zone_find_interval() succeeds then
        /// this function returns the same value, without modifying @time_.
        /// 
        /// This function may, however, modify @time_ in order to deal with
        /// non-existent times.  If the non-existent local @time_ of 02:30 were
        /// requested on March 14th 2010 in Toronto then this function would
        /// adjust @time_ to be 03:00 and return the interval containing the
        /// adjusted time.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="type">
        /// the #GTimeType of @time_
        /// </param>
        /// <param name="time">
        /// a pointer to a number of seconds since January 1, 1970
        /// </param>
        /// <returns>
        /// the interval containing @time_, never -1
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 AdjustTime(
            GISharp.GLib.TimeType type,
            System.Int64 time)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Finds an the interval within @tz that corresponds to the given @time_.
        /// The meaning of @time_ depends on @type.
        /// </summary>
        /// <remarks>
        /// If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
        /// succeed (since universal time is monotonic and continuous).
        /// 
        /// Otherwise @time_ is treated as local time.  The distinction between
        /// %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
        /// the case that the given @time_ is ambiguous.  In Toronto, for example,
        /// 01:30 on November 7th 2010 occurred twice (once inside of daylight
        /// savings time and the next, an hour later, outside of daylight savings
        /// time).  In this case, the different value of @type would result in a
        /// different interval being returned.
        /// 
        /// It is still possible for this function to fail.  In Toronto, for
        /// example, 02:00 on March 14th 2010 does not exist (due to the leap
        /// forward to begin daylight savings time).  -1 is returned in that
        /// case.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="type">
        /// the #GTimeType of @time_
        /// </param>
        /// <param name="time">
        /// a number of seconds since January 1, 1970
        /// </param>
        /// <returns>
        /// the interval containing @time_, or -1 in case of failure
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_time_zone_find_interval(
            [System.Runtime.InteropServices.In()] System.IntPtr tz,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TimeType type,
            [System.Runtime.InteropServices.In()] System.Int64 time);

        /// <summary>
        /// Finds an the interval within @tz that corresponds to the given @time_.
        /// The meaning of @time_ depends on @type.
        /// </summary>
        /// <remarks>
        /// If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
        /// succeed (since universal time is monotonic and continuous).
        /// 
        /// Otherwise @time_ is treated as local time.  The distinction between
        /// %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
        /// the case that the given @time_ is ambiguous.  In Toronto, for example,
        /// 01:30 on November 7th 2010 occurred twice (once inside of daylight
        /// savings time and the next, an hour later, outside of daylight savings
        /// time).  In this case, the different value of @type would result in a
        /// different interval being returned.
        /// 
        /// It is still possible for this function to fail.  In Toronto, for
        /// example, 02:00 on March 14th 2010 does not exist (due to the leap
        /// forward to begin daylight savings time).  -1 is returned in that
        /// case.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="type">
        /// the #GTimeType of @time_
        /// </param>
        /// <param name="time">
        /// a number of seconds since January 1, 1970
        /// </param>
        /// <returns>
        /// the interval containing @time_, or -1 in case of failure
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 FindInterval(
            GISharp.GLib.TimeType type,
            System.Int64 time)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Determines the time zone abbreviation to be used during a particular
        /// @interval of time in the time zone @tz.
        /// </summary>
        /// <remarks>
        /// For example, in Toronto this is currently "EST" during the winter
        /// months and "EDT" during the summer months when daylight savings time
        /// is in effect.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="interval">
        /// an interval within the timezone
        /// </param>
        /// <returns>
        /// the time zone abbreviation, which belongs to @tz
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_time_zone_get_abbreviation(
            [System.Runtime.InteropServices.In()] System.IntPtr tz,
            [System.Runtime.InteropServices.In()] System.Int32 interval);

        /// <summary>
        /// Determines the time zone abbreviation to be used during a particular
        /// @interval of time in the time zone @tz.
        /// </summary>
        /// <remarks>
        /// For example, in Toronto this is currently "EST" during the winter
        /// months and "EDT" during the summer months when daylight savings time
        /// is in effect.
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="interval">
        /// an interval within the timezone
        /// </param>
        /// <returns>
        /// the time zone abbreviation, which belongs to @tz
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.String GetAbbreviation(
            System.Int32 interval)
        {
            return default(System.String);
        }

        /// <summary>
        /// Determines the offset to UTC in effect during a particular @interval
        /// of time in the time zone @tz.
        /// </summary>
        /// <remarks>
        /// The offset is the number of seconds that you add to UTC time to
        /// arrive at local time for @tz (ie: negative numbers for time zones
        /// west of GMT, positive numbers for east).
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="interval">
        /// an interval within the timezone
        /// </param>
        /// <returns>
        /// the number of seconds that should be added to UTC to get the
        ///          local time in @tz
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_time_zone_get_offset(
            [System.Runtime.InteropServices.In()] System.IntPtr tz,
            [System.Runtime.InteropServices.In()] System.Int32 interval);

        /// <summary>
        /// Determines the offset to UTC in effect during a particular @interval
        /// of time in the time zone @tz.
        /// </summary>
        /// <remarks>
        /// The offset is the number of seconds that you add to UTC time to
        /// arrive at local time for @tz (ie: negative numbers for time zones
        /// west of GMT, positive numbers for east).
        /// </remarks>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="interval">
        /// an interval within the timezone
        /// </param>
        /// <returns>
        /// the number of seconds that should be added to UTC to get the
        ///          local time in @tz
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 GetOffset(
            System.Int32 interval)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Determines if daylight savings time is in effect during a particular
        /// @interval of time in the time zone @tz.
        /// </summary>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="interval">
        /// an interval within the timezone
        /// </param>
        /// <returns>
        /// %TRUE if daylight savings time is in effect
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Boolean g_time_zone_is_dst(
            [System.Runtime.InteropServices.In()] System.IntPtr tz,
            [System.Runtime.InteropServices.In()] System.Int32 interval);

        /// <summary>
        /// Determines if daylight savings time is in effect during a particular
        /// @interval of time in the time zone @tz.
        /// </summary>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <param name="interval">
        /// an interval within the timezone
        /// </param>
        /// <returns>
        /// %TRUE if daylight savings time is in effect
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Boolean IsDst(
            System.Int32 interval)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Increases the reference count on @tz.
        /// </summary>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <returns>
        /// a new reference to @tz.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_time_zone_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr tz);

        /// <summary>
        /// Increases the reference count on @tz.
        /// </summary>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        /// <returns>
        /// a new reference to @tz.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Decreases the reference count on @tz.
        /// </summary>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern void g_time_zone_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr tz);

        /// <summary>
        /// Decreases the reference count on @tz.
        /// </summary>
        /// <param name="tz">
        /// a #GTimeZone
        /// </param>
        [GISharp.Core.Since("2.26")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// The type of functions which are used to translate user-visible
    /// strings, for &lt;option&gt;--help&lt;/option&gt; output.
    /// </summary>
    /// <param name="str">
    /// the untranslated string
    /// </param>
    /// <param name="data">
    /// user data specified when installing the function, e.g.
    ///  in g_option_group_set_translate_func()
    /// </param>
    /// <returns>
    /// a translation of the string for the current locale.
    ///  The returned string is owned by GLib and must not be freed.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"TranslateFunc\" c:type=\"GTranslateFunc\" gs:managed-name=\"TranslateFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The type of functions which are used to translate user-visible\nstrings, for &lt;option&gt;--help&lt;/option&gt; output.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">a translation of the string for the current locale.\n The returned string is owned by GLib and must not be freed.</doc>\n    <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"str\" transfer-ownership=\"none\" gs:managed-name=\"str\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the untranslated string</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data specified when installing the function, e.g.\n in g_option_group_set_translate_func()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"str\" transfer-ownership=\"none\" gs:managed-name=\"str\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the untranslated string</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data specified when installing the function, e.g.\n in g_option_group_set_translate_func()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.IntPtr TranslateFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr str,
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// The type of functions which are used to translate user-visible
    /// strings, for &lt;option&gt;--help&lt;/option&gt; output.
    /// </summary>
    /// <param name="str">
    /// the untranslated string
    /// </param>
    /// <param name="data">
    /// user data specified when installing the function, e.g.
    ///  in g_option_group_set_translate_func()
    /// </param>
    /// <returns>
    /// a translation of the string for the current locale.
    ///  The returned string is owned by GLib and must not be freed.
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"TranslateFunc\" c:type=\"GTranslateFunc\" gs:managed-name=\"TranslateFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The type of functions which are used to translate user-visible\nstrings, for &lt;option&gt;--help&lt;/option&gt; output.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n    <doc xml:space=\"preserve\">a translation of the string for the current locale.\n The returned string is owned by GLib and must not be freed.</doc>\n    <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"str\" transfer-ownership=\"none\" gs:managed-name=\"str\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the untranslated string</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data specified when installing the function, e.g.\n in g_option_group_set_translate_func()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"str\" transfer-ownership=\"none\" gs:managed-name=\"str\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the untranslated string</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data specified when installing the function, e.g.\n in g_option_group_set_translate_func()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate System.String TranslateFunc(
        System.String str,
        System.IntPtr data);

    /// <summary>
    /// Specifies which nodes are visited during several of the tree
    /// functions, including g_node_traverse() and g_node_find().
    /// </summary>
    [GISharp.Core.GirXml("<bitfield name=\"TraverseFlags\" c:type=\"GTraverseFlags\" gs:managed-name=\"TraverseFlags\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies which nodes are visited during several of the tree\nfunctions, including g_node_traverse() and g_node_find().</doc>\n  <member name=\"leaves\" value=\"1\" c:identifier=\"G_TRAVERSE_LEAVES\" gs:managed-name=\"Leaves\">\n    <doc xml:space=\"preserve\">only leaf nodes should be visited. This name has\n                    been introduced in 2.6, for older version use\n                    %G_TRAVERSE_LEAFS.</doc>\n  </member>\n  <member name=\"non_leaves\" value=\"2\" c:identifier=\"G_TRAVERSE_NON_LEAVES\" gs:managed-name=\"NonLeaves\">\n    <doc xml:space=\"preserve\">only non-leaf nodes should be visited. This\n                        name has been introduced in 2.6, for older\n                        version use %G_TRAVERSE_NON_LEAFS.</doc>\n  </member>\n  <member name=\"all\" value=\"3\" c:identifier=\"G_TRAVERSE_ALL\" gs:managed-name=\"All\">\n    <doc xml:space=\"preserve\">all nodes should be visited.</doc>\n  </member>\n  <member name=\"mask\" value=\"3\" c:identifier=\"G_TRAVERSE_MASK\" gs:managed-name=\"Mask\">\n    <doc xml:space=\"preserve\">a mask of all traverse flags.</doc>\n  </member>\n  <member name=\"leafs\" value=\"1\" c:identifier=\"G_TRAVERSE_LEAFS\" gs:managed-name=\"Leafs\">\n    <doc xml:space=\"preserve\">identical to %G_TRAVERSE_LEAVES.</doc>\n  </member>\n  <member name=\"non_leafs\" value=\"2\" c:identifier=\"G_TRAVERSE_NON_LEAFS\" gs:managed-name=\"NonLeafs\">\n    <doc xml:space=\"preserve\">identical to %G_TRAVERSE_NON_LEAVES.</doc>\n  </member>\n</bitfield>")]
    [System.Flags()]
    public enum TraverseFlags
    {
        /// <summary>
        /// only leaf nodes should be visited. This name has
        ///                     been introduced in 2.6, for older version use
        ///                     %G_TRAVERSE_LEAFS.
        /// </summary>
        Leaves = 1,
        /// <summary>
        /// only non-leaf nodes should be visited. This
        ///                         name has been introduced in 2.6, for older
        ///                         version use %G_TRAVERSE_NON_LEAFS.
        /// </summary>
        NonLeaves = 2,
        /// <summary>
        /// all nodes should be visited.
        /// </summary>
        All = 3,
        /// <summary>
        /// a mask of all traverse flags.
        /// </summary>
        Mask = 3,
        /// <summary>
        /// identical to %G_TRAVERSE_LEAVES.
        /// </summary>
        Leafs = 1,
        /// <summary>
        /// identical to %G_TRAVERSE_NON_LEAVES.
        /// </summary>
        NonLeafs = 2
    }

    /// <summary>
    /// Specifies the type of function passed to g_tree_traverse(). It is
    /// passed the key and value of each node, together with the @user_data
    /// parameter passed to g_tree_traverse(). If the function returns
    /// %TRUE, the traversal is stopped.
    /// </summary>
    /// <param name="key">
    /// a key of a #GTree node
    /// </param>
    /// <param name="value">
    /// the value corresponding to the key
    /// </param>
    /// <param name="data">
    /// user data passed to g_tree_traverse()
    /// </param>
    /// <returns>
    /// %TRUE to stop the traversal
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"TraverseFunc\" c:type=\"GTraverseFunc\" gs:managed-name=\"TraverseFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_tree_traverse(). It is\npassed the key and value of each node, together with the @user_data\nparameter passed to g_tree_traverse(). If the function returns\n%TRUE, the traversal is stopped.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">%TRUE to stop the traversal</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a key of a #GTree node</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_tree_traverse()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a key of a #GTree node</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_tree_traverse()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate System.Boolean TraverseFuncNative(
        [System.Runtime.InteropServices.In()] System.IntPtr key,
        [System.Runtime.InteropServices.In()] System.IntPtr value,
        [System.Runtime.InteropServices.In()] System.IntPtr data);

    /// <summary>
    /// Specifies the type of function passed to g_tree_traverse(). It is
    /// passed the key and value of each node, together with the @user_data
    /// parameter passed to g_tree_traverse(). If the function returns
    /// %TRUE, the traversal is stopped.
    /// </summary>
    /// <param name="key">
    /// a key of a #GTree node
    /// </param>
    /// <param name="value">
    /// the value corresponding to the key
    /// </param>
    /// <param name="data">
    /// user data passed to g_tree_traverse()
    /// </param>
    /// <returns>
    /// %TRUE to stop the traversal
    /// </returns>
    [GISharp.Core.GirXml("<callback name=\"TraverseFunc\" c:type=\"GTraverseFunc\" gs:managed-name=\"TraverseFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of function passed to g_tree_traverse(). It is\npassed the key and value of each node, together with the @user_data\nparameter passed to g_tree_traverse(). If the function returns\n%TRUE, the traversal is stopped.</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n    <doc xml:space=\"preserve\">%TRUE to stop the traversal</doc>\n    <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n  </return-value>\n  <parameters>\n    <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a key of a #GTree node</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_tree_traverse()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </parameters>\n  <gs:managed-parameters>\n    <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a key of a #GTree node</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n    <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">user data passed to g_tree_traverse()</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </parameter>\n  </gs:managed-parameters>\n</callback>")]
    public delegate System.Boolean TraverseFunc(
        System.IntPtr key,
        System.IntPtr value,
        System.IntPtr data);

    /// <summary>
    /// Specifies the type of traveral performed by g_tree_traverse(),
    /// g_node_traverse() and g_node_find(). The different orders are
    /// illustrated here:
    /// - In order: A, B, C, D, E, F, G, H, I
    ///   ![](Sorted_binary_tree_inorder.svg)
    /// - Pre order: F, B, A, D, C, E, G, I, H
    ///   ![](Sorted_binary_tree_preorder.svg)
    /// - Post order: A, C, E, D, B, H, I, G, F
    ///   ![](Sorted_binary_tree_postorder.svg)
    /// - Level order: F, B, G, A, D, I, C, E, H
    ///   ![](Sorted_binary_tree_breadth-first_traversal.svg)
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Specifies the type of traveral performed by g_tree_traverse(),\ng_node_traverse() and g_node_find(). The different orders are\nillustrated here:\n- In order: A, B, C, D, E, F, G, H, I\n  ![](Sorted_binary_tree_inorder.svg)\n- Pre order: F, B, A, D, C, E, G, I, H\n  ![](Sorted_binary_tree_preorder.svg)\n- Post order: A, C, E, D, B, H, I, G, F\n  ![](Sorted_binary_tree_postorder.svg)\n- Level order: F, B, G, A, D, I, C, E, H\n  ![](Sorted_binary_tree_breadth-first_traversal.svg)</doc>\n  <member name=\"in_order\" value=\"0\" c:identifier=\"G_IN_ORDER\" gs:managed-name=\"InOrder\">\n    <doc xml:space=\"preserve\">vists a node's left child first, then the node itself,\n             then its right child. This is the one to use if you\n             want the output sorted according to the compare\n             function.</doc>\n  </member>\n  <member name=\"pre_order\" value=\"1\" c:identifier=\"G_PRE_ORDER\" gs:managed-name=\"PreOrder\">\n    <doc xml:space=\"preserve\">visits a node, then its children.</doc>\n  </member>\n  <member name=\"post_order\" value=\"2\" c:identifier=\"G_POST_ORDER\" gs:managed-name=\"PostOrder\">\n    <doc xml:space=\"preserve\">visits the node's children, then the node itself.</doc>\n  </member>\n  <member name=\"level_order\" value=\"3\" c:identifier=\"G_LEVEL_ORDER\" gs:managed-name=\"LevelOrder\">\n    <doc xml:space=\"preserve\">is not implemented for\n             [balanced binary trees][glib-Balanced-Binary-Trees].\n             For [n-ary trees][glib-N-ary-Trees], it\n             vists the root node first, then its children, then\n             its grandchildren, and so on. Note that this is less\n             efficient than the other orders.</doc>\n  </member>\n</enumeration>")]
    public enum TraverseType
    {
        /// <summary>
        /// vists a node's left child first, then the node itself,
        ///              then its right child. This is the one to use if you
        ///              want the output sorted according to the compare
        ///              function.
        /// </summary>
        InOrder = 0,
        /// <summary>
        /// visits a node, then its children.
        /// </summary>
        PreOrder = 1,
        /// <summary>
        /// visits the node's children, then the node itself.
        /// </summary>
        PostOrder = 2,
        /// <summary>
        /// is not implemented for
        ///              [balanced binary trees][glib-Balanced-Binary-Trees].
        ///              For [n-ary trees][glib-N-ary-Trees], it
        ///              vists the root node first, then its children, then
        ///              its grandchildren, and so on. Note that this is less
        ///              efficient than the other orders.
        /// </summary>
        LevelOrder = 3
    }

    /// <summary>
    /// The GTree struct is an opaque data structure representing a
    /// [balanced binary tree][glib-Balanced-Binary-Trees]. It should be
    /// accessed only by using the following functions.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"Tree\" c:type=\"GTree\" disguised=\"1\" gs:managed-name=\"Tree\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The GTree struct is an opaque data structure representing a\n[balanced binary tree][glib-Balanced-Binary-Trees]. It should be\naccessed only by using the following functions.</doc>\n  <method name=\"destroy\" c:identifier=\"g_tree_destroy\" gs:managed-name=\"Destroy\">\n    <doc xml:space=\"preserve\">Removes all keys and values from the #GTree and decreases its\nreference count by one. If keys and/or values are dynamically\nallocated, you should either free them first or create the #GTree\nusing g_tree_new_full(). In the latter case the destroy functions\nyou supplied will be called on all keys and values before destroying\nthe #GTree.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"foreach\" c:identifier=\"g_tree_foreach\" introspectable=\"0\" gs:managed-name=\"Foreach\">\n    <doc xml:space=\"preserve\">Calls the given function for each of the key/value pairs in the #GTree.\nThe function is passed the key and value of each pair, and the given\n@data parameter. The tree is traversed in sorted order.\n\nThe tree may not be modified while iterating over it (you can't\nadd/remove items). To remove all items matching a predicate, you need\nto add each item to a list in your #GTraverseFunc as you walk over\nthe tree, then walk the list and remove each item.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"func\" gs:managed-type=\"TraverseFunc\" gs:unmanaged-type=\"TraverseFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each node visited.\n    If this function returns %TRUE, the traversal is stopped.</doc>\n        <type name=\"TraverseFunc\" c:type=\"GTraverseFunc\" gs:managed-name=\"TraverseFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"func\" gs:managed-type=\"TraverseFunc\" gs:unmanaged-type=\"TraverseFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each node visited.\n    If this function returns %TRUE, the traversal is stopped.</doc>\n        <type name=\"TraverseFunc\" c:type=\"GTraverseFunc\" gs:managed-name=\"TraverseFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"height\" c:identifier=\"g_tree_height\" gs:managed-name=\"Height\">\n    <doc xml:space=\"preserve\">Gets the height of a #GTree.\n\nIf the #GTree contains no nodes, the height is 0.\nIf the #GTree contains only one root node the height is 1.\nIf the root node has children the height is 2, etc.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the height of @tree</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"insert\" c:identifier=\"g_tree_insert\" gs:managed-name=\"Insert\">\n    <doc xml:space=\"preserve\">Inserts a key/value pair into a #GTree.\n\nIf the given key already exists in the #GTree its corresponding value\nis set to the new value. If you supplied a @value_destroy_func when\ncreating the #GTree, the old value is freed using that function. If\nyou supplied a @key_destroy_func when creating the #GTree, the passed\nkey is freed using that function.\n\nThe tree is automatically 'balanced' as new key/value pairs are added,\nso that the distance from the root to every leaf is as small as possible.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"lookup\" c:identifier=\"g_tree_lookup\" introspectable=\"0\" gs:managed-name=\"Lookup\">\n    <doc xml:space=\"preserve\">Gets the value corresponding to the given key. Since a #GTree is\nautomatically balanced as key/value pairs are added, key lookup\nis O(log n) (where n is the number of key/value pairs in the tree).</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value corresponding to the key, or %NULL\n    if the key was not found</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to look up</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to look up</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"lookup_extended\" c:identifier=\"g_tree_lookup_extended\" gs:managed-name=\"LookupExtended\">\n    <doc xml:space=\"preserve\">Looks up a key in the #GTree, returning the original key and the\nassociated value. This is useful if you need to free the memory\nallocated for the original key, for example before calling\ng_tree_remove().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the key was found in the #GTree</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"lookup_key\" transfer-ownership=\"none\" gs:managed-name=\"lookupKey\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to look up</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"orig_key\" transfer-ownership=\"none\" gs:managed-name=\"origKey\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">returns the original key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">returns the value associated with the key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"lookup_key\" transfer-ownership=\"none\" gs:managed-name=\"lookupKey\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to look up</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"orig_key\" transfer-ownership=\"none\" gs:managed-name=\"origKey\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">returns the original key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">returns the value associated with the key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer*\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"nnodes\" c:identifier=\"g_tree_nnodes\" gs:managed-name=\"Nnodes\">\n    <doc xml:space=\"preserve\">Gets the number of nodes in a #GTree.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">the number of nodes in @tree</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"ref\" c:identifier=\"g_tree_ref\" version=\"2.22\" introspectable=\"0\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increments the reference count of @tree by one.\n\nIt is safe to call this function from any thread.</doc>\n    <return-value skip=\"1\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the passed in #GTree</doc>\n      <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove\" c:identifier=\"g_tree_remove\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes a key/value pair from a #GTree.\n\nIf the #GTree was created using g_tree_new_full(), the key and value\nare freed using the supplied destroy functions, otherwise you have to\nmake sure that any dynamically allocated values are freed yourself.\nIf the key does not exist in the #GTree, the function does nothing.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the key was found (prior to 2.8, this function\n    returned nothing)</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"replace\" c:identifier=\"g_tree_replace\" gs:managed-name=\"Replace\">\n    <doc xml:space=\"preserve\">Inserts a new key and value into a #GTree similar to g_tree_insert().\nThe difference is that if the key already exists in the #GTree, it gets\nreplaced by the new key. If you supplied a @value_destroy_func when\ncreating the #GTree, the old value is freed using that function. If you\nsupplied a @key_destroy_func when creating the #GTree, the old key is\nfreed using that function.\n\nThe tree is automatically 'balanced' as new key/value pairs are added,\nso that the distance from the root to every leaf is as small as possible.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to insert</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value corresponding to the key</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"search\" c:identifier=\"g_tree_search\" introspectable=\"0\" gs:managed-name=\"Search\">\n    <doc xml:space=\"preserve\">Searches a #GTree using @search_func.\n\nThe @search_func is called with a pointer to the key of a key/value\npair in the tree, and the passed in @user_data. If @search_func returns\n0 for a key/value pair, then the corresponding value is returned as\nthe result of g_tree_search(). If @search_func returns -1, searching\nwill proceed among the key/value pairs that have a smaller key; if\n@search_func returns 1, searching will proceed among the key/value\npairs that have a larger key.</doc>\n    <return-value gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value corresponding to the found key, or %NULL\n    if the key was not found</doc>\n      <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"search_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"searchFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">a function used to search the #GTree</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data passed as the second argument to @search_func</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"search_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"searchFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">a function used to search the #GTree</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"steal\" c:identifier=\"g_tree_steal\" gs:managed-name=\"Steal\">\n    <doc xml:space=\"preserve\">Removes a key and its associated value from a #GTree without calling\nthe key and value destroy functions.\n\nIf the key does not exist in the #GTree, the function does nothing.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the key was found (prior to 2.8, this function\n    returned nothing)</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to remove</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"traverse\" c:identifier=\"g_tree_traverse\" introspectable=\"0\" deprecated=\"1\" deprecated-version=\"2.2\" gs:managed-name=\"Traverse\">\n    <doc xml:space=\"preserve\">Calls the given function for each node in the #GTree.</doc>\n    <doc-deprecated xml:space=\"preserve\">The order of a balanced tree is somewhat arbitrary.\n    If you just want to visit all nodes in sorted order, use\n    g_tree_foreach() instead. If you really need to visit nodes in\n    a different order, consider using an [n-ary tree][glib-N-ary-Trees].</doc-deprecated>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n      <parameter name=\"traverse_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"traverseFunc\" gs:managed-type=\"TraverseFunc\" gs:unmanaged-type=\"TraverseFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each node visited. If this\n  function returns %TRUE, the traversal is stopped.</doc>\n        <type name=\"TraverseFunc\" c:type=\"GTraverseFunc\" gs:managed-name=\"TraverseFunc\" />\n      </parameter>\n      <parameter name=\"traverse_type\" transfer-ownership=\"none\" gs:managed-name=\"traverseType\" gs:managed-type=\"TraverseType\" gs:unmanaged-type=\"TraverseType\">\n        <doc xml:space=\"preserve\">the order in which nodes are visited, one of %G_IN_ORDER,\n  %G_PRE_ORDER and %G_POST_ORDER</doc>\n        <type name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">user data to pass to the function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"traverse_func\" transfer-ownership=\"none\" closure=\"2\" gs:managed-name=\"traverseFunc\" gs:managed-type=\"TraverseFunc\" gs:unmanaged-type=\"TraverseFuncNative\">\n        <doc xml:space=\"preserve\">the function to call for each node visited. If this\n  function returns %TRUE, the traversal is stopped.</doc>\n        <type name=\"TraverseFunc\" c:type=\"GTraverseFunc\" gs:managed-name=\"TraverseFunc\" />\n      </parameter>\n      <parameter name=\"traverse_type\" transfer-ownership=\"none\" gs:managed-name=\"traverseType\" gs:managed-type=\"TraverseType\" gs:unmanaged-type=\"TraverseType\">\n        <doc xml:space=\"preserve\">the order in which nodes are visited, one of %G_IN_ORDER,\n  %G_PRE_ORDER and %G_POST_ORDER</doc>\n        <type name=\"TraverseType\" c:type=\"GTraverseType\" gs:managed-name=\"TraverseType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_tree_unref\" version=\"2.22\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decrements the reference count of @tree by one.\nIf the reference count drops to 0, all keys and values will\nbe destroyed (if destroy functions were specified) and all\nmemory allocated by @tree will be released.\n\nIt is safe to call this function from any thread.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"tree\" transfer-ownership=\"none\" gs:managed-name=\"tree\" gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GTree</doc>\n        <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"new\" c:identifier=\"g_tree_new\" introspectable=\"0\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GTree.</doc>\n    <return-value gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated #GTree</doc>\n      <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"key_compare_func\" transfer-ownership=\"none\" gs:managed-name=\"keyCompareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to order the nodes in the #GTree.\n  It should return values similar to the standard strcmp() function -\n  0 if the two arguments are equal, a negative value if the first argument\n  comes before the second, or a positive value if the first argument comes\n  after the second.</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key_compare_func\" transfer-ownership=\"none\" gs:managed-name=\"keyCompareFunc\" gs:managed-type=\"CompareFunc\" gs:unmanaged-type=\"CompareFuncNative\">\n        <doc xml:space=\"preserve\">the function used to order the nodes in the #GTree.\n  It should return values similar to the standard strcmp() function -\n  0 if the two arguments are equal, a negative value if the first argument\n  comes before the second, or a positive value if the first argument comes\n  after the second.</doc>\n        <type name=\"CompareFunc\" c:type=\"GCompareFunc\" gs:managed-name=\"CompareFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"new_full\" c:identifier=\"g_tree_new_full\" introspectable=\"0\" gs:managed-name=\"NewFull\">\n    <doc xml:space=\"preserve\">Creates a new #GTree like g_tree_new() and allows to specify functions\nto free the memory allocated for the key and value that get called when\nremoving the entry from the #GTree.</doc>\n    <return-value gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated #GTree</doc>\n      <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"key_compare_func\" transfer-ownership=\"none\" scope=\"notified\" closure=\"1\" destroy=\"3\" gs:managed-name=\"keyCompareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">qsort()-style comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"key_compare_data\" transfer-ownership=\"none\" gs:managed-name=\"keyCompareData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to comparison function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"key_destroy_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"keyDestroyFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a function to free the memory allocated for the key\n  used when removing the entry from the #GTree or %NULL if you don't\n  want to supply such a function</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n      <parameter name=\"value_destroy_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"valueDestroyFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a function to free the memory allocated for the\n  value used when removing the entry from the #GTree or %NULL if you\n  don't want to supply such a function</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key_compare_func\" transfer-ownership=\"none\" scope=\"notified\" closure=\"1\" destroy=\"3\" gs:managed-name=\"keyCompareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">qsort()-style comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"key_destroy_func\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"keyDestroyFunc\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">a function to free the memory allocated for the key\n  used when removing the entry from the #GTree or %NULL if you don't\n  want to supply such a function</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"new_with_data\" c:identifier=\"g_tree_new_with_data\" introspectable=\"0\" gs:managed-name=\"NewWithData\">\n    <doc xml:space=\"preserve\">Creates a new #GTree with a comparison function that accepts user data.\nSee g_tree_new() for more details.</doc>\n    <return-value gs:managed-type=\"Tree\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly allocated #GTree</doc>\n      <type name=\"Tree\" c:type=\"GTree*\" gs:managed-name=\"Tree\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"key_compare_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"keyCompareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">qsort()-style comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n      <parameter name=\"key_compare_data\" transfer-ownership=\"none\" gs:managed-name=\"keyCompareData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to comparison function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key_compare_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"keyCompareFunc\" gs:managed-type=\"CompareDataFunc\" gs:unmanaged-type=\"CompareDataFuncNative\">\n        <doc xml:space=\"preserve\">qsort()-style comparison function</doc>\n        <type name=\"CompareDataFunc\" c:type=\"GCompareDataFunc\" gs:managed-name=\"CompareDataFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    public partial class Tree : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.Tree>
    {
        public Tree(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GTree.
        /// </summary>
        /// <param name="keyCompareFunc">
        /// the function used to order the nodes in the #GTree.
        ///   It should return values similar to the standard strcmp() function -
        ///   0 if the two arguments are equal, a negative value if the first argument
        ///   comes before the second, or a positive value if the first argument comes
        ///   after the second.
        /// </param>
        /// <returns>
        /// a newly allocated #GTree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_tree_new(
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative keyCompareFunc);

        /// <summary>
        /// Creates a new #GTree.
        /// </summary>
        /// <param name="keyCompareFunc">
        /// the function used to order the nodes in the #GTree.
        ///   It should return values similar to the standard strcmp() function -
        ///   0 if the two arguments are equal, a negative value if the first argument
        ///   comes before the second, or a positive value if the first argument comes
        ///   after the second.
        /// </param>
        /// <returns>
        /// a newly allocated #GTree
        /// </returns>
        public static GISharp.GLib.Tree New(
            GISharp.Core.CompareFuncNative keyCompareFunc)
        {
            return default(GISharp.GLib.Tree);
        }

        /// <summary>
        /// Creates a new #GTree like g_tree_new() and allows to specify functions
        /// to free the memory allocated for the key and value that get called when
        /// removing the entry from the #GTree.
        /// </summary>
        /// <param name="keyCompareFunc">
        /// qsort()-style comparison function
        /// </param>
        /// <param name="keyCompareData">
        /// data to pass to comparison function
        /// </param>
        /// <param name="keyDestroyFunc">
        /// a function to free the memory allocated for the key
        ///   used when removing the entry from the #GTree or %NULL if you don't
        ///   want to supply such a function
        /// </param>
        /// <param name="valueDestroyFunc">
        /// a function to free the memory allocated for the
        ///   value used when removing the entry from the #GTree or %NULL if you
        ///   don't want to supply such a function
        /// </param>
        /// <returns>
        /// a newly allocated #GTree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_tree_new_full(
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative keyCompareFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr keyCompareData,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify keyDestroyFunc,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify valueDestroyFunc);

        /// <summary>
        /// Creates a new #GTree like g_tree_new() and allows to specify functions
        /// to free the memory allocated for the key and value that get called when
        /// removing the entry from the #GTree.
        /// </summary>
        /// <param name="keyCompareFunc">
        /// qsort()-style comparison function
        /// </param>
        /// <param name="keyCompareData">
        /// data to pass to comparison function
        /// </param>
        /// <param name="keyDestroyFunc">
        /// a function to free the memory allocated for the key
        ///   used when removing the entry from the #GTree or %NULL if you don't
        ///   want to supply such a function
        /// </param>
        /// <param name="valueDestroyFunc">
        /// a function to free the memory allocated for the
        ///   value used when removing the entry from the #GTree or %NULL if you
        ///   don't want to supply such a function
        /// </param>
        /// <returns>
        /// a newly allocated #GTree
        /// </returns>
        public static GISharp.GLib.Tree NewFull(
            GISharp.Core.CompareDataFuncNative keyCompareFunc,
            GISharp.GLib.DestroyNotify keyDestroyFunc)
        {
            return default(GISharp.GLib.Tree);
        }

        /// <summary>
        /// Creates a new #GTree with a comparison function that accepts user data.
        /// See g_tree_new() for more details.
        /// </summary>
        /// <param name="keyCompareFunc">
        /// qsort()-style comparison function
        /// </param>
        /// <param name="keyCompareData">
        /// data to pass to comparison function
        /// </param>
        /// <returns>
        /// a newly allocated #GTree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_tree_new_with_data(
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareDataFuncNative keyCompareFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr keyCompareData);

        /// <summary>
        /// Creates a new #GTree with a comparison function that accepts user data.
        /// See g_tree_new() for more details.
        /// </summary>
        /// <param name="keyCompareFunc">
        /// qsort()-style comparison function
        /// </param>
        /// <param name="keyCompareData">
        /// data to pass to comparison function
        /// </param>
        /// <returns>
        /// a newly allocated #GTree
        /// </returns>
        public static GISharp.GLib.Tree NewWithData(
            GISharp.Core.CompareDataFuncNative keyCompareFunc)
        {
            return default(GISharp.GLib.Tree);
        }

        /// <summary>
        /// Removes all keys and values from the #GTree and decreases its
        /// reference count by one. If keys and/or values are dynamically
        /// allocated, you should either free them first or create the #GTree
        /// using g_tree_new_full(). In the latter case the destroy functions
        /// you supplied will be called on all keys and values before destroying
        /// the #GTree.
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_tree_destroy(
            [System.Runtime.InteropServices.In()] System.IntPtr tree);

        /// <summary>
        /// Removes all keys and values from the #GTree and decreases its
        /// reference count by one. If keys and/or values are dynamically
        /// allocated, you should either free them first or create the #GTree
        /// using g_tree_new_full(). In the latter case the destroy functions
        /// you supplied will be called on all keys and values before destroying
        /// the #GTree.
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        public void Destroy()
        {
        }

        /// <summary>
        /// Calls the given function for each of the key/value pairs in the #GTree.
        /// The function is passed the key and value of each pair, and the given
        /// @data parameter. The tree is traversed in sorted order.
        /// </summary>
        /// <remarks>
        /// The tree may not be modified while iterating over it (you can't
        /// add/remove items). To remove all items matching a predicate, you need
        /// to add each item to a list in your #GTraverseFunc as you walk over
        /// the tree, then walk the list and remove each item.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="func">
        /// the function to call for each node visited.
        ///     If this function returns %TRUE, the traversal is stopped.
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_tree_foreach(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFunc func,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls the given function for each of the key/value pairs in the #GTree.
        /// The function is passed the key and value of each pair, and the given
        /// @data parameter. The tree is traversed in sorted order.
        /// </summary>
        /// <remarks>
        /// The tree may not be modified while iterating over it (you can't
        /// add/remove items). To remove all items matching a predicate, you need
        /// to add each item to a list in your #GTraverseFunc as you walk over
        /// the tree, then walk the list and remove each item.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="func">
        /// the function to call for each node visited.
        ///     If this function returns %TRUE, the traversal is stopped.
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        public void Foreach(
            GISharp.GLib.TraverseFunc func)
        {
        }

        /// <summary>
        /// Gets the height of a #GTree.
        /// </summary>
        /// <remarks>
        /// If the #GTree contains no nodes, the height is 0.
        /// If the #GTree contains only one root node the height is 1.
        /// If the root node has children the height is 2, etc.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <returns>
        /// the height of @tree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_tree_height(
            [System.Runtime.InteropServices.In()] System.IntPtr tree);

        /// <summary>
        /// Gets the height of a #GTree.
        /// </summary>
        /// <remarks>
        /// If the #GTree contains no nodes, the height is 0.
        /// If the #GTree contains only one root node the height is 1.
        /// If the root node has children the height is 2, etc.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <returns>
        /// the height of @tree
        /// </returns>
        public System.Int32 Height()
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Inserts a key/value pair into a #GTree.
        /// </summary>
        /// <remarks>
        /// If the given key already exists in the #GTree its corresponding value
        /// is set to the new value. If you supplied a @value_destroy_func when
        /// creating the #GTree, the old value is freed using that function. If
        /// you supplied a @key_destroy_func when creating the #GTree, the passed
        /// key is freed using that function.
        /// 
        /// The tree is automatically 'balanced' as new key/value pairs are added,
        /// so that the distance from the root to every leaf is as small as possible.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to insert
        /// </param>
        /// <param name="value">
        /// the value corresponding to the key
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_tree_insert(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Inserts a key/value pair into a #GTree.
        /// </summary>
        /// <remarks>
        /// If the given key already exists in the #GTree its corresponding value
        /// is set to the new value. If you supplied a @value_destroy_func when
        /// creating the #GTree, the old value is freed using that function. If
        /// you supplied a @key_destroy_func when creating the #GTree, the passed
        /// key is freed using that function.
        /// 
        /// The tree is automatically 'balanced' as new key/value pairs are added,
        /// so that the distance from the root to every leaf is as small as possible.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to insert
        /// </param>
        /// <param name="value">
        /// the value corresponding to the key
        /// </param>
        public void Insert(
            System.IntPtr key,
            System.IntPtr value)
        {
        }

        /// <summary>
        /// Gets the value corresponding to the given key. Since a #GTree is
        /// automatically balanced as key/value pairs are added, key lookup
        /// is O(log n) (where n is the number of key/value pairs in the tree).
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to look up
        /// </param>
        /// <returns>
        /// the value corresponding to the key, or %NULL
        ///     if the key was not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_tree_lookup(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Gets the value corresponding to the given key. Since a #GTree is
        /// automatically balanced as key/value pairs are added, key lookup
        /// is O(log n) (where n is the number of key/value pairs in the tree).
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to look up
        /// </param>
        /// <returns>
        /// the value corresponding to the key, or %NULL
        ///     if the key was not found
        /// </returns>
        public System.IntPtr Lookup(
            System.IntPtr key)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Looks up a key in the #GTree, returning the original key and the
        /// associated value. This is useful if you need to free the memory
        /// allocated for the original key, for example before calling
        /// g_tree_remove().
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="lookupKey">
        /// the key to look up
        /// </param>
        /// <param name="origKey">
        /// returns the original key
        /// </param>
        /// <param name="value">
        /// returns the value associated with the key
        /// </param>
        /// <returns>
        /// %TRUE if the key was found in the #GTree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_tree_lookup_extended(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] System.IntPtr lookupKey,
            [System.Runtime.InteropServices.In()] System.IntPtr origKey,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Looks up a key in the #GTree, returning the original key and the
        /// associated value. This is useful if you need to free the memory
        /// allocated for the original key, for example before calling
        /// g_tree_remove().
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="lookupKey">
        /// the key to look up
        /// </param>
        /// <param name="origKey">
        /// returns the original key
        /// </param>
        /// <param name="value">
        /// returns the value associated with the key
        /// </param>
        /// <returns>
        /// %TRUE if the key was found in the #GTree
        /// </returns>
        public System.Boolean LookupExtended(
            System.IntPtr lookupKey,
            System.IntPtr origKey,
            System.IntPtr value)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Gets the number of nodes in a #GTree.
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <returns>
        /// the number of nodes in @tree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Int32 g_tree_nnodes(
            [System.Runtime.InteropServices.In()] System.IntPtr tree);

        /// <summary>
        /// Gets the number of nodes in a #GTree.
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <returns>
        /// the number of nodes in @tree
        /// </returns>
        public System.Int32 Nnodes()
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Increments the reference count of @tree by one.
        /// </summary>
        /// <remarks>
        /// It is safe to call this function from any thread.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <returns>
        /// the passed in #GTree
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern System.IntPtr g_tree_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr tree);

        /// <summary>
        /// Increments the reference count of @tree by one.
        /// </summary>
        /// <remarks>
        /// It is safe to call this function from any thread.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <returns>
        /// the passed in #GTree
        /// </returns>
        [GISharp.Core.Since("2.22")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Removes a key/value pair from a #GTree.
        /// </summary>
        /// <remarks>
        /// If the #GTree was created using g_tree_new_full(), the key and value
        /// are freed using the supplied destroy functions, otherwise you have to
        /// make sure that any dynamically allocated values are freed yourself.
        /// If the key does not exist in the #GTree, the function does nothing.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was found (prior to 2.8, this function
        ///     returned nothing)
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_tree_remove(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Removes a key/value pair from a #GTree.
        /// </summary>
        /// <remarks>
        /// If the #GTree was created using g_tree_new_full(), the key and value
        /// are freed using the supplied destroy functions, otherwise you have to
        /// make sure that any dynamically allocated values are freed yourself.
        /// If the key does not exist in the #GTree, the function does nothing.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was found (prior to 2.8, this function
        ///     returned nothing)
        /// </returns>
        public System.Boolean Remove(
            System.IntPtr key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Inserts a new key and value into a #GTree similar to g_tree_insert().
        /// The difference is that if the key already exists in the #GTree, it gets
        /// replaced by the new key. If you supplied a @value_destroy_func when
        /// creating the #GTree, the old value is freed using that function. If you
        /// supplied a @key_destroy_func when creating the #GTree, the old key is
        /// freed using that function.
        /// </summary>
        /// <remarks>
        /// The tree is automatically 'balanced' as new key/value pairs are added,
        /// so that the distance from the root to every leaf is as small as possible.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to insert
        /// </param>
        /// <param name="value">
        /// the value corresponding to the key
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_tree_replace(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Inserts a new key and value into a #GTree similar to g_tree_insert().
        /// The difference is that if the key already exists in the #GTree, it gets
        /// replaced by the new key. If you supplied a @value_destroy_func when
        /// creating the #GTree, the old value is freed using that function. If you
        /// supplied a @key_destroy_func when creating the #GTree, the old key is
        /// freed using that function.
        /// </summary>
        /// <remarks>
        /// The tree is automatically 'balanced' as new key/value pairs are added,
        /// so that the distance from the root to every leaf is as small as possible.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to insert
        /// </param>
        /// <param name="value">
        /// the value corresponding to the key
        /// </param>
        public void Replace(
            System.IntPtr key,
            System.IntPtr value)
        {
        }

        /// <summary>
        /// Searches a #GTree using @search_func.
        /// </summary>
        /// <remarks>
        /// The @search_func is called with a pointer to the key of a key/value
        /// pair in the tree, and the passed in @user_data. If @search_func returns
        /// 0 for a key/value pair, then the corresponding value is returned as
        /// the result of g_tree_search(). If @search_func returns -1, searching
        /// will proceed among the key/value pairs that have a smaller key; if
        /// @search_func returns 1, searching will proceed among the key/value
        /// pairs that have a larger key.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="searchFunc">
        /// a function used to search the #GTree
        /// </param>
        /// <param name="userData">
        /// the data passed as the second argument to @search_func
        /// </param>
        /// <returns>
        /// the value corresponding to the found key, or %NULL
        ///     if the key was not found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_tree_search(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] GISharp.Core.CompareFuncNative searchFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Searches a #GTree using @search_func.
        /// </summary>
        /// <remarks>
        /// The @search_func is called with a pointer to the key of a key/value
        /// pair in the tree, and the passed in @user_data. If @search_func returns
        /// 0 for a key/value pair, then the corresponding value is returned as
        /// the result of g_tree_search(). If @search_func returns -1, searching
        /// will proceed among the key/value pairs that have a smaller key; if
        /// @search_func returns 1, searching will proceed among the key/value
        /// pairs that have a larger key.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="searchFunc">
        /// a function used to search the #GTree
        /// </param>
        /// <param name="userData">
        /// the data passed as the second argument to @search_func
        /// </param>
        /// <returns>
        /// the value corresponding to the found key, or %NULL
        ///     if the key was not found
        /// </returns>
        public System.IntPtr Search(
            GISharp.Core.CompareFuncNative searchFunc)
        {
            return default(System.IntPtr);
        }

        /// <summary>
        /// Removes a key and its associated value from a #GTree without calling
        /// the key and value destroy functions.
        /// </summary>
        /// <remarks>
        /// If the key does not exist in the #GTree, the function does nothing.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was found (prior to 2.8, this function
        ///     returned nothing)
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_tree_steal(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Removes a key and its associated value from a #GTree without calling
        /// the key and value destroy functions.
        /// </summary>
        /// <remarks>
        /// If the key does not exist in the #GTree, the function does nothing.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="key">
        /// the key to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was found (prior to 2.8, this function
        ///     returned nothing)
        /// </returns>
        public System.Boolean Steal(
            System.IntPtr key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Calls the given function for each node in the #GTree.
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="traverseFunc">
        /// the function to call for each node visited. If this
        ///   function returns %TRUE, the traversal is stopped.
        /// </param>
        /// <param name="traverseType">
        /// the order in which nodes are visited, one of %G_IN_ORDER,
        ///   %G_PRE_ORDER and %G_POST_ORDER
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [System.Obsolete("The order of a balanced tree is somewhat arbitrary.\n    If you just want to visit all nodes in sorted order, use\n    g_tree_foreach() instead. If you really need to visit nodes in\n    a different order, consider using an [n-ary tree][glib-N-ary-Trees].")]
        static extern void g_tree_traverse(
            [System.Runtime.InteropServices.In()] System.IntPtr tree,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseFunc traverseFunc,
            [System.Runtime.InteropServices.In()] GISharp.GLib.TraverseType traverseType,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Calls the given function for each node in the #GTree.
        /// </summary>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        /// <param name="traverseFunc">
        /// the function to call for each node visited. If this
        ///   function returns %TRUE, the traversal is stopped.
        /// </param>
        /// <param name="traverseType">
        /// the order in which nodes are visited, one of %G_IN_ORDER,
        ///   %G_PRE_ORDER and %G_POST_ORDER
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [System.Obsolete("The order of a balanced tree is somewhat arbitrary.\n    If you just want to visit all nodes in sorted order, use\n    g_tree_foreach() instead. If you really need to visit nodes in\n    a different order, consider using an [n-ary tree][glib-N-ary-Trees].")]
        public void Traverse(
            GISharp.GLib.TraverseFunc traverseFunc,
            GISharp.GLib.TraverseType traverseType)
        {
        }

        /// <summary>
        /// Decrements the reference count of @tree by one.
        /// If the reference count drops to 0, all keys and values will
        /// be destroyed (if destroy functions were specified) and all
        /// memory allocated by @tree will be released.
        /// </summary>
        /// <remarks>
        /// It is safe to call this function from any thread.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.22")]
        static extern void g_tree_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr tree);

        /// <summary>
        /// Decrements the reference count of @tree by one.
        /// If the reference count drops to 0, all keys and values will
        /// be destroyed (if destroy functions were specified) and all
        /// memory allocated by @tree will be released.
        /// </summary>
        /// <remarks>
        /// It is safe to call this function from any thread.
        /// </remarks>
        /// <param name="tree">
        /// a #GTree
        /// </param>
        [GISharp.Core.Since("2.22")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// #GVariant is a variant datatype; it stores a value along with
    /// information about the type of that value.  The range of possible
    /// values is determined by the type.  The type system used by #GVariant
    /// is #GVariantType.
    /// </summary>
    /// <remarks>
    /// #GVariant instances always have a type and a value (which are given
    /// at construction time).  The type and value of a #GVariant instance
    /// can never change other than by the #GVariant itself being
    /// destroyed.  A #GVariant cannot contain a pointer.
    /// 
    /// #GVariant is reference counted using g_variant_ref() and
    /// g_variant_unref().  #GVariant also has floating reference counts --
    /// see g_variant_ref_sink().
    /// 
    /// #GVariant is completely threadsafe.  A #GVariant instance can be
    /// concurrently accessed in any way from any number of threads without
    /// problems.
    /// 
    /// #GVariant is heavily optimised for dealing with data in serialised
    /// form.  It works particularly well with data located in memory-mapped
    /// files.  It can perform nearly all deserialisation operations in a
    /// small constant time, usually touching only a single memory page.
    /// Serialised #GVariant data can also be sent over the network.
    /// 
    /// #GVariant is largely compatible with D-Bus.  Almost all types of
    /// #GVariant instances can be sent over D-Bus.  See #GVariantType for
    /// exceptions.  (However, #GVariant's serialisation format is not the same
    /// as the serialisation format of a D-Bus message body: use #GDBusMessage,
    /// in the gio library, for those.)
    /// 
    /// For space-efficiency, the #GVariant serialisation format does not
    /// automatically include the variant's length, type or endianness,
    /// which must either be implied from context (such as knowledge that a
    /// particular file format always contains a little-endian
    /// %G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)
    /// or supplied out-of-band (for instance, a length, type and/or endianness
    /// indicator could be placed at the beginning of a file, network message
    /// or network stream).
    /// 
    /// A #GVariant's size is limited mainly by any lower level operating
    /// system constraints, such as the number of bits in #gsize.  For
    /// example, it is reasonable to have a 2GB file mapped into memory
    /// with #GMappedFile, and call g_variant_new_from_data() on it.
    /// 
    /// For convenience to C programmers, #GVariant features powerful
    /// varargs-based value construction and destruction.  This feature is
    /// designed to be embedded in other libraries.
    /// 
    /// There is a Python-inspired text language for describing #GVariant
    /// values.  #GVariant includes a printer for this language and a parser
    /// with type inferencing.
    /// 
    /// ## Memory Use
    /// 
    /// #GVariant tries to be quite efficient with respect to memory use.
    /// This section gives a rough idea of how much memory is used by the
    /// current implementation.  The information here is subject to change
    /// in the future.
    /// 
    /// The memory allocated by #GVariant can be grouped into 4 broad
    /// purposes: memory for serialised data, memory for the type
    /// information cache, buffer management memory and memory for the
    /// #GVariant structure itself.
    /// 
    /// ## Serialised Data Memory
    /// 
    /// This is the memory that is used for storing GVariant data in
    /// serialised form.  This is what would be sent over the network or
    /// what would end up on disk, not counting any indicator of the
    /// endianness, or of the length or type of the top-level variant.
    /// 
    /// The amount of memory required to store a boolean is 1 byte. 16,
    /// 32 and 64 bit integers and double precision floating point numbers
    /// use their "natural" size.  Strings (including object path and
    /// signature strings) are stored with a nul terminator, and as such
    /// use the length of the string plus 1 byte.
    /// 
    /// Maybe types use no space at all to represent the null value and
    /// use the same amount of space (sometimes plus one byte) as the
    /// equivalent non-maybe-typed value to represent the non-null case.
    /// 
    /// Arrays use the amount of space required to store each of their
    /// members, concatenated.  Additionally, if the items stored in an
    /// array are not of a fixed-size (ie: strings, other arrays, etc)
    /// then an additional framing offset is stored for each item.  The
    /// size of this offset is either 1, 2 or 4 bytes depending on the
    /// overall size of the container.  Additionally, extra padding bytes
    /// are added as required for alignment of child values.
    /// 
    /// Tuples (including dictionary entries) use the amount of space
    /// required to store each of their members, concatenated, plus one
    /// framing offset (as per arrays) for each non-fixed-sized item in
    /// the tuple, except for the last one.  Additionally, extra padding
    /// bytes are added as required for alignment of child values.
    /// 
    /// Variants use the same amount of space as the item inside of the
    /// variant, plus 1 byte, plus the length of the type string for the
    /// item inside the variant.
    /// 
    /// As an example, consider a dictionary mapping strings to variants.
    /// In the case that the dictionary is empty, 0 bytes are required for
    /// the serialisation.
    /// 
    /// If we add an item "width" that maps to the int32 value of 500 then
    /// we will use 4 byte to store the int32 (so 6 for the variant
    /// containing it) and 6 bytes for the string.  The variant must be
    /// aligned to 8 after the 6 bytes of the string, so that's 2 extra
    /// bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
    /// for the dictionary entry.  An additional 1 byte is added to the
    /// array as a framing offset making a total of 15 bytes.
    /// 
    /// If we add another entry, "title" that maps to a nullable string
    /// that happens to have a value of null, then we use 0 bytes for the
    /// null value (and 3 bytes for the variant to contain it along with
    /// its type string) plus 6 bytes for the string.  Again, we need 2
    /// padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.
    /// 
    /// We now require extra padding between the two items in the array.
    /// After the 14 bytes of the first item, that's 2 bytes required.
    /// We now require 2 framing offsets for an extra two
    /// bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
    /// dictionary.
    /// 
    /// ## Type Information Cache
    /// 
    /// For each GVariant type that currently exists in the program a type
    /// information structure is kept in the type information cache.  The
    /// type information structure is required for rapid deserialisation.
    /// 
    /// Continuing with the above example, if a #GVariant exists with the
    /// type "a{sv}" then a type information struct will exist for
    /// "a{sv}", "{sv}", "s", and "v".  Multiple uses of the same type
    /// will share the same type information.  Additionally, all
    /// single-digit types are stored in read-only static memory and do
    /// not contribute to the writable memory footprint of a program using
    /// #GVariant.
    /// 
    /// Aside from the type information structures stored in read-only
    /// memory, there are two forms of type information.  One is used for
    /// container types where there is a single element type: arrays and
    /// maybe types.  The other is used for container types where there
    /// are multiple element types: tuples and dictionary entries.
    /// 
    /// Array type info structures are 6 * sizeof (void *), plus the
    /// memory required to store the type string itself.  This means that
    /// on 32-bit systems, the cache entry for "a{sv}" would require 30
    /// bytes of memory (plus malloc overhead).
    /// 
    /// Tuple type info structures are 6 * sizeof (void *), plus 4 *
    /// sizeof (void *) for each item in the tuple, plus the memory
    /// required to store the type string itself.  A 2-item tuple, for
    /// example, would have a type information structure that consumed
    /// writable memory in the size of 14 * sizeof (void *) (plus type
    /// string)  This means that on 32-bit systems, the cache entry for
    /// "{sv}" would require 61 bytes of memory (plus malloc overhead).
    /// 
    /// This means that in total, for our "a{sv}" example, 91 bytes of
    /// type information would be allocated.
    /// 
    /// The type information cache, additionally, uses a #GHashTable to
    /// store and lookup the cached items and stores a pointer to this
    /// hash table in static storage.  The hash table is freed when there
    /// are zero items in the type cache.
    /// 
    /// Although these sizes may seem large it is important to remember
    /// that a program will probably only have a very small number of
    /// different types of values in it and that only one type information
    /// structure is required for many different values of the same type.
    /// 
    /// ## Buffer Management Memory
    /// 
    /// #GVariant uses an internal buffer management structure to deal
    /// with the various different possible sources of serialised data
    /// that it uses.  The buffer is responsible for ensuring that the
    /// correct call is made when the data is no longer in use by
    /// #GVariant.  This may involve a g_free() or a g_slice_free() or
    /// even g_mapped_file_unref().
    /// 
    /// One buffer management structure is used for each chunk of
    /// serialised data.  The size of the buffer management structure
    /// is 4 * (void *).  On 32-bit systems, that's 16 bytes.
    /// 
    /// ## GVariant structure
    /// 
    /// The size of a #GVariant structure is 6 * (void *).  On 32-bit
    /// systems, that's 24 bytes.
    /// 
    /// #GVariant structures only exist if they are explicitly created
    /// with API calls.  For example, if a #GVariant is constructed out of
    /// serialised data for the example given above (with the dictionary)
    /// then although there are 9 individual values that comprise the
    /// entire dictionary (two keys, two values, two variants containing
    /// the values, two dictionary entries, plus the dictionary itself),
    /// only 1 #GVariant instance exists -- the one referring to the
    /// dictionary.
    /// 
    /// If calls are made to start accessing the other values then
    /// #GVariant instances will exist for those values only for as long
    /// as they are in use (ie: until you call g_variant_unref()).  The
    /// type information is shared.  The serialised data and the buffer
    /// management structure for that serialised data is shared by the
    /// child.
    /// 
    /// ## Summary
    /// 
    /// To put the entire example together, for our dictionary mapping
    /// strings to variants (with two entries, as given above), we are
    /// using 91 bytes of memory for type information, 29 byes of memory
    /// for the serialised data, 16 bytes for buffer management and 24
    /// bytes for the #GVariant instance, or a total of 160 bytes, plus
    /// malloc overhead.  If we were to use g_variant_get_child_value() to
    /// access the two dictionary entries, we would use an additional 48
    /// bytes.  If we were to have other dictionaries of the same type, we
    /// would use more memory for the serialised data and buffer
    /// management for those dictionaries, but the type information would
    /// be shared.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"Variant\" c:type=\"GVariant\" version=\"2.24\" glib:type-name=\"GVariant\" glib:get-type=\"intern\" c:symbol-prefix=\"variant\" gs:managed-name=\"Variant\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">#GVariant is a variant datatype; it stores a value along with\ninformation about the type of that value.  The range of possible\nvalues is determined by the type.  The type system used by #GVariant\nis #GVariantType.\n\n#GVariant instances always have a type and a value (which are given\nat construction time).  The type and value of a #GVariant instance\ncan never change other than by the #GVariant itself being\ndestroyed.  A #GVariant cannot contain a pointer.\n\n#GVariant is reference counted using g_variant_ref() and\ng_variant_unref().  #GVariant also has floating reference counts --\nsee g_variant_ref_sink().\n\n#GVariant is completely threadsafe.  A #GVariant instance can be\nconcurrently accessed in any way from any number of threads without\nproblems.\n\n#GVariant is heavily optimised for dealing with data in serialised\nform.  It works particularly well with data located in memory-mapped\nfiles.  It can perform nearly all deserialisation operations in a\nsmall constant time, usually touching only a single memory page.\nSerialised #GVariant data can also be sent over the network.\n\n#GVariant is largely compatible with D-Bus.  Almost all types of\n#GVariant instances can be sent over D-Bus.  See #GVariantType for\nexceptions.  (However, #GVariant's serialisation format is not the same\nas the serialisation format of a D-Bus message body: use #GDBusMessage,\nin the gio library, for those.)\n\nFor space-efficiency, the #GVariant serialisation format does not\nautomatically include the variant's length, type or endianness,\nwhich must either be implied from context (such as knowledge that a\nparticular file format always contains a little-endian\n%G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)\nor supplied out-of-band (for instance, a length, type and/or endianness\nindicator could be placed at the beginning of a file, network message\nor network stream).\n\nA #GVariant's size is limited mainly by any lower level operating\nsystem constraints, such as the number of bits in #gsize.  For\nexample, it is reasonable to have a 2GB file mapped into memory\nwith #GMappedFile, and call g_variant_new_from_data() on it.\n\nFor convenience to C programmers, #GVariant features powerful\nvarargs-based value construction and destruction.  This feature is\ndesigned to be embedded in other libraries.\n\nThere is a Python-inspired text language for describing #GVariant\nvalues.  #GVariant includes a printer for this language and a parser\nwith type inferencing.\n\n## Memory Use\n\n#GVariant tries to be quite efficient with respect to memory use.\nThis section gives a rough idea of how much memory is used by the\ncurrent implementation.  The information here is subject to change\nin the future.\n\nThe memory allocated by #GVariant can be grouped into 4 broad\npurposes: memory for serialised data, memory for the type\ninformation cache, buffer management memory and memory for the\n#GVariant structure itself.\n\n## Serialised Data Memory\n\nThis is the memory that is used for storing GVariant data in\nserialised form.  This is what would be sent over the network or\nwhat would end up on disk, not counting any indicator of the\nendianness, or of the length or type of the top-level variant.\n\nThe amount of memory required to store a boolean is 1 byte. 16,\n32 and 64 bit integers and double precision floating point numbers\nuse their \"natural\" size.  Strings (including object path and\nsignature strings) are stored with a nul terminator, and as such\nuse the length of the string plus 1 byte.\n\nMaybe types use no space at all to represent the null value and\nuse the same amount of space (sometimes plus one byte) as the\nequivalent non-maybe-typed value to represent the non-null case.\n\nArrays use the amount of space required to store each of their\nmembers, concatenated.  Additionally, if the items stored in an\narray are not of a fixed-size (ie: strings, other arrays, etc)\nthen an additional framing offset is stored for each item.  The\nsize of this offset is either 1, 2 or 4 bytes depending on the\noverall size of the container.  Additionally, extra padding bytes\nare added as required for alignment of child values.\n\nTuples (including dictionary entries) use the amount of space\nrequired to store each of their members, concatenated, plus one\nframing offset (as per arrays) for each non-fixed-sized item in\nthe tuple, except for the last one.  Additionally, extra padding\nbytes are added as required for alignment of child values.\n\nVariants use the same amount of space as the item inside of the\nvariant, plus 1 byte, plus the length of the type string for the\nitem inside the variant.\n\nAs an example, consider a dictionary mapping strings to variants.\nIn the case that the dictionary is empty, 0 bytes are required for\nthe serialisation.\n\nIf we add an item \"width\" that maps to the int32 value of 500 then\nwe will use 4 byte to store the int32 (so 6 for the variant\ncontaining it) and 6 bytes for the string.  The variant must be\naligned to 8 after the 6 bytes of the string, so that's 2 extra\nbytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used\nfor the dictionary entry.  An additional 1 byte is added to the\narray as a framing offset making a total of 15 bytes.\n\nIf we add another entry, \"title\" that maps to a nullable string\nthat happens to have a value of null, then we use 0 bytes for the\nnull value (and 3 bytes for the variant to contain it along with\nits type string) plus 6 bytes for the string.  Again, we need 2\npadding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.\n\nWe now require extra padding between the two items in the array.\nAfter the 14 bytes of the first item, that's 2 bytes required.\nWe now require 2 framing offsets for an extra two\nbytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item\ndictionary.\n\n## Type Information Cache\n\nFor each GVariant type that currently exists in the program a type\ninformation structure is kept in the type information cache.  The\ntype information structure is required for rapid deserialisation.\n\nContinuing with the above example, if a #GVariant exists with the\ntype \"a{sv}\" then a type information struct will exist for\n\"a{sv}\", \"{sv}\", \"s\", and \"v\".  Multiple uses of the same type\nwill share the same type information.  Additionally, all\nsingle-digit types are stored in read-only static memory and do\nnot contribute to the writable memory footprint of a program using\n#GVariant.\n\nAside from the type information structures stored in read-only\nmemory, there are two forms of type information.  One is used for\ncontainer types where there is a single element type: arrays and\nmaybe types.  The other is used for container types where there\nare multiple element types: tuples and dictionary entries.\n\nArray type info structures are 6 * sizeof (void *), plus the\nmemory required to store the type string itself.  This means that\non 32-bit systems, the cache entry for \"a{sv}\" would require 30\nbytes of memory (plus malloc overhead).\n\nTuple type info structures are 6 * sizeof (void *), plus 4 *\nsizeof (void *) for each item in the tuple, plus the memory\nrequired to store the type string itself.  A 2-item tuple, for\nexample, would have a type information structure that consumed\nwritable memory in the size of 14 * sizeof (void *) (plus type\nstring)  This means that on 32-bit systems, the cache entry for\n\"{sv}\" would require 61 bytes of memory (plus malloc overhead).\n\nThis means that in total, for our \"a{sv}\" example, 91 bytes of\ntype information would be allocated.\n\nThe type information cache, additionally, uses a #GHashTable to\nstore and lookup the cached items and stores a pointer to this\nhash table in static storage.  The hash table is freed when there\nare zero items in the type cache.\n\nAlthough these sizes may seem large it is important to remember\nthat a program will probably only have a very small number of\ndifferent types of values in it and that only one type information\nstructure is required for many different values of the same type.\n\n## Buffer Management Memory\n\n#GVariant uses an internal buffer management structure to deal\nwith the various different possible sources of serialised data\nthat it uses.  The buffer is responsible for ensuring that the\ncorrect call is made when the data is no longer in use by\n#GVariant.  This may involve a g_free() or a g_slice_free() or\neven g_mapped_file_unref().\n\nOne buffer management structure is used for each chunk of\nserialised data.  The size of the buffer management structure\nis 4 * (void *).  On 32-bit systems, that's 16 bytes.\n\n## GVariant structure\n\nThe size of a #GVariant structure is 6 * (void *).  On 32-bit\nsystems, that's 24 bytes.\n\n#GVariant structures only exist if they are explicitly created\nwith API calls.  For example, if a #GVariant is constructed out of\nserialised data for the example given above (with the dictionary)\nthen although there are 9 individual values that comprise the\nentire dictionary (two keys, two values, two variants containing\nthe values, two dictionary entries, plus the dictionary itself),\nonly 1 #GVariant instance exists -- the one referring to the\ndictionary.\n\nIf calls are made to start accessing the other values then\n#GVariant instances will exist for those values only for as long\nas they are in use (ie: until you call g_variant_unref()).  The\ntype information is shared.  The serialised data and the buffer\nmanagement structure for that serialised data is shared by the\nchild.\n\n## Summary\n\nTo put the entire example together, for our dictionary mapping\nstrings to variants (with two entries, as given above), we are\nusing 91 bytes of memory for type information, 29 byes of memory\nfor the serialised data, 16 bytes for buffer management and 24\nbytes for the #GVariant instance, or a total of 160 bytes, plus\nmalloc overhead.  If we were to use g_variant_get_child_value() to\naccess the two dictionary entries, we would use an additional 48\nbytes.  If we were to have other dictionaries of the same type, we\nwould use more memory for the serialised data and buffer\nmanagement for those dictionaries, but the type information would\nbe shared.</doc>\n  <constructor name=\"new_array\" c:identifier=\"g_variant_new_array\" version=\"2.24\" gs:managed-name=\"NewArray\">\n    <doc xml:space=\"preserve\">Creates a new #GVariant array from @children.\n\n@child_type must be non-%NULL if @n_children is zero.  Otherwise, the\nchild type is determined by inspecting the first element of the\n@children array.  If @child_type is non-%NULL then it must be a\ndefinite type.\n\nThe items of the array are taken from the @children array.  No entry\nin the @children array may be %NULL.\n\nAll items in the array must have the same type, which must be the\nsame as @child_type, if given.\n\nIf the @children are floating references (see g_variant_ref_sink()), the\nnew instance takes ownership of them as if via g_variant_ref_sink().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new #GVariant array</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"child_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"childType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the element type of the new array</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"children\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"children\" gs:managed-type=\"Variant[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">an array of\n           #GVariant pointers, the children</doc>\n        <array length=\"2\" zero-terminated=\"0\" c:type=\"GVariant**\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n        </array>\n      </parameter>\n      <parameter name=\"n_children\" transfer-ownership=\"none\" gs:managed-name=\"nChildren\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of @children</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"child_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"childType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the element type of the new array</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"children\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"children\" gs:managed-type=\"Variant[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">an array of\n           #GVariant pointers, the children</doc>\n        <array length=\"2\" zero-terminated=\"0\" c:type=\"GVariant**\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_boolean\" c:identifier=\"g_variant_new_boolean\" version=\"2.24\" gs:managed-name=\"NewBoolean\">\n    <doc xml:space=\"preserve\">Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new boolean #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">a #gboolean value</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">a #gboolean value</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_byte\" c:identifier=\"g_variant_new_byte\" version=\"2.24\" gs:managed-name=\"NewByte\">\n    <doc xml:space=\"preserve\">Creates a new byte #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new byte #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <doc xml:space=\"preserve\">a #guint8 value</doc>\n        <type name=\"guint8\" c:type=\"guchar\" gs:managed-name=\"Guint8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <doc xml:space=\"preserve\">a #guint8 value</doc>\n        <type name=\"guint8\" c:type=\"guchar\" gs:managed-name=\"Guint8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_bytestring\" c:identifier=\"g_variant_new_bytestring\" version=\"2.26\" gs:managed-name=\"NewBytestring\">\n    <doc xml:space=\"preserve\">Creates an array-of-bytes #GVariant with the contents of @string.\nThis function is just like g_variant_new_string() except that the\nstring need not be valid utf8.\n\nThe nul terminator character at the end of the string is stored in\nthe array.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new bytestring #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">a normal\n         nul-terminated string in no particular encoding</doc>\n        <array c:type=\"gchar*\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">a normal\n         nul-terminated string in no particular encoding</doc>\n        <array c:type=\"gchar*\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_bytestring_array\" c:identifier=\"g_variant_new_bytestring_array\" version=\"2.26\" gs:pinvoke-only=\"1\" gs:managed-name=\"NewBytestringArray\">\n    <doc xml:space=\"preserve\">Constructs an array of bytestring #GVariant from the given array of\nstrings.\n\nIf @length is -1 then @strv is %NULL-terminated.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new floating #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"strv\" transfer-ownership=\"none\" gs:managed-name=\"strv\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of strings</doc>\n        <array length=\"1\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the length of @strv, or -1</doc>\n        <type name=\"gssize\" c:type=\"gssize\" gs:managed-name=\"Gssize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"strv\" transfer-ownership=\"none\" gs:managed-name=\"strv\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of strings</doc>\n        <array length=\"1\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_dict_entry\" c:identifier=\"g_variant_new_dict_entry\" version=\"2.24\" gs:managed-name=\"NewDictEntry\">\n    <doc xml:space=\"preserve\">Creates a new dictionary entry #GVariant. @key and @value must be\nnon-%NULL. @key must be a value of a basic type (ie: not a container).\n\nIf the @key or @value are floating references (see g_variant_ref_sink()),\nthe new instance takes ownership of them as if via g_variant_ref_sink().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new dictionary entry #GVariant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a basic #GVariant, the key</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant, the value</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a basic #GVariant, the key</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant, the value</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_double\" c:identifier=\"g_variant_new_double\" version=\"2.24\" gs:managed-name=\"NewDouble\">\n    <doc xml:space=\"preserve\">Creates a new double #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new double #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">a #gdouble floating point value</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n        <doc xml:space=\"preserve\">a #gdouble floating point value</doc>\n        <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_fixed_array\" c:identifier=\"g_variant_new_fixed_array\" version=\"2.32\" gs:managed-name=\"NewFixedArray\">\n    <doc xml:space=\"preserve\">Provides access to the serialised data for an array of fixed-sized\nitems.\n\n@value must be an array with fixed-sized elements.  Numeric types are\nfixed-size as are tuples containing only other fixed-sized types.\n\n@element_size must be the size of a single element in the array.\nFor example, if calling this function for an array of 32-bit integers,\nyou might say sizeof(gint32). This value isn't used except for the purpose\nof a double-check that the form of the serialised data matches the caller's\nexpectation.\n\n@n_elements, which must be non-%NULL is set equal to the number of\nitems in the array.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new array #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"element_type\" transfer-ownership=\"none\" gs:managed-name=\"elementType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariantType of each element</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"elements\" transfer-ownership=\"none\" gs:managed-name=\"elements\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to the fixed array of contiguous elements</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"n_elements\" transfer-ownership=\"none\" gs:managed-name=\"nElements\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the number of elements</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"element_size\" transfer-ownership=\"none\" gs:managed-name=\"elementSize\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of each element</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"element_type\" transfer-ownership=\"none\" gs:managed-name=\"elementType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariantType of each element</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"elements\" transfer-ownership=\"none\" gs:managed-name=\"elements\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to the fixed array of contiguous elements</doc>\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"n_elements\" transfer-ownership=\"none\" gs:managed-name=\"nElements\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the number of elements</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"element_size\" transfer-ownership=\"none\" gs:managed-name=\"elementSize\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of each element</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_from_bytes\" c:identifier=\"g_variant_new_from_bytes\" version=\"2.36\" gs:managed-name=\"NewFromBytes\">\n    <doc xml:space=\"preserve\">Constructs a new serialised-mode #GVariant instance.  This is the\ninner interface for creation of new serialised values that gets\ncalled from various functions in gvariant.c.\n\nA reference is taken on @bytes.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GVariant with a floating reference</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </parameter>\n      <parameter name=\"trusted\" transfer-ownership=\"none\" gs:managed-name=\"trusted\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">if the contents of @bytes are trusted</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"bytes\" transfer-ownership=\"none\" gs:managed-name=\"bytes\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GBytes</doc>\n        <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n      </parameter>\n      <parameter name=\"trusted\" transfer-ownership=\"none\" gs:managed-name=\"trusted\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">if the contents of @bytes are trusted</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_from_data\" c:identifier=\"g_variant_new_from_data\" version=\"2.24\" gs:pinvoke-only=\"1\" gs:managed-name=\"NewFromData\">\n    <doc xml:space=\"preserve\">Creates a new #GVariant instance from serialised data.\n\n@type is the type of #GVariant instance that will be constructed.\nThe interpretation of @data depends on knowing the type.\n\n@data is not modified by this function and must remain valid with an\nunchanging value until such a time as @notify is called with\n@user_data.  If the contents of @data change before that time then\nthe result is undefined.\n\nIf @data is trusted to be serialised data in normal form then\n@trusted should be %TRUE.  This applies to serialised data created\nwithin this process or read from a trusted location on the disk (such\nas a file installed in /usr/lib alongside your application).  You\nshould set trusted to %FALSE if @data is read from the network, a\nfile in the user's home directory, etc.\n\nIf @data was not stored in this machine's native endianness, any multi-byte\nnumeric values in the returned variant will also be in non-native\nendianness. g_variant_byteswap() can be used to recover the original values.\n\n@notify will be called with @user_data when @data is no longer\nneeded.  The exact time of this call is unspecified and might even be\nbefore this function returns.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new floating #GVariant of type @type</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a definite #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">the serialised data</doc>\n        <array length=\"2\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n      <parameter name=\"size\" transfer-ownership=\"none\" gs:managed-name=\"size\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of @data</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"trusted\" transfer-ownership=\"none\" gs:managed-name=\"trusted\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE if @data is definitely in normal form</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">function to call when @data is no longer needed</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for @notify</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a definite #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n        <doc xml:space=\"preserve\">the serialised data</doc>\n        <array length=\"2\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n          <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n        </array>\n      </parameter>\n      <parameter name=\"trusted\" transfer-ownership=\"none\" gs:managed-name=\"trusted\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE if @data is definitely in normal form</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">function to call when @data is no longer needed</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data for @notify</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_handle\" c:identifier=\"g_variant_new_handle\" version=\"2.24\" gs:pinvoke-only=\"1\" gs:managed-name=\"NewHandle\">\n    <doc xml:space=\"preserve\">Creates a new handle #GVariant instance.\n\nBy convention, handles are indexes into an array of file descriptors\nthat are sent alongside a D-Bus message.  If you're not interacting\nwith D-Bus, you probably don't need them.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new handle #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">a #gint32 value</doc>\n        <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">a #gint32 value</doc>\n        <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_int16\" c:identifier=\"g_variant_new_int16\" version=\"2.24\" gs:managed-name=\"NewInt16\">\n    <doc xml:space=\"preserve\">Creates a new int16 #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new int16 #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int16\" gs:unmanaged-type=\"System.Int16\">\n        <doc xml:space=\"preserve\">a #gint16 value</doc>\n        <type name=\"gint16\" c:type=\"gint16\" gs:managed-name=\"Gint16\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int16\" gs:unmanaged-type=\"System.Int16\">\n        <doc xml:space=\"preserve\">a #gint16 value</doc>\n        <type name=\"gint16\" c:type=\"gint16\" gs:managed-name=\"Gint16\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_int32\" c:identifier=\"g_variant_new_int32\" version=\"2.24\" gs:managed-name=\"NewInt32\">\n    <doc xml:space=\"preserve\">Creates a new int32 #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new int32 #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">a #gint32 value</doc>\n        <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">a #gint32 value</doc>\n        <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_int64\" c:identifier=\"g_variant_new_int64\" version=\"2.24\" gs:managed-name=\"NewInt64\">\n    <doc xml:space=\"preserve\">Creates a new int64 #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new int64 #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">a #gint64 value</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">a #gint64 value</doc>\n        <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_maybe\" c:identifier=\"g_variant_new_maybe\" version=\"2.24\" gs:managed-name=\"NewMaybe\">\n    <doc xml:space=\"preserve\">Depending on if @child is %NULL, either wraps @child inside of a\nmaybe container or creates a Nothing instance for the given @type.\n\nAt least one of @child_type and @child must be non-%NULL.\nIf @child_type is non-%NULL then it must be a definite type.\nIf they are both non-%NULL then @child_type must be the type\nof @child.\n\nIf @child is a floating reference (see g_variant_ref_sink()), the new\ninstance takes ownership of @child.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new #GVariant maybe instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"child_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"childType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariantType of the child, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"child\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"child\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the child value, or %NULL</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"child_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"childType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariantType of the child, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"child\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"child\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the child value, or %NULL</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_object_path\" c:identifier=\"g_variant_new_object_path\" version=\"2.24\" gs:pinvoke-only=\"1\" gs:managed-name=\"NewObjectPath\">\n    <doc xml:space=\"preserve\">Creates a D-Bus object path #GVariant with the contents of @string.\n@string must be a valid D-Bus object path.  Use\ng_variant_is_object_path() if you're not sure.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new object path #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"object_path\" transfer-ownership=\"none\" gs:managed-name=\"objectPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"object_path\" transfer-ownership=\"none\" gs:managed-name=\"objectPath\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_objv\" c:identifier=\"g_variant_new_objv\" version=\"2.30\" gs:pinvoke-only=\"1\" gs:managed-name=\"NewObjv\">\n    <doc xml:space=\"preserve\">Constructs an array of object paths #GVariant from the given array of\nstrings.\n\nEach string must be a valid #GVariant object path; see\ng_variant_is_object_path().\n\nIf @length is -1 then @strv is %NULL-terminated.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new floating #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"strv\" transfer-ownership=\"none\" gs:managed-name=\"strv\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of strings</doc>\n        <array length=\"1\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the length of @strv, or -1</doc>\n        <type name=\"gssize\" c:type=\"gssize\" gs:managed-name=\"Gssize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"strv\" transfer-ownership=\"none\" gs:managed-name=\"strv\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of strings</doc>\n        <array length=\"1\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_parsed_va\" c:identifier=\"g_variant_new_parsed_va\" introspectable=\"0\" gs:managed-name=\"NewParsedVa\">\n    <doc xml:space=\"preserve\">Parses @format and returns the result.\n\nThis is the version of g_variant_new_parsed() intended to be used\nfrom libraries.\n\nThe return value will be floating if it was a newly created GVariant\ninstance.  In the case that @format simply specified the collection\nof a #GVariant pointer (eg: @format was \"%*\") then the collected\n#GVariant pointer will be returned unmodified, without adding any\nadditional references.\n\nNote that the arguments in @app must be of the correct width for their types\nspecified in @format when collected into the #va_list. See\nthe [GVariant varargs documentation][gvariant-varargs].\n\nIn order to behave correctly in all cases it is necessary for the\ncalling function to g_variant_ref_sink() the return result before\nreturning control to the user that originally provided the pointer.\nAt this point, the caller will have their own full reference to the\nresult.  This can also be done by adding the result to a container,\nor by passing it to another g_variant_new() call.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new, usually floating, #GVariant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a text format #GVariant</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"app\" transfer-ownership=\"none\" gs:managed-name=\"app\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #va_list</doc>\n        <type name=\"va_list\" c:type=\"va_list*\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a text format #GVariant</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"app\" transfer-ownership=\"none\" gs:managed-name=\"app\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #va_list</doc>\n        <type name=\"va_list\" c:type=\"va_list*\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_signature\" c:identifier=\"g_variant_new_signature\" version=\"2.24\" gs:pinvoke-only=\"1\" gs:managed-name=\"NewSignature\">\n    <doc xml:space=\"preserve\">Creates a D-Bus type signature #GVariant with the contents of\n@string.  @string must be a valid D-Bus type signature.  Use\ng_variant_is_signature() if you're not sure.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new signature #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"signature\" transfer-ownership=\"none\" gs:managed-name=\"signature\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"signature\" transfer-ownership=\"none\" gs:managed-name=\"signature\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_strv\" c:identifier=\"g_variant_new_strv\" version=\"2.24\" gs:managed-name=\"NewStrv\">\n    <doc xml:space=\"preserve\">Constructs an array of strings #GVariant from the given array of\nstrings.\n\nIf @length is -1 then @strv is %NULL-terminated.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new floating #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"strv\" transfer-ownership=\"none\" gs:managed-name=\"strv\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">an array of strings</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n        <doc xml:space=\"preserve\">the length of @strv, or -1</doc>\n        <type name=\"gssize\" c:type=\"gssize\" gs:managed-name=\"Gssize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"strv\" transfer-ownership=\"none\" gs:managed-name=\"strv\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">an array of strings</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_take_string\" c:identifier=\"g_variant_new_take_string\" version=\"2.38\" introspectable=\"0\" gs:managed-name=\"NewTakeString\">\n    <doc xml:space=\"preserve\">Creates a string #GVariant with the contents of @string.\n\n@string must be valid utf8.\n\nThis function consumes @string.  g_free() will be called on @string\nwhen it is no longer required.\n\nYou must not modify or access @string in any other way after passing\nit to this function.  It is even possible that @string is immediately\nfreed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new string\n  #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal utf8 nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal utf8 nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_tuple\" c:identifier=\"g_variant_new_tuple\" version=\"2.24\" gs:managed-name=\"NewTuple\">\n    <doc xml:space=\"preserve\">Creates a new tuple #GVariant out of the items in @children.  The\ntype is determined from the types of @children.  No entry in the\n@children array may be %NULL.\n\nIf @n_children is 0 then the unit tuple is constructed.\n\nIf the @children are floating references (see g_variant_ref_sink()), the\nnew instance takes ownership of them as if via g_variant_ref_sink().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new #GVariant tuple</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"children\" transfer-ownership=\"none\" gs:managed-name=\"children\" gs:managed-type=\"Variant[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">the items to make the tuple out of</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"GVariant**\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n        </array>\n      </parameter>\n      <parameter name=\"n_children\" transfer-ownership=\"none\" gs:managed-name=\"nChildren\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of @children</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"children\" transfer-ownership=\"none\" gs:managed-name=\"children\" gs:managed-type=\"Variant[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">the items to make the tuple out of</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"GVariant**\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_uint16\" c:identifier=\"g_variant_new_uint16\" version=\"2.24\" gs:managed-name=\"NewUint16\">\n    <doc xml:space=\"preserve\">Creates a new uint16 #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new uint16 #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n        <doc xml:space=\"preserve\">a #guint16 value</doc>\n        <type name=\"guint16\" c:type=\"guint16\" gs:managed-name=\"Guint16\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n        <doc xml:space=\"preserve\">a #guint16 value</doc>\n        <type name=\"guint16\" c:type=\"guint16\" gs:managed-name=\"Guint16\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_uint32\" c:identifier=\"g_variant_new_uint32\" version=\"2.24\" gs:managed-name=\"NewUint32\">\n    <doc xml:space=\"preserve\">Creates a new uint32 #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new uint32 #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">a #guint32 value</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">a #guint32 value</doc>\n        <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_uint64\" c:identifier=\"g_variant_new_uint64\" version=\"2.24\" gs:managed-name=\"NewUint64\">\n    <doc xml:space=\"preserve\">Creates a new uint64 #GVariant instance.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new uint64 #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">a #guint64 value</doc>\n        <type name=\"guint64\" c:type=\"guint64\" gs:managed-name=\"Guint64\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">a #guint64 value</doc>\n        <type name=\"guint64\" c:type=\"guint64\" gs:managed-name=\"Guint64\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_va\" c:identifier=\"g_variant_new_va\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"NewVa\">\n    <doc xml:space=\"preserve\">This function is intended to be used by libraries based on\n#GVariant that want to provide g_variant_new()-like functionality\nto their users.\n\nThe API is more general than g_variant_new() to allow a wider range\nof possible uses.\n\n@format_string must still point to a valid format string, but it only\nneeds to be nul-terminated if @endptr is %NULL.  If @endptr is\nnon-%NULL then it is updated to point to the first character past the\nend of the format string.\n\n@app is a pointer to a #va_list.  The arguments, according to\n@format_string, are collected from this #va_list and the list is left\npointing to the argument following the last.\n\nNote that the arguments in @app must be of the correct width for their\ntypes specified in @format_string when collected into the #va_list.\nSee the [GVariant varargs documentation][gvariant-varargs.\n\nThese two generalisations allow mixing of multiple calls to\ng_variant_new_va() and g_variant_get_va() within a single actual\nvarargs call by the user.\n\nThe return value will be floating if it was a newly created GVariant\ninstance (for example, if the format string was \"(ii)\").  In the case\nthat the format_string was '*', '?', 'r', or a format starting with\n'@' then the collected #GVariant pointer will be returned unmodified,\nwithout adding any additional references.\n\nIn order to behave correctly in all cases it is necessary for the\ncalling function to g_variant_ref_sink() the return result before\nreturning control to the user that originally provided the pointer.\nAt this point, the caller will have their own full reference to the\nresult.  This can also be done by adding the result to a container,\nor by passing it to another g_variant_new() call.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new, usually floating, #GVariant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"format_string\" transfer-ownership=\"none\" gs:managed-name=\"formatString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string that is prefixed with a format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">location to store the end pointer,\n         or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"app\" transfer-ownership=\"none\" gs:managed-name=\"app\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #va_list</doc>\n        <type name=\"va_list\" c:type=\"va_list*\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"format_string\" transfer-ownership=\"none\" gs:managed-name=\"formatString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string that is prefixed with a format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">location to store the end pointer,\n         or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"app\" transfer-ownership=\"none\" gs:managed-name=\"app\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #va_list</doc>\n        <type name=\"va_list\" c:type=\"va_list*\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <constructor name=\"new_variant\" c:identifier=\"g_variant_new_variant\" version=\"2.24\" gs:managed-name=\"NewVariant\">\n    <doc xml:space=\"preserve\">Boxes @value.  The result is a #GVariant instance representing a\nvariant containing the original value.\n\nIf @child is a floating reference (see g_variant_ref_sink()), the new\ninstance takes ownership of @child.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a floating reference to a new variant #GVariant instance</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"byteswap\" c:identifier=\"g_variant_byteswap\" version=\"2.24\" gs:managed-name=\"Byteswap\">\n    <doc xml:space=\"preserve\">Performs a byteswapping operation on the contents of @value.  The\nresult is that all multi-byte numeric data contained in @value is\nbyteswapped.  That includes 16, 32, and 64bit signed and unsigned\nintegers as well as file handles and double precision floating point\nvalues.\n\nThis function is an identity mapping on any value that does not\ncontain multi-byte numeric data.  That include strings, booleans,\nbytes and containers containing only these things (recursively).\n\nThe returned value is always in normal form and is marked as trusted.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the byteswapped form of @value</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"check_format_string\" c:identifier=\"g_variant_check_format_string\" version=\"2.34\" gs:managed-name=\"CheckFormatString\">\n    <doc xml:space=\"preserve\">Checks if calling g_variant_get() with @format_string on @value would\nbe valid from a type-compatibility standpoint.  @format_string is\nassumed to be a valid format string (from a syntactic standpoint).\n\nIf @copy_only is %TRUE then this function additionally checks that it\nwould be safe to call g_variant_unref() on @value immediately after\nthe call to g_variant_get() without invalidating the result.  This is\nonly possible if deep copies are made (ie: there are no pointers to\nthe data inside of the soon-to-be-freed #GVariant instance).  If this\ncheck fails then a g_critical() is printed and %FALSE is returned.\n\nThis function is meant to be used by functions that wish to provide\nvarargs accessors to #GVariant values of uncertain values (eg:\ng_variant_lookup() or g_menu_model_get_item_attribute()).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @format_string is safe to use</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"format_string\" transfer-ownership=\"none\" gs:managed-name=\"formatString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid #GVariant format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"copy_only\" transfer-ownership=\"none\" gs:managed-name=\"copyOnly\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE to ensure the format string makes deep copies</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"format_string\" transfer-ownership=\"none\" gs:managed-name=\"formatString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid #GVariant format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"copy_only\" transfer-ownership=\"none\" gs:managed-name=\"copyOnly\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE to ensure the format string makes deep copies</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"classify\" c:identifier=\"g_variant_classify\" version=\"2.24\" gs:managed-name=\"Classify\">\n    <doc xml:space=\"preserve\">Classifies @value according to its top-level type.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantClass\" gs:unmanaged-type=\"VariantClass\">\n      <doc xml:space=\"preserve\">the #GVariantClass of @value</doc>\n      <type name=\"VariantClass\" c:type=\"GVariantClass\" gs:managed-name=\"VariantClass\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"compare\" c:identifier=\"g_variant_compare\" version=\"2.26\" gs:managed-name=\"CompareTo\" gs:special-func=\"compare\">\n    <doc xml:space=\"preserve\">Compares @one and @two.\n\nThe types of @one and @two are #gconstpointer only to allow use of\nthis function with #GTree, #GPtrArray, etc.  They must each be a\n#GVariant.\n\nComparison is only defined for basic types (ie: booleans, numbers,\nstrings).  For booleans, %FALSE is less than %TRUE.  Numbers are\nordered in the usual way.  Strings are in ASCII lexographical order.\n\nIt is a programmer error to attempt to compare container values or\ntwo values that have types that are not exactly equal.  For example,\nyou cannot compare a 32-bit signed integer with a 32-bit unsigned\ninteger.  Also note that this function is not particularly\nwell-behaved when it comes to comparison of doubles; in particular,\nthe handling of incomparable values (ie: NaN) is undefined.\n\nIf you only require an equality comparison, g_variant_equal() is more\ngeneral.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">negative value if a &lt; b;\n         zero if a = b;\n         positive value if a &gt; b.</doc>\n      <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"one\" transfer-ownership=\"none\" gs:managed-name=\"one\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a basic-typed #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"two\" transfer-ownership=\"none\" gs:managed-name=\"two\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance of the same type</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"two\" transfer-ownership=\"none\" gs:managed-name=\"two\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance of the same type</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"equal\" c:identifier=\"g_variant_equal\" version=\"2.24\" gs:managed-name=\"Equals\" gs:special-func=\"equal\">\n    <doc xml:space=\"preserve\">Checks if @one and @two have the same type and value.\n\nThe types of @one and @two are #gconstpointer only to allow use of\nthis function with #GHashTable.  They must each be a #GVariant.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @one and @two are equal</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"one\" transfer-ownership=\"none\" gs:managed-name=\"one\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"two\" transfer-ownership=\"none\" gs:managed-name=\"two\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"two\" transfer-ownership=\"none\" gs:managed-name=\"two\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_boolean\" c:identifier=\"g_variant_get_boolean\" version=\"2.24\" gs:managed-name=\"get_Boolean\" gs:property=\"Boolean\">\n    <doc xml:space=\"preserve\">Returns the boolean value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_BOOLEAN.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE or %FALSE</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a boolean #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_byte\" c:identifier=\"g_variant_get_byte\" version=\"2.24\" gs:managed-name=\"get_Byte\" gs:property=\"Byte\">\n    <doc xml:space=\"preserve\">Returns the byte value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_BYTE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n      <doc xml:space=\"preserve\">a #guchar</doc>\n      <type name=\"guint8\" c:type=\"guchar\" gs:managed-name=\"Guint8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a byte #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_bytestring\" c:identifier=\"g_variant_get_bytestring\" version=\"2.26\" gs:managed-name=\"get_Bytestring\" gs:property=\"Bytestring\">\n    <doc xml:space=\"preserve\">Returns the string value of a #GVariant instance with an\narray-of-bytes type.  The string has no particular encoding.\n\nIf the array does not end with a nul terminator character, the empty\nstring is returned.  For this reason, you can always trust that a\nnon-%NULL nul-terminated string will be returned by this function.\n\nIf the array contains a nul terminator character somewhere other than\nthe last byte then the returned string is the string, up to the first\nsuch nul character.\n\nIt is an error to call this function with a @value that is not an\narray of bytes.\n\nThe return value remains valid as long as @value exists.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Byte[]\" gs:unmanaged-type=\"System.Byte[]\">\n      <doc xml:space=\"preserve\">\n         the constant string</doc>\n      <array c:type=\"gchar*\" gs:managed-type=\"System.Byte\" gs:unmanaged-type=\"System.Byte\">\n        <type name=\"guint8\" gs:managed-name=\"Guint8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array-of-bytes #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_bytestring_array\" c:identifier=\"g_variant_get_bytestring_array\" version=\"2.26\" gs:pinvoke-only=\"1\" gs:managed-name=\"GetBytestringArray\">\n    <doc xml:space=\"preserve\">Gets the contents of an array of array of bytes #GVariant.  This call\nmakes a shallow copy; the return result should be released with\ng_free(), but the individual strings must not be modified.\n\nIf @length is non-%NULL then the number of elements in the result is\nstored there.  In any case, the resulting array will be\n%NULL-terminated.\n\nFor an empty array, @length will be set to 0 and a pointer to a\n%NULL pointer will be returned.</doc>\n    <return-value transfer-ownership=\"container\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an array of constant strings</doc>\n      <array length=\"0\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of array of bytes #GVariant ('aay')</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of the result, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_child_value\" c:identifier=\"g_variant_get_child_value\" version=\"2.24\" gs:managed-name=\"GetChildValue\">\n    <doc xml:space=\"preserve\">Reads a child item out of a container #GVariant instance.  This\nincludes variants, maybes, arrays, tuples and dictionary\nentries.  It is an error to call this function on any other type of\n#GVariant.\n\nIt is an error if @index_ is greater than the number of child items\nin the container.  See g_variant_n_children().\n\nThe returned value is never floating.  You should free it with\ng_variant_unref() when you're done with it.\n\nThis function is O(1).</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the child at the specified index</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the index of the child to fetch</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"index_\" transfer-ownership=\"none\" gs:managed-name=\"index\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the index of the child to fetch</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_data\" c:identifier=\"g_variant_get_data\" version=\"2.24\" gs:managed-name=\"get_Data\" gs:property=\"Data\">\n    <doc xml:space=\"preserve\">Returns a pointer to the serialised form of a #GVariant instance.\nThe returned data may not be in fully-normalised form if read from an\nuntrusted source.  The returned data must not be freed; it remains\nvalid for as long as @value exists.\n\nIf @value is a fixed-sized value that was deserialised from a\ncorrupted serialised container then %NULL may be returned.  In this\ncase, the proper thing to do is typically to use the appropriate\nnumber of nul bytes in place of @value.  If @value is not fixed-sized\nthen %NULL is never returned.\n\nIn the case that @value is already in serialised form, this function\nis O(1).  If the value is not already in serialised form,\nserialisation occurs implicitly and is approximately O(n) in the size\nof the result.\n\nTo deserialise the data returned by this function, in addition to the\nserialised data, you must know the type of the #GVariant, and (if the\nmachine might be different) the endianness of the machine that stored\nit. As a result, file formats or network messages that incorporate\nserialised #GVariants must include this information either\nimplicitly (for instance \"the file always contains a\n%G_VARIANT_TYPE_VARIANT and it is always in little-endian order\") or\nexplicitly (by storing the type and/or endianness in addition to the\nserialised data).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the serialised form of @value, or %NULL</doc>\n      <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_data_as_bytes\" c:identifier=\"g_variant_get_data_as_bytes\" version=\"2.36\" gs:managed-name=\"get_DataAsBytes\" gs:property=\"DataAsBytes\">\n    <doc xml:space=\"preserve\">Returns a pointer to the serialised form of a #GVariant instance.\nThe semantics of this function are exactly the same as\ng_variant_get_data(), except that the returned #GBytes holds\na reference to the variant data.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Bytes\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">A new #GBytes representing the variant data</doc>\n      <type name=\"Bytes\" c:type=\"GBytes*\" gs:managed-name=\"Bytes\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_double\" c:identifier=\"g_variant_get_double\" version=\"2.24\" gs:managed-name=\"get_Double\" gs:property=\"Double\">\n    <doc xml:space=\"preserve\">Returns the double precision floating point value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_DOUBLE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Double\" gs:unmanaged-type=\"System.Double\">\n      <doc xml:space=\"preserve\">a #gdouble</doc>\n      <type name=\"gdouble\" c:type=\"gdouble\" gs:managed-name=\"Gdouble\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a double #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_fixed_array\" c:identifier=\"g_variant_get_fixed_array\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"GetFixedArray\">\n    <doc xml:space=\"preserve\">Provides access to the serialised data for an array of fixed-sized\nitems.\n\n@value must be an array with fixed-sized elements.  Numeric types are\nfixed-size, as are tuples containing only other fixed-sized types.\n\n@element_size must be the size of a single element in the array,\nas given by the section on\n[serialized data memory][gvariant-serialised-data-memory].\n\nIn particular, arrays of these fixed-sized types can be interpreted\nas an array of the given C type, with @element_size set to the size\nthe appropriate type:\n- %G_VARIANT_TYPE_INT16 (etc.): #gint16 (etc.)\n- %G_VARIANT_TYPE_BOOLEAN: #guchar (not #gboolean!)\n- %G_VARIANT_TYPE_BYTE: #guchar\n- %G_VARIANT_TYPE_HANDLE: #guint32\n- %G_VARIANT_TYPE_DOUBLE: #gdouble\n\nFor example, if calling this function for an array of 32-bit integers,\nyou might say sizeof(gint32). This value isn't used except for the purpose\nof a double-check that the form of the serialised data matches the caller's\nexpectation.\n\n@n_elements, which must be non-%NULL is set equal to the number of\nitems in the array.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.IntPtr[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n      <doc xml:space=\"preserve\">a pointer to\n    the fixed array</doc>\n      <array length=\"0\" zero-terminated=\"0\" c:type=\"gconstpointer\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"gpointer\" c:type=\"gconstpointer\" gs:managed-name=\"Gpointer\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant array with fixed-sized elements</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"n_elements\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" gs:managed-name=\"nElements\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">a pointer to the location to store the number of items</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n      <parameter name=\"element_size\" transfer-ownership=\"none\" gs:managed-name=\"elementSize\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of each element</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"element_size\" transfer-ownership=\"none\" gs:managed-name=\"elementSize\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the size of each element</doc>\n        <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_d_bus_handle\" c:identifier=\"g_variant_get_handle\" version=\"2.24\" gs:managed-name=\"get_DBusHandle\" gs:property=\"DBusHandle\">\n    <doc xml:space=\"preserve\">Returns the 32-bit signed integer value of @value.\n\nIt is an error to call this function with a @value of any type other\nthan %G_VARIANT_TYPE_HANDLE.\n\nBy convention, handles are indexes into an array of file descriptors\nthat are sent alongside a D-Bus message.  If you're not interacting\nwith D-Bus, you probably don't need them.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">a #gint32</doc>\n      <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a handle #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_int16\" c:identifier=\"g_variant_get_int16\" version=\"2.24\" gs:managed-name=\"get_Int16\" gs:property=\"Int16\">\n    <doc xml:space=\"preserve\">Returns the 16-bit signed integer value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_INT16.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int16\" gs:unmanaged-type=\"System.Int16\">\n      <doc xml:space=\"preserve\">a #gint16</doc>\n      <type name=\"gint16\" c:type=\"gint16\" gs:managed-name=\"Gint16\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a int16 #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_int32\" c:identifier=\"g_variant_get_int32\" version=\"2.24\" gs:managed-name=\"get_Int32\" gs:property=\"Int32\">\n    <doc xml:space=\"preserve\">Returns the 32-bit signed integer value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_INT32.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n      <doc xml:space=\"preserve\">a #gint32</doc>\n      <type name=\"gint32\" c:type=\"gint32\" gs:managed-name=\"Gint32\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a int32 #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_int64\" c:identifier=\"g_variant_get_int64\" version=\"2.24\" gs:managed-name=\"get_Int64\" gs:property=\"Int64\">\n    <doc xml:space=\"preserve\">Returns the 64-bit signed integer value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_INT64.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Int64\" gs:unmanaged-type=\"System.Int64\">\n      <doc xml:space=\"preserve\">a #gint64</doc>\n      <type name=\"gint64\" c:type=\"gint64\" gs:managed-name=\"Gint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a int64 #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_maybe\" c:identifier=\"g_variant_get_maybe\" version=\"2.24\" gs:managed-name=\"get_Maybe\" gs:property=\"Maybe\">\n    <doc xml:space=\"preserve\">Given a maybe-typed #GVariant instance, extract its value.  If the\nvalue is Nothing, then this function returns %NULL.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the contents of @value, or %NULL</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a maybe-typed value</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_normal_form\" c:identifier=\"g_variant_get_normal_form\" version=\"2.24\" gs:managed-name=\"get_NormalForm\" gs:property=\"NormalForm\">\n    <doc xml:space=\"preserve\">Gets a #GVariant instance that has the same value as @value and is\ntrusted to be in normal form.\n\nIf @value is already trusted to be in normal form then a new\nreference to @value is returned.\n\nIf @value is not already trusted, then it is scanned to check if it\nis in normal form.  If it is found to be in normal form then it is\nmarked as trusted and a new reference to it is returned.\n\nIf @value is found not to be in normal form then a new trusted\n#GVariant is created with the same value as @value.\n\nIt makes sense to call this function if you've received #GVariant\ndata from untrusted sources and you want to ensure your serialised\noutput is definitely in normal form.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a trusted #GVariant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_objv\" c:identifier=\"g_variant_get_objv\" version=\"2.30\" gs:pinvoke-only=\"1\" gs:managed-name=\"GetObjv\">\n    <doc xml:space=\"preserve\">Gets the contents of an array of object paths #GVariant.  This call\nmakes a shallow copy; the return result should be released with\ng_free(), but the individual strings must not be modified.\n\nIf @length is non-%NULL then the number of elements in the result\nis stored there.  In any case, the resulting array will be\n%NULL-terminated.\n\nFor an empty array, @length will be set to 0 and a pointer to a\n%NULL pointer will be returned.</doc>\n    <return-value transfer-ownership=\"container\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an array of constant strings</doc>\n      <array length=\"0\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of object paths #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of the result, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_size\" c:identifier=\"g_variant_get_size\" version=\"2.24\" gs:managed-name=\"get_Size\" gs:property=\"Size\">\n    <doc xml:space=\"preserve\">Determines the number of bytes that would be required to store @value\nwith g_variant_store().\n\nIf @value has a fixed-sized type then this function always returned\nthat fixed size.\n\nIn the case that @value is already in serialised form or the size has\nalready been calculated (ie: this function has been called before)\nthen this function is O(1).  Otherwise, the size is calculated, an\noperation which is approximately O(n) in the number of values\ninvolved.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the serialised size of @value</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_string\" c:identifier=\"g_variant_get_string\" version=\"2.24\" gs:managed-name=\"GetString\">\n    <doc xml:space=\"preserve\">Returns the string value of a #GVariant instance with a string\ntype.  This includes the types %G_VARIANT_TYPE_STRING,\n%G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.\n\nThe string will always be utf8 encoded.\n\nIf @length is non-%NULL then the length of the string (in bytes) is\nreturned there.  For trusted values, this information is already\nknown.  For untrusted values, a strlen() will be performed.\n\nIt is an error to call this function with a @value of any type\nother than those three.\n\nThe return value remains valid as long as @value exists.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the constant string, utf8 encoded</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">a pointer to a #gsize,\n         to store the length</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">a pointer to a #gsize,\n         to store the length</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_strv\" c:identifier=\"g_variant_get_strv\" version=\"2.24\" gs:managed-name=\"get_Strv\" gs:property=\"Strv\">\n    <doc xml:space=\"preserve\">Gets the contents of an array of strings #GVariant.  This call\nmakes a shallow copy; the return result should be released with\ng_free(), but the individual strings must not be modified.\n\nIf @length is non-%NULL then the number of elements in the result\nis stored there.  In any case, the resulting array will be\n%NULL-terminated.\n\nFor an empty array, @length will be set to 0 and a pointer to a\n%NULL pointer will be returned.</doc>\n    <return-value transfer-ownership=\"container\" gs:managed-type=\"System.String[]\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">an array of constant strings</doc>\n      <array length=\"0\" zero-terminated=\"1\" c:type=\"gchar**\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" gs:managed-name=\"Utf8\" />\n      </array>\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array of strings #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"length\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"length\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n        <doc xml:space=\"preserve\">the length of the result, or %NULL</doc>\n        <type name=\"gsize\" c:type=\"gsize*\" gs:managed-name=\"Gsize\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_variant_type\" c:identifier=\"g_variant_get_type\" version=\"2.24\" gs:managed-name=\"get_VariantType\" gs:property=\"VariantType\">\n    <doc xml:space=\"preserve\">Determines the type of @value.\n\nThe return value is valid for the lifetime of @value and must not\nbe freed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GVariantType</doc>\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_type_string\" c:identifier=\"g_variant_get_type_string\" version=\"2.24\" gs:managed-name=\"get_TypeString\" gs:property=\"TypeString\">\n    <doc xml:space=\"preserve\">Returns the type string of @value.  Unlike the result of calling\ng_variant_type_peek_string(), this string is nul-terminated.  This\nstring belongs to #GVariant and must not be freed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the type string for the type of @value</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_uint16\" c:identifier=\"g_variant_get_uint16\" version=\"2.24\" gs:managed-name=\"get_Uint16\" gs:property=\"Uint16\">\n    <doc xml:space=\"preserve\">Returns the 16-bit unsigned integer value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_UINT16.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt16\" gs:unmanaged-type=\"System.UInt16\">\n      <doc xml:space=\"preserve\">a #guint16</doc>\n      <type name=\"guint16\" c:type=\"guint16\" gs:managed-name=\"Guint16\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a uint16 #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_uint32\" c:identifier=\"g_variant_get_uint32\" version=\"2.24\" gs:managed-name=\"get_Uint32\" gs:property=\"Uint32\">\n    <doc xml:space=\"preserve\">Returns the 32-bit unsigned integer value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_UINT32.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">a #guint32</doc>\n      <type name=\"guint32\" c:type=\"guint32\" gs:managed-name=\"Guint32\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a uint32 #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_uint64\" c:identifier=\"g_variant_get_uint64\" version=\"2.24\" gs:managed-name=\"get_Uint64\" gs:property=\"Uint64\">\n    <doc xml:space=\"preserve\">Returns the 64-bit unsigned integer value of @value.\n\nIt is an error to call this function with a @value of any type\nother than %G_VARIANT_TYPE_UINT64.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">a #guint64</doc>\n      <type name=\"guint64\" c:type=\"guint64\" gs:managed-name=\"Guint64\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a uint64 #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_va\" c:identifier=\"g_variant_get_va\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"GetVa\">\n    <doc xml:space=\"preserve\">This function is intended to be used by libraries based on #GVariant\nthat want to provide g_variant_get()-like functionality to their\nusers.\n\nThe API is more general than g_variant_get() to allow a wider range\nof possible uses.\n\n@format_string must still point to a valid format string, but it only\nneed to be nul-terminated if @endptr is %NULL.  If @endptr is\nnon-%NULL then it is updated to point to the first character past the\nend of the format string.\n\n@app is a pointer to a #va_list.  The arguments, according to\n@format_string, are collected from this #va_list and the list is left\npointing to the argument following the last.\n\nThese two generalisations allow mixing of multiple calls to\ng_variant_new_va() and g_variant_get_va() within a single actual\nvarargs call by the user.\n\n@format_string determines the C types that are used for unpacking\nthe values and also determines if the values are copied or borrowed,\nsee the section on\n[GVariant format strings][gvariant-format-strings-pointers].</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"format_string\" transfer-ownership=\"none\" gs:managed-name=\"formatString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string that is prefixed with a format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">location to store the end pointer,\n         or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"app\" transfer-ownership=\"none\" gs:managed-name=\"app\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #va_list</doc>\n        <type name=\"va_list\" c:type=\"va_list*\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"format_string\" transfer-ownership=\"none\" gs:managed-name=\"formatString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string that is prefixed with a format string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">location to store the end pointer,\n         or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"app\" transfer-ownership=\"none\" gs:managed-name=\"app\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #va_list</doc>\n        <type name=\"va_list\" c:type=\"va_list*\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"get_boxed_variant\" c:identifier=\"g_variant_get_variant\" version=\"2.24\" gs:managed-name=\"get_BoxedVariant\" gs:property=\"BoxedVariant\">\n    <doc xml:space=\"preserve\">Unboxes @value.  The result is the #GVariant instance that was\ncontained in @value.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the item contained in the variant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a variant #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"hash\" c:identifier=\"g_variant_hash\" version=\"2.24\" gs:managed-name=\"Hash\" gs:special-func=\"hash\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Generates a hash value for a #GVariant instance.\n\nThe output of this function is guaranteed to be the same for a given\nvalue only per-process.  It may change between different processor\narchitectures or even different versions of GLib.  Do not use this\nfunction as a basis for building protocols or file formats.\n\nThe type of @value is #gconstpointer only to allow use of this\nfunction with #GHashTable.  @value must be a #GVariant.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">a hash value corresponding to @value</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a basic #GVariant value as a #gconstpointer</doc>\n        <type name=\"Variant\" c:type=\"gconstpointer\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_container\" c:identifier=\"g_variant_is_container\" version=\"2.24\" gs:managed-name=\"get_IsContainer\" gs:property=\"IsContainer\">\n    <doc xml:space=\"preserve\">Checks if @value is a container.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @value is a container</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_normal_form\" c:identifier=\"g_variant_is_normal_form\" version=\"2.24\" gs:managed-name=\"get_IsNormalForm\" gs:property=\"IsNormalForm\">\n    <doc xml:space=\"preserve\">Checks if @value is in normal form.\n\nThe main reason to do this is to detect if a given chunk of\nserialised data is in normal form: load the data into a #GVariant\nusing g_variant_new_from_data() and then use this function to\ncheck.\n\nIf @value is found to be in normal form then it will be marked as\nbeing trusted.  If the value was already marked as being trusted then\nthis function will immediately return %TRUE.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @value is in normal form</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_of_type\" c:identifier=\"g_variant_is_of_type\" version=\"2.24\" gs:managed-name=\"IsOfType\">\n    <doc xml:space=\"preserve\">Checks if a value has a type matching the provided type.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the type of @value matches @type</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant instance</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"iter_new\" c:identifier=\"g_variant_iter_new\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"IterNew\">\n    <doc xml:space=\"preserve\">Creates a heap-allocated #GVariantIter for iterating over the items\nin @value.\n\nUse g_variant_iter_free() to free the return value when you no longer\nneed it.\n\nA reference is taken to @value and will be released only when\ng_variant_iter_free() is called.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new heap-allocated #GVariantIter</doc>\n      <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"lookup_value\" c:identifier=\"g_variant_lookup_value\" version=\"2.28\" gs:managed-name=\"LookupValue\">\n    <doc xml:space=\"preserve\">Looks up a value in a dictionary #GVariant.\n\nThis function works with dictionaries of the type a{s*} (and equally\nwell with type a{o*}, but we only further discuss the string case\nfor sake of clarity).\n\nIn the event that @dictionary has the type a{sv}, the @expected_type\nstring specifies what type of value is expected to be inside of the\nvariant. If the value inside the variant has a different type then\n%NULL is returned. In the event that @dictionary has a value type other\nthan v then @expected_type must directly match the key type and it is\nused to unpack the value directly or an error occurs.\n\nIn either case, if @key is not found in @dictionary, %NULL is returned.\n\nIf the key is found and the value has the correct type, it is\nreturned.  If @expected_type was specified then any non-%NULL return\nvalue will have this type.\n\nThis function is currently implemented with a linear scan.  If you\nplan to do many lookups then #GVariantDict may be more efficient.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value of the dictionary key, or %NULL</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dictionary\" transfer-ownership=\"none\" gs:managed-name=\"dictionary\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a dictionary #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to lookup in the dictionary</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"expected_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"expectedType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to lookup in the dictionary</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"expected_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"expectedType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"n_children\" c:identifier=\"g_variant_n_children\" version=\"2.24\" gs:managed-name=\"NChildren\">\n    <doc xml:space=\"preserve\">Determines the number of children in a container #GVariant instance.\nThis includes variants, maybes, arrays, tuples and dictionary\nentries.  It is an error to call this function on any other type of\n#GVariant.\n\nFor variants, the return value is always 1.  For values with maybe\ntypes, it is always zero or one.  For arrays, it is the length of the\narray.  For tuples it is the number of tuple items (which depends\nonly on the type).  For dictionary entries, it is always 2\n\nThis function is O(1).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the number of children in the container</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"print\" c:identifier=\"g_variant_print\" version=\"2.24\" gs:managed-name=\"Print\">\n    <doc xml:space=\"preserve\">Pretty-prints @value in the format understood by g_variant_parse().\n\nThe format is described [here][gvariant-text].\n\nIf @type_annotate is %TRUE, then type information is included in\nthe output.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a newly-allocated string holding the result.</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"type_annotate\" transfer-ownership=\"none\" gs:managed-name=\"typeAnnotate\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE if type information should be included in\n                the output</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type_annotate\" transfer-ownership=\"none\" gs:managed-name=\"typeAnnotate\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n        <doc xml:space=\"preserve\">%TRUE if type information should be included in\n                the output</doc>\n        <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_variant_ref_sink\" version=\"2.24\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">#GVariant uses a floating reference count system.  All functions with\nnames starting with `g_variant_new_` return floating\nreferences.\n\nCalling g_variant_ref_sink() on a #GVariant with a floating reference\nwill convert the floating reference into a full reference.  Calling\ng_variant_ref_sink() on a non-floating #GVariant results in an\nadditional normal reference being added.\n\nIn other words, if the @value is floating, then this call \"assumes\nownership\" of the floating reference, converting it to a normal\nreference.  If the @value is not floating, then this call adds a\nnew normal reference increasing the reference count by one.\n\nAll calls that result in a #GVariant instance being inserted into a\ncontainer will call g_variant_ref_sink() on the instance.  This means\nthat if the value was just created (and has only its floating\nreference) then the container will assume sole ownership of the value\nat that point and the caller will not need to unreference it.  This\nmakes certain common styles of programming much easier while still\nmaintaining normal refcounting semantics in situations where values\nare not floating.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the same @value</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"store\" c:identifier=\"g_variant_store\" version=\"2.24\" gs:managed-name=\"Store\">\n    <doc xml:space=\"preserve\">Stores the serialised form of @value at @data.  @data should be\nlarge enough.  See g_variant_get_size().\n\nThe stored data is in machine native byte order but may not be in\nfully-normalised form if read from an untrusted source.  See\ng_variant_get_normal_form() for a solution.\n\nAs with g_variant_get_data(), to be able to deserialise the\nserialised variant successfully, its type and (if the destination\nmachine might be different) its endianness must also be available.\n\nThis function is approximately O(n) in the size of @data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariant to store</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the location to store the serialised data at</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the location to store the serialised data at</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_variant_unref\" version=\"2.24\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count of @value.  When its reference count\ndrops to 0, the memory used by the variant is freed.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"is_object_path\" c:identifier=\"g_variant_is_object_path\" version=\"2.24\" gs:managed-name=\"IsObjectPath\">\n    <doc xml:space=\"preserve\">Determines if a given string is a valid D-Bus object path.  You\nshould ensure that a string is a valid D-Bus object path before\npassing it to g_variant_new_object_path().\n\nA valid object path starts with '/' followed by zero or more\nsequences of characters separated by '/' characters.  Each sequence\nmust contain only the characters \"[A-Z][a-z][0-9]_\".  No sequence\n(including the one following the final '/' character) may be empty.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @string is a D-Bus object path</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"is_signature\" c:identifier=\"g_variant_is_signature\" version=\"2.24\" gs:managed-name=\"IsSignature\">\n    <doc xml:space=\"preserve\">Determines if a given string is a valid D-Bus type signature.  You\nshould ensure that a string is a valid D-Bus type signature before\npassing it to g_variant_new_signature().\n\nD-Bus type signatures consist of zero or more definite #GVariantType\nstrings in sequence.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @string is a D-Bus type signature</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a normal C nul-terminated string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"parse\" c:identifier=\"g_variant_parse\" throws=\"1\" gs:managed-name=\"Parse\">\n    <doc xml:space=\"preserve\">Parses a #GVariant from a text representation.\n\nA single #GVariant is parsed from the content of @text.\n\nThe format is described [here][gvariant-text].\n\nThe memory at @limit will never be accessed and the parser behaves as\nif the character at @limit is the nul terminator.  This has the\neffect of bounding @text.\n\nIf @endptr is non-%NULL then @text is permitted to contain data\nfollowing the value that this function parses and @endptr will be\nupdated to point to the first character past the end of the text\nparsed by this function.  If @endptr is %NULL and there is extra data\nthen an error is returned.\n\nIf @type is non-%NULL then the value will be parsed to have that\ntype.  This may result in additional parse errors (in the case that\nthe parsed value doesn't fit the type) but may also result in fewer\nerrors (in the case that the type would have been ambiguous, such as\nwith empty arrays).\n\nIn the event that the parsing is successful, the resulting #GVariant\nis returned.\n\nIn case of any error, %NULL will be returned.  If @error is non-%NULL\nthen it will be set to reflect the error that occurred.\n\nOfficially, the language understood by the parser is \"any string\nproduced by g_variant_print()\".</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a reference to a #GVariant, or %NULL</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"text\" transfer-ownership=\"none\" gs:managed-name=\"text\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string containing a GVariant in text form</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"limit\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"limit\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to the end of @text, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a location to store the end pointer, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"text\" transfer-ownership=\"none\" gs:managed-name=\"text\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a string containing a GVariant in text form</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"limit\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"limit\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to the end of @text, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a location to store the end pointer, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"parse_error_print_context\" c:identifier=\"g_variant_parse_error_print_context\" version=\"2.40\" gs:managed-name=\"ParseErrorPrintContext\">\n    <doc xml:space=\"preserve\">Pretty-prints a message showing the context of a #GVariant parse\nerror within the string for which parsing was attempted.\n\nThe resulting string is suitable for output to the console or other\nmonospace media where newlines are treated in the usual way.\n\nThe message will typically look something like one of the following:\n\n|[\nunterminated string constant:\n  (1, 2, 3, 'abc\n            ^^^^\n]|\n\nor\n\n|[\nunable to find a common type:\n  [1, 2, 3, 'str']\n   ^        ^^^^^\n]|\n\nThe format of the message may change in a future version.\n\n@error must have come from a failed attempt to g_variant_parse() and\n@source_str must be exactly the same string that caused the error.\nIf @source_str was not nul-terminated when you passed it to\ng_variant_parse() then you must add nul termination before using this\nfunction.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the printed message</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"error\" transfer-ownership=\"none\" gs:managed-name=\"error\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GError from the #GVariantParseError domain</doc>\n        <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n      </parameter>\n      <parameter name=\"source_str\" transfer-ownership=\"none\" gs:managed-name=\"sourceStr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the string that was given to the parser</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"error\" transfer-ownership=\"none\" gs:managed-name=\"error\" gs:managed-type=\"Error\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GError from the #GVariantParseError domain</doc>\n        <type name=\"Error\" c:type=\"GError*\" gs:managed-name=\"Error\" />\n      </parameter>\n      <parameter name=\"source_str\" transfer-ownership=\"none\" gs:managed-name=\"sourceStr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the string that was given to the parser</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"parse_error_quark\" c:identifier=\"g_variant_parse_error_quark\" gs:managed-name=\"ParseErrorQuark\">\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </return-value>\n  </function>\n  <function name=\"parser_get_error_quark\" c:identifier=\"g_variant_parser_get_error_quark\" deprecated=\"1\" gs:managed-name=\"ParserGetErrorQuark\">\n    <doc xml:space=\"preserve\">Same as g_variant_error_quark().</doc>\n    <doc-deprecated xml:space=\"preserve\">Use g_variant_parse_error_quark() instead.</doc-deprecated>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Quark\" gs:unmanaged-type=\"Quark\">\n      <type name=\"Quark\" c:type=\"GQuark\" gs:managed-name=\"Quark\" />\n    </return-value>\n  </function>\n</record>")]
    [GISharp.Core.Since("2.24")]
    public partial class Variant : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.Variant>,
        System.IComparable<GISharp.GLib.Variant>,
        System.IEquatable<GISharp.GLib.Variant>
    {
        /// <summary>
        /// Returns the boolean value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_BOOLEAN.
        /// </remarks>
        /// <param name="value">
        /// a boolean #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE or %FALSE
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Boolean Boolean
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Returns the byte value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_BYTE.
        /// </remarks>
        /// <param name="value">
        /// a byte #GVariant instance
        /// </param>
        /// <returns>
        /// a #guchar
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Byte Byte
        {
            get
            {
                return default(System.Byte);
            }
        }

        /// <summary>
        /// Returns the string value of a #GVariant instance with an
        /// array-of-bytes type.  The string has no particular encoding.
        /// </summary>
        /// <remarks>
        /// If the array does not end with a nul terminator character, the empty
        /// string is returned.  For this reason, you can always trust that a
        /// non-%NULL nul-terminated string will be returned by this function.
        /// 
        /// If the array contains a nul terminator character somewhere other than
        /// the last byte then the returned string is the string, up to the first
        /// such nul character.
        /// 
        /// It is an error to call this function with a @value that is not an
        /// array of bytes.
        /// 
        /// The return value remains valid as long as @value exists.
        /// </remarks>
        /// <param name="value">
        /// an array-of-bytes #GVariant instance
        /// </param>
        /// <returns>
        /// 
        ///          the constant string
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Byte[] Bytestring
        {
            get
            {
                return default(System.Byte[]);
            }
        }

        /// <summary>
        /// Returns a pointer to the serialised form of a #GVariant instance.
        /// The returned data may not be in fully-normalised form if read from an
        /// untrusted source.  The returned data must not be freed; it remains
        /// valid for as long as @value exists.
        /// </summary>
        /// <remarks>
        /// If @value is a fixed-sized value that was deserialised from a
        /// corrupted serialised container then %NULL may be returned.  In this
        /// case, the proper thing to do is typically to use the appropriate
        /// number of nul bytes in place of @value.  If @value is not fixed-sized
        /// then %NULL is never returned.
        /// 
        /// In the case that @value is already in serialised form, this function
        /// is O(1).  If the value is not already in serialised form,
        /// serialisation occurs implicitly and is approximately O(n) in the size
        /// of the result.
        /// 
        /// To deserialise the data returned by this function, in addition to the
        /// serialised data, you must know the type of the #GVariant, and (if the
        /// machine might be different) the endianness of the machine that stored
        /// it. As a result, file formats or network messages that incorporate
        /// serialised #GVariants must include this information either
        /// implicitly (for instance "the file always contains a
        /// %G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
        /// explicitly (by storing the type and/or endianness in addition to the
        /// serialised data).
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// the serialised form of @value, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.IntPtr Data
        {
            get
            {
                return default(System.IntPtr);
            }
        }

        /// <summary>
        /// Returns a pointer to the serialised form of a #GVariant instance.
        /// The semantics of this function are exactly the same as
        /// g_variant_get_data(), except that the returned #GBytes holds
        /// a reference to the variant data.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// A new #GBytes representing the variant data
        /// </returns>
        [GISharp.Core.Since("2.36")]
        public GISharp.GLib.Bytes DataAsBytes
        {
            get
            {
                return default(GISharp.GLib.Bytes);
            }
        }

        /// <summary>
        /// Returns the double precision floating point value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_DOUBLE.
        /// </remarks>
        /// <param name="value">
        /// a double #GVariant instance
        /// </param>
        /// <returns>
        /// a #gdouble
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Double Double
        {
            get
            {
                return default(System.Double);
            }
        }

        /// <summary>
        /// Returns the 32-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type other
        /// than %G_VARIANT_TYPE_HANDLE.
        /// 
        /// By convention, handles are indexes into an array of file descriptors
        /// that are sent alongside a D-Bus message.  If you're not interacting
        /// with D-Bus, you probably don't need them.
        /// </remarks>
        /// <param name="value">
        /// a handle #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint32
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Int32 DBusHandle
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Returns the 16-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT16.
        /// </remarks>
        /// <param name="value">
        /// a int16 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint16
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Int16 Int16
        {
            get
            {
                return default(System.Int16);
            }
        }

        /// <summary>
        /// Returns the 32-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT32.
        /// </remarks>
        /// <param name="value">
        /// a int32 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint32
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Int32 Int32
        {
            get
            {
                return default(System.Int32);
            }
        }

        /// <summary>
        /// Returns the 64-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT64.
        /// </remarks>
        /// <param name="value">
        /// a int64 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint64
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Int64 Int64
        {
            get
            {
                return default(System.Int64);
            }
        }

        /// <summary>
        /// Given a maybe-typed #GVariant instance, extract its value.  If the
        /// value is Nothing, then this function returns %NULL.
        /// </summary>
        /// <param name="value">
        /// a maybe-typed value
        /// </param>
        /// <returns>
        /// the contents of @value, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant Maybe
        {
            get
            {
                return default(GISharp.GLib.Variant);
            }
        }

        /// <summary>
        /// Gets a #GVariant instance that has the same value as @value and is
        /// trusted to be in normal form.
        /// </summary>
        /// <remarks>
        /// If @value is already trusted to be in normal form then a new
        /// reference to @value is returned.
        /// 
        /// If @value is not already trusted, then it is scanned to check if it
        /// is in normal form.  If it is found to be in normal form then it is
        /// marked as trusted and a new reference to it is returned.
        /// 
        /// If @value is found not to be in normal form then a new trusted
        /// #GVariant is created with the same value as @value.
        /// 
        /// It makes sense to call this function if you've received #GVariant
        /// data from untrusted sources and you want to ensure your serialised
        /// output is definitely in normal form.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// a trusted #GVariant
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant NormalForm
        {
            get
            {
                return default(GISharp.GLib.Variant);
            }
        }

        /// <summary>
        /// Determines the number of bytes that would be required to store @value
        /// with g_variant_store().
        /// </summary>
        /// <remarks>
        /// If @value has a fixed-sized type then this function always returned
        /// that fixed size.
        /// 
        /// In the case that @value is already in serialised form or the size has
        /// already been calculated (ie: this function has been called before)
        /// then this function is O(1).  Otherwise, the size is calculated, an
        /// operation which is approximately O(n) in the number of values
        /// involved.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// the serialised size of @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt64 Size
        {
            get
            {
                return default(System.UInt64);
            }
        }

        /// <summary>
        /// Gets the contents of an array of strings #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of strings #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.String[] Strv
        {
            get
            {
                return default(System.String[]);
            }
        }

        /// <summary>
        /// Determines the type of @value.
        /// </summary>
        /// <remarks>
        /// The return value is valid for the lifetime of @value and must not
        /// be freed.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// a #GVariantType
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.VariantType VariantType
        {
            get
            {
                return default(GISharp.GLib.VariantType);
            }
        }

        /// <summary>
        /// Returns the type string of @value.  Unlike the result of calling
        /// g_variant_type_peek_string(), this string is nul-terminated.  This
        /// string belongs to #GVariant and must not be freed.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the type string for the type of @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.String TypeString
        {
            get
            {
                return default(System.String);
            }
        }

        /// <summary>
        /// Returns the 16-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT16.
        /// </remarks>
        /// <param name="value">
        /// a uint16 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint16
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt16 Uint16
        {
            get
            {
                return default(System.UInt16);
            }
        }

        /// <summary>
        /// Returns the 32-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT32.
        /// </remarks>
        /// <param name="value">
        /// a uint32 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint32
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt32 Uint32
        {
            get
            {
                return default(System.UInt32);
            }
        }

        /// <summary>
        /// Returns the 64-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT64.
        /// </remarks>
        /// <param name="value">
        /// a uint64 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint64
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt64 Uint64
        {
            get
            {
                return default(System.UInt64);
            }
        }

        /// <summary>
        /// Unboxes @value.  The result is the #GVariant instance that was
        /// contained in @value.
        /// </summary>
        /// <param name="value">
        /// a variant #GVariant instance
        /// </param>
        /// <returns>
        /// the item contained in the variant
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant BoxedVariant
        {
            get
            {
                return default(GISharp.GLib.Variant);
            }
        }

        /// <summary>
        /// Checks if @value is a container.
        /// </summary>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @value is a container
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Boolean IsContainer
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Checks if @value is in normal form.
        /// </summary>
        /// <remarks>
        /// The main reason to do this is to detect if a given chunk of
        /// serialised data is in normal form: load the data into a #GVariant
        /// using g_variant_new_from_data() and then use this function to
        /// check.
        /// 
        /// If @value is found to be in normal form then it will be marked as
        /// being trusted.  If the value was already marked as being trusted then
        /// this function will immediately return %TRUE.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @value is in normal form
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Boolean IsNormalForm
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public Variant(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GVariant array from @children.
        /// </summary>
        /// <remarks>
        /// @child_type must be non-%NULL if @n_children is zero.  Otherwise, the
        /// child type is determined by inspecting the first element of the
        /// @children array.  If @child_type is non-%NULL then it must be a
        /// definite type.
        /// 
        /// The items of the array are taken from the @children array.  No entry
        /// in the @children array may be %NULL.
        /// 
        /// All items in the array must have the same type, which must be the
        /// same as @child_type, if given.
        /// 
        /// If the @children are floating references (see g_variant_ref_sink()), the
        /// new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="childType">
        /// the element type of the new array
        /// </param>
        /// <param name="children">
        /// an array of
        ///            #GVariant pointers, the children
        /// </param>
        /// <param name="nChildren">
        /// the length of @children
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant array
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            GISharp.GLib.VariantType childType,
            GISharp.GLib.Variant[] children) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.
        /// </summary>
        /// <param name="value">
        /// a #gboolean value
        /// </param>
        /// <returns>
        /// a floating reference to a new boolean #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.Boolean value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new byte #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint8 value
        /// </param>
        /// <returns>
        /// a floating reference to a new byte #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.Byte value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates an array-of-bytes #GVariant with the contents of @string.
        /// This function is just like g_variant_new_string() except that the
        /// string need not be valid utf8.
        /// </summary>
        /// <remarks>
        /// The nul terminator character at the end of the string is stored in
        /// the array.
        /// </remarks>
        /// <param name="string">
        /// a normal
        ///          nul-terminated string in no particular encoding
        /// </param>
        /// <returns>
        /// a floating reference to a new bytestring #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public Variant(
            System.Byte[] @string) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new dictionary entry #GVariant. @key and @value must be
        /// non-%NULL. @key must be a value of a basic type (ie: not a container).
        /// </summary>
        /// <remarks>
        /// If the @key or @value are floating references (see g_variant_ref_sink()),
        /// the new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="key">
        /// a basic #GVariant, the key
        /// </param>
        /// <param name="value">
        /// a #GVariant, the value
        /// </param>
        /// <returns>
        /// a floating reference to a new dictionary entry #GVariant
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            GISharp.GLib.Variant key,
            GISharp.GLib.Variant value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new double #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gdouble floating point value
        /// </param>
        /// <returns>
        /// a floating reference to a new double #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.Double value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Provides access to the serialised data for an array of fixed-sized
        /// items.
        /// </summary>
        /// <remarks>
        /// @value must be an array with fixed-sized elements.  Numeric types are
        /// fixed-size as are tuples containing only other fixed-sized types.
        /// 
        /// @element_size must be the size of a single element in the array.
        /// For example, if calling this function for an array of 32-bit integers,
        /// you might say sizeof(gint32). This value isn't used except for the purpose
        /// of a double-check that the form of the serialised data matches the caller's
        /// expectation.
        /// 
        /// @n_elements, which must be non-%NULL is set equal to the number of
        /// items in the array.
        /// </remarks>
        /// <param name="elementType">
        /// the #GVariantType of each element
        /// </param>
        /// <param name="elements">
        /// a pointer to the fixed array of contiguous elements
        /// </param>
        /// <param name="nElements">
        /// the number of elements
        /// </param>
        /// <param name="elementSize">
        /// the size of each element
        /// </param>
        /// <returns>
        /// a floating reference to a new array #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.32")]
        public Variant(
            GISharp.GLib.VariantType elementType,
            System.IntPtr elements,
            System.UInt64 nElements,
            System.UInt64 elementSize) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Constructs a new serialised-mode #GVariant instance.  This is the
        /// inner interface for creation of new serialised values that gets
        /// called from various functions in gvariant.c.
        /// </summary>
        /// <remarks>
        /// A reference is taken on @bytes.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="trusted">
        /// if the contents of @bytes are trusted
        /// </param>
        /// <returns>
        /// a new #GVariant with a floating reference
        /// </returns>
        [GISharp.Core.Since("2.36")]
        public Variant(
            GISharp.GLib.VariantType type,
            GISharp.GLib.Bytes bytes,
            System.Boolean trusted) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new int16 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint16 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int16 #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.Int16 value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new int32 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int32 #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.Int32 value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new int64 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint64 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int64 #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.Int64 value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Depending on if @child is %NULL, either wraps @child inside of a
        /// maybe container or creates a Nothing instance for the given @type.
        /// </summary>
        /// <remarks>
        /// At least one of @child_type and @child must be non-%NULL.
        /// If @child_type is non-%NULL then it must be a definite type.
        /// If they are both non-%NULL then @child_type must be the type
        /// of @child.
        /// 
        /// If @child is a floating reference (see g_variant_ref_sink()), the new
        /// instance takes ownership of @child.
        /// </remarks>
        /// <param name="childType">
        /// the #GVariantType of the child, or %NULL
        /// </param>
        /// <param name="child">
        /// the child value, or %NULL
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant maybe instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            GISharp.GLib.VariantType childType,
            GISharp.GLib.Variant child) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Parses @format and returns the result.
        /// </summary>
        /// <remarks>
        /// This is the version of g_variant_new_parsed() intended to be used
        /// from libraries.
        /// 
        /// The return value will be floating if it was a newly created GVariant
        /// instance.  In the case that @format simply specified the collection
        /// of a #GVariant pointer (eg: @format was "%*") then the collected
        /// #GVariant pointer will be returned unmodified, without adding any
        /// additional references.
        /// 
        /// Note that the arguments in @app must be of the correct width for their types
        /// specified in @format when collected into the #va_list. See
        /// the [GVariant varargs documentation][gvariant-varargs].
        /// 
        /// In order to behave correctly in all cases it is necessary for the
        /// calling function to g_variant_ref_sink() the return result before
        /// returning control to the user that originally provided the pointer.
        /// At this point, the caller will have their own full reference to the
        /// result.  This can also be done by adding the result to a container,
        /// or by passing it to another g_variant_new() call.
        /// </remarks>
        /// <param name="format">
        /// a text format #GVariant
        /// </param>
        /// <param name="app">
        /// a pointer to a #va_list
        /// </param>
        /// <returns>
        /// a new, usually floating, #GVariant
        /// </returns>
        public Variant(
            System.String format,
            System.Object[] app) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Constructs an array of strings #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.String[] strv) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a string #GVariant with the contents of @string.
        /// </summary>
        /// <remarks>
        /// @string must be valid utf8.
        /// 
        /// This function consumes @string.  g_free() will be called on @string
        /// when it is no longer required.
        /// 
        /// You must not modify or access @string in any other way after passing
        /// it to this function.  It is even possible that @string is immediately
        /// freed.
        /// </remarks>
        /// <param name="string">
        /// a normal utf8 nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new string
        ///   #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.38")]
        public Variant(
            System.String @string) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new tuple #GVariant out of the items in @children.  The
        /// type is determined from the types of @children.  No entry in the
        /// @children array may be %NULL.
        /// </summary>
        /// <remarks>
        /// If @n_children is 0 then the unit tuple is constructed.
        /// 
        /// If the @children are floating references (see g_variant_ref_sink()), the
        /// new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="children">
        /// the items to make the tuple out of
        /// </param>
        /// <param name="nChildren">
        /// the length of @children
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant tuple
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            GISharp.GLib.Variant[] children) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new uint16 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint16 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint16 #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.UInt16 value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new uint32 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint32 #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.UInt32 value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new uint64 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint64 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint64 #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.UInt64 value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// This function is intended to be used by libraries based on
        /// #GVariant that want to provide g_variant_new()-like functionality
        /// to their users.
        /// </summary>
        /// <remarks>
        /// The API is more general than g_variant_new() to allow a wider range
        /// of possible uses.
        /// 
        /// @format_string must still point to a valid format string, but it only
        /// needs to be nul-terminated if @endptr is %NULL.  If @endptr is
        /// non-%NULL then it is updated to point to the first character past the
        /// end of the format string.
        /// 
        /// @app is a pointer to a #va_list.  The arguments, according to
        /// @format_string, are collected from this #va_list and the list is left
        /// pointing to the argument following the last.
        /// 
        /// Note that the arguments in @app must be of the correct width for their
        /// types specified in @format_string when collected into the #va_list.
        /// See the [GVariant varargs documentation][gvariant-varargs.
        /// 
        /// These two generalisations allow mixing of multiple calls to
        /// g_variant_new_va() and g_variant_get_va() within a single actual
        /// varargs call by the user.
        /// 
        /// The return value will be floating if it was a newly created GVariant
        /// instance (for example, if the format string was "(ii)").  In the case
        /// that the format_string was '*', '?', 'r', or a format starting with
        /// '@' then the collected #GVariant pointer will be returned unmodified,
        /// without adding any additional references.
        /// 
        /// In order to behave correctly in all cases it is necessary for the
        /// calling function to g_variant_ref_sink() the return result before
        /// returning control to the user that originally provided the pointer.
        /// At this point, the caller will have their own full reference to the
        /// result.  This can also be done by adding the result to a container,
        /// or by passing it to another g_variant_new() call.
        /// </remarks>
        /// <param name="formatString">
        /// a string that is prefixed with a format string
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer,
        ///          or %NULL
        /// </param>
        /// <param name="app">
        /// a pointer to a #va_list
        /// </param>
        /// <returns>
        /// a new, usually floating, #GVariant
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            System.String formatString,
            System.String endptr,
            System.Object[] app) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Boxes @value.  The result is a #GVariant instance representing a
        /// variant containing the original value.
        /// </summary>
        /// <remarks>
        /// If @child is a floating reference (see g_variant_ref_sink()), the new
        /// instance takes ownership of @child.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// a floating reference to a new variant #GVariant instance
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public Variant(
            GISharp.GLib.Variant value) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GVariant array from @children.
        /// </summary>
        /// <remarks>
        /// @child_type must be non-%NULL if @n_children is zero.  Otherwise, the
        /// child type is determined by inspecting the first element of the
        /// @children array.  If @child_type is non-%NULL then it must be a
        /// definite type.
        /// 
        /// The items of the array are taken from the @children array.  No entry
        /// in the @children array may be %NULL.
        /// 
        /// All items in the array must have the same type, which must be the
        /// same as @child_type, if given.
        /// 
        /// If the @children are floating references (see g_variant_ref_sink()), the
        /// new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="childType">
        /// the element type of the new array
        /// </param>
        /// <param name="children">
        /// an array of
        ///            #GVariant pointers, the children
        /// </param>
        /// <param name="nChildren">
        /// the length of @children
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant array
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_array(
            [System.Runtime.InteropServices.In()] System.IntPtr childType,
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 2)] System.IntPtr[] children,
            [System.Runtime.InteropServices.In()] System.UInt64 nChildren);

        /// <summary>
        /// Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.
        /// </summary>
        /// <param name="value">
        /// a #gboolean value
        /// </param>
        /// <returns>
        /// a floating reference to a new boolean #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_boolean(
            [System.Runtime.InteropServices.In()] System.Boolean value);

        /// <summary>
        /// Creates a new byte #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint8 value
        /// </param>
        /// <returns>
        /// a floating reference to a new byte #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_byte(
            [System.Runtime.InteropServices.In()] System.Byte value);

        /// <summary>
        /// Creates an array-of-bytes #GVariant with the contents of @string.
        /// This function is just like g_variant_new_string() except that the
        /// string need not be valid utf8.
        /// </summary>
        /// <remarks>
        /// The nul terminator character at the end of the string is stored in
        /// the array.
        /// </remarks>
        /// <param name="string">
        /// a normal
        ///          nul-terminated string in no particular encoding
        /// </param>
        /// <returns>
        /// a floating reference to a new bytestring #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_variant_new_bytestring(
            [System.Runtime.InteropServices.In()] System.Byte[] @string);

        /// <summary>
        /// Constructs an array of bytestring #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_variant_new_bytestring_array(
            [System.Runtime.InteropServices.In()] System.IntPtr strv,
            [System.Runtime.InteropServices.In()] System.Int64 length);

        /// <summary>
        /// Creates a new dictionary entry #GVariant. @key and @value must be
        /// non-%NULL. @key must be a value of a basic type (ie: not a container).
        /// </summary>
        /// <remarks>
        /// If the @key or @value are floating references (see g_variant_ref_sink()),
        /// the new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="key">
        /// a basic #GVariant, the key
        /// </param>
        /// <param name="value">
        /// a #GVariant, the value
        /// </param>
        /// <returns>
        /// a floating reference to a new dictionary entry #GVariant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_dict_entry(
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Creates a new double #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gdouble floating point value
        /// </param>
        /// <returns>
        /// a floating reference to a new double #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_double(
            [System.Runtime.InteropServices.In()] System.Double value);

        /// <summary>
        /// Provides access to the serialised data for an array of fixed-sized
        /// items.
        /// </summary>
        /// <remarks>
        /// @value must be an array with fixed-sized elements.  Numeric types are
        /// fixed-size as are tuples containing only other fixed-sized types.
        /// 
        /// @element_size must be the size of a single element in the array.
        /// For example, if calling this function for an array of 32-bit integers,
        /// you might say sizeof(gint32). This value isn't used except for the purpose
        /// of a double-check that the form of the serialised data matches the caller's
        /// expectation.
        /// 
        /// @n_elements, which must be non-%NULL is set equal to the number of
        /// items in the array.
        /// </remarks>
        /// <param name="elementType">
        /// the #GVariantType of each element
        /// </param>
        /// <param name="elements">
        /// a pointer to the fixed array of contiguous elements
        /// </param>
        /// <param name="nElements">
        /// the number of elements
        /// </param>
        /// <param name="elementSize">
        /// the size of each element
        /// </param>
        /// <returns>
        /// a floating reference to a new array #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.32")]
        static extern System.IntPtr g_variant_new_fixed_array(
            [System.Runtime.InteropServices.In()] System.IntPtr elementType,
            [System.Runtime.InteropServices.In()] System.IntPtr elements,
            [System.Runtime.InteropServices.In()] System.UInt64 nElements,
            [System.Runtime.InteropServices.In()] System.UInt64 elementSize);

        /// <summary>
        /// Constructs a new serialised-mode #GVariant instance.  This is the
        /// inner interface for creation of new serialised values that gets
        /// called from various functions in gvariant.c.
        /// </summary>
        /// <remarks>
        /// A reference is taken on @bytes.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="trusted">
        /// if the contents of @bytes are trusted
        /// </param>
        /// <returns>
        /// a new #GVariant with a floating reference
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.36")]
        static extern System.IntPtr g_variant_new_from_bytes(
            [System.Runtime.InteropServices.In()] System.IntPtr type,
            [System.Runtime.InteropServices.In()] System.IntPtr bytes,
            [System.Runtime.InteropServices.In()] System.Boolean trusted);

        /// <summary>
        /// Creates a new #GVariant instance from serialised data.
        /// </summary>
        /// <remarks>
        /// @type is the type of #GVariant instance that will be constructed.
        /// The interpretation of @data depends on knowing the type.
        /// 
        /// @data is not modified by this function and must remain valid with an
        /// unchanging value until such a time as @notify is called with
        /// @user_data.  If the contents of @data change before that time then
        /// the result is undefined.
        /// 
        /// If @data is trusted to be serialised data in normal form then
        /// @trusted should be %TRUE.  This applies to serialised data created
        /// within this process or read from a trusted location on the disk (such
        /// as a file installed in /usr/lib alongside your application).  You
        /// should set trusted to %FALSE if @data is read from the network, a
        /// file in the user's home directory, etc.
        /// 
        /// If @data was not stored in this machine's native endianness, any multi-byte
        /// numeric values in the returned variant will also be in non-native
        /// endianness. g_variant_byteswap() can be used to recover the original values.
        /// 
        /// @notify will be called with @user_data when @data is no longer
        /// needed.  The exact time of this call is unspecified and might even be
        /// before this function returns.
        /// </remarks>
        /// <param name="type">
        /// a definite #GVariantType
        /// </param>
        /// <param name="data">
        /// the serialised data
        /// </param>
        /// <param name="size">
        /// the size of @data
        /// </param>
        /// <param name="trusted">
        /// %TRUE if @data is definitely in normal form
        /// </param>
        /// <param name="notify">
        /// function to call when @data is no longer needed
        /// </param>
        /// <param name="userData">
        /// data for @notify
        /// </param>
        /// <returns>
        /// a new floating #GVariant of type @type
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_from_data(
            [System.Runtime.InteropServices.In()] System.IntPtr type,
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 2)] System.Byte[] data,
            [System.Runtime.InteropServices.In()] System.UInt64 size,
            [System.Runtime.InteropServices.In()] System.Boolean trusted,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Creates a new handle #GVariant instance.
        /// </summary>
        /// <remarks>
        /// By convention, handles are indexes into an array of file descriptors
        /// that are sent alongside a D-Bus message.  If you're not interacting
        /// with D-Bus, you probably don't need them.
        /// </remarks>
        /// <param name="value">
        /// a #gint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new handle #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_handle(
            [System.Runtime.InteropServices.In()] System.Int32 value);

        /// <summary>
        /// Creates a new int16 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint16 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int16 #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_int16(
            [System.Runtime.InteropServices.In()] System.Int16 value);

        /// <summary>
        /// Creates a new int32 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int32 #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_int32(
            [System.Runtime.InteropServices.In()] System.Int32 value);

        /// <summary>
        /// Creates a new int64 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint64 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int64 #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_int64(
            [System.Runtime.InteropServices.In()] System.Int64 value);

        /// <summary>
        /// Depending on if @child is %NULL, either wraps @child inside of a
        /// maybe container or creates a Nothing instance for the given @type.
        /// </summary>
        /// <remarks>
        /// At least one of @child_type and @child must be non-%NULL.
        /// If @child_type is non-%NULL then it must be a definite type.
        /// If they are both non-%NULL then @child_type must be the type
        /// of @child.
        /// 
        /// If @child is a floating reference (see g_variant_ref_sink()), the new
        /// instance takes ownership of @child.
        /// </remarks>
        /// <param name="childType">
        /// the #GVariantType of the child, or %NULL
        /// </param>
        /// <param name="child">
        /// the child value, or %NULL
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant maybe instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_maybe(
            [System.Runtime.InteropServices.In()] System.IntPtr childType,
            [System.Runtime.InteropServices.In()] System.IntPtr child);

        /// <summary>
        /// Creates a D-Bus object path #GVariant with the contents of @string.
        /// @string must be a valid D-Bus object path.  Use
        /// g_variant_is_object_path() if you're not sure.
        /// </summary>
        /// <param name="objectPath">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new object path #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_object_path(
            [System.Runtime.InteropServices.In()] System.IntPtr objectPath);

        /// <summary>
        /// Constructs an array of object paths #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// Each string must be a valid #GVariant object path; see
        /// g_variant_is_object_path().
        /// 
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.30")]
        static extern System.IntPtr g_variant_new_objv(
            [System.Runtime.InteropServices.In()] System.IntPtr strv,
            [System.Runtime.InteropServices.In()] System.Int64 length);

        /// <summary>
        /// Parses @format and returns the result.
        /// </summary>
        /// <remarks>
        /// This is the version of g_variant_new_parsed() intended to be used
        /// from libraries.
        /// 
        /// The return value will be floating if it was a newly created GVariant
        /// instance.  In the case that @format simply specified the collection
        /// of a #GVariant pointer (eg: @format was "%*") then the collected
        /// #GVariant pointer will be returned unmodified, without adding any
        /// additional references.
        /// 
        /// Note that the arguments in @app must be of the correct width for their types
        /// specified in @format when collected into the #va_list. See
        /// the [GVariant varargs documentation][gvariant-varargs].
        /// 
        /// In order to behave correctly in all cases it is necessary for the
        /// calling function to g_variant_ref_sink() the return result before
        /// returning control to the user that originally provided the pointer.
        /// At this point, the caller will have their own full reference to the
        /// result.  This can also be done by adding the result to a container,
        /// or by passing it to another g_variant_new() call.
        /// </remarks>
        /// <param name="format">
        /// a text format #GVariant
        /// </param>
        /// <param name="app">
        /// a pointer to a #va_list
        /// </param>
        /// <returns>
        /// a new, usually floating, #GVariant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_new_parsed_va(
            [System.Runtime.InteropServices.In()] System.IntPtr format,
            [System.Runtime.InteropServices.In()] System.IntPtr app);

        /// <summary>
        /// Creates a D-Bus type signature #GVariant with the contents of
        /// @string.  @string must be a valid D-Bus type signature.  Use
        /// g_variant_is_signature() if you're not sure.
        /// </summary>
        /// <param name="signature">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new signature #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_signature(
            [System.Runtime.InteropServices.In()] System.IntPtr signature);

        /// <summary>
        /// Constructs an array of strings #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_strv(
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)] System.IntPtr[] strv,
            [System.Runtime.InteropServices.In()] System.Int64 length);

        /// <summary>
        /// Creates a string #GVariant with the contents of @string.
        /// </summary>
        /// <remarks>
        /// @string must be valid utf8.
        /// 
        /// This function consumes @string.  g_free() will be called on @string
        /// when it is no longer required.
        /// 
        /// You must not modify or access @string in any other way after passing
        /// it to this function.  It is even possible that @string is immediately
        /// freed.
        /// </remarks>
        /// <param name="string">
        /// a normal utf8 nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new string
        ///   #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.38")]
        static extern System.IntPtr g_variant_new_take_string(
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Creates a new tuple #GVariant out of the items in @children.  The
        /// type is determined from the types of @children.  No entry in the
        /// @children array may be %NULL.
        /// </summary>
        /// <remarks>
        /// If @n_children is 0 then the unit tuple is constructed.
        /// 
        /// If the @children are floating references (see g_variant_ref_sink()), the
        /// new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="children">
        /// the items to make the tuple out of
        /// </param>
        /// <param name="nChildren">
        /// the length of @children
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant tuple
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_tuple(
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)] System.IntPtr[] children,
            [System.Runtime.InteropServices.In()] System.UInt64 nChildren);

        /// <summary>
        /// Creates a new uint16 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint16 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint16 #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_uint16(
            [System.Runtime.InteropServices.In()] System.UInt16 value);

        /// <summary>
        /// Creates a new uint32 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint32 #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_uint32(
            [System.Runtime.InteropServices.In()] System.UInt32 value);

        /// <summary>
        /// Creates a new uint64 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint64 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint64 #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_uint64(
            [System.Runtime.InteropServices.In()] System.UInt64 value);

        /// <summary>
        /// This function is intended to be used by libraries based on
        /// #GVariant that want to provide g_variant_new()-like functionality
        /// to their users.
        /// </summary>
        /// <remarks>
        /// The API is more general than g_variant_new() to allow a wider range
        /// of possible uses.
        /// 
        /// @format_string must still point to a valid format string, but it only
        /// needs to be nul-terminated if @endptr is %NULL.  If @endptr is
        /// non-%NULL then it is updated to point to the first character past the
        /// end of the format string.
        /// 
        /// @app is a pointer to a #va_list.  The arguments, according to
        /// @format_string, are collected from this #va_list and the list is left
        /// pointing to the argument following the last.
        /// 
        /// Note that the arguments in @app must be of the correct width for their
        /// types specified in @format_string when collected into the #va_list.
        /// See the [GVariant varargs documentation][gvariant-varargs.
        /// 
        /// These two generalisations allow mixing of multiple calls to
        /// g_variant_new_va() and g_variant_get_va() within a single actual
        /// varargs call by the user.
        /// 
        /// The return value will be floating if it was a newly created GVariant
        /// instance (for example, if the format string was "(ii)").  In the case
        /// that the format_string was '*', '?', 'r', or a format starting with
        /// '@' then the collected #GVariant pointer will be returned unmodified,
        /// without adding any additional references.
        /// 
        /// In order to behave correctly in all cases it is necessary for the
        /// calling function to g_variant_ref_sink() the return result before
        /// returning control to the user that originally provided the pointer.
        /// At this point, the caller will have their own full reference to the
        /// result.  This can also be done by adding the result to a container,
        /// or by passing it to another g_variant_new() call.
        /// </remarks>
        /// <param name="formatString">
        /// a string that is prefixed with a format string
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer,
        ///          or %NULL
        /// </param>
        /// <param name="app">
        /// a pointer to a #va_list
        /// </param>
        /// <returns>
        /// a new, usually floating, #GVariant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_va(
            [System.Runtime.InteropServices.In()] System.IntPtr formatString,
            [System.Runtime.InteropServices.In()] System.IntPtr endptr,
            [System.Runtime.InteropServices.In()] System.IntPtr app);

        /// <summary>
        /// Boxes @value.  The result is a #GVariant instance representing a
        /// variant containing the original value.
        /// </summary>
        /// <remarks>
        /// If @child is a floating reference (see g_variant_ref_sink()), the new
        /// instance takes ownership of @child.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// a floating reference to a new variant #GVariant instance
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_new_variant(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Determines if a given string is a valid D-Bus object path.  You
        /// should ensure that a string is a valid D-Bus object path before
        /// passing it to g_variant_new_object_path().
        /// </summary>
        /// <remarks>
        /// A valid object path starts with '/' followed by zero or more
        /// sequences of characters separated by '/' characters.  Each sequence
        /// must contain only the characters "[A-Z][a-z][0-9]_".  No sequence
        /// (including the one following the final '/' character) may be empty.
        /// </remarks>
        /// <param name="string">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// %TRUE if @string is a D-Bus object path
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_is_object_path(
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Determines if a given string is a valid D-Bus object path.  You
        /// should ensure that a string is a valid D-Bus object path before
        /// passing it to g_variant_new_object_path().
        /// </summary>
        /// <remarks>
        /// A valid object path starts with '/' followed by zero or more
        /// sequences of characters separated by '/' characters.  Each sequence
        /// must contain only the characters "[A-Z][a-z][0-9]_".  No sequence
        /// (including the one following the final '/' character) may be empty.
        /// </remarks>
        /// <param name="string">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// %TRUE if @string is a D-Bus object path
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public static System.Boolean IsObjectPath(
            System.String @string)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Determines if a given string is a valid D-Bus type signature.  You
        /// should ensure that a string is a valid D-Bus type signature before
        /// passing it to g_variant_new_signature().
        /// </summary>
        /// <remarks>
        /// D-Bus type signatures consist of zero or more definite #GVariantType
        /// strings in sequence.
        /// </remarks>
        /// <param name="string">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// %TRUE if @string is a D-Bus type signature
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_is_signature(
            [System.Runtime.InteropServices.In()] System.IntPtr @string);

        /// <summary>
        /// Determines if a given string is a valid D-Bus type signature.  You
        /// should ensure that a string is a valid D-Bus type signature before
        /// passing it to g_variant_new_signature().
        /// </summary>
        /// <remarks>
        /// D-Bus type signatures consist of zero or more definite #GVariantType
        /// strings in sequence.
        /// </remarks>
        /// <param name="string">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// %TRUE if @string is a D-Bus type signature
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public static System.Boolean IsSignature(
            System.String @string)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Parses a #GVariant from a text representation.
        /// </summary>
        /// <remarks>
        /// A single #GVariant is parsed from the content of @text.
        /// 
        /// The format is described [here][gvariant-text].
        /// 
        /// The memory at @limit will never be accessed and the parser behaves as
        /// if the character at @limit is the nul terminator.  This has the
        /// effect of bounding @text.
        /// 
        /// If @endptr is non-%NULL then @text is permitted to contain data
        /// following the value that this function parses and @endptr will be
        /// updated to point to the first character past the end of the text
        /// parsed by this function.  If @endptr is %NULL and there is extra data
        /// then an error is returned.
        /// 
        /// If @type is non-%NULL then the value will be parsed to have that
        /// type.  This may result in additional parse errors (in the case that
        /// the parsed value doesn't fit the type) but may also result in fewer
        /// errors (in the case that the type would have been ambiguous, such as
        /// with empty arrays).
        /// 
        /// In the event that the parsing is successful, the resulting #GVariant
        /// is returned.
        /// 
        /// In case of any error, %NULL will be returned.  If @error is non-%NULL
        /// then it will be set to reflect the error that occurred.
        /// 
        /// Officially, the language understood by the parser is "any string
        /// produced by g_variant_print()".
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <param name="text">
        /// a string containing a GVariant in text form
        /// </param>
        /// <param name="limit">
        /// a pointer to the end of @text, or %NULL
        /// </param>
        /// <param name="endptr">
        /// a location to store the end pointer, or %NULL
        /// </param>
        /// <returns>
        /// a reference to a #GVariant, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_parse(
            [System.Runtime.InteropServices.In()] System.IntPtr type,
            [System.Runtime.InteropServices.In()] System.IntPtr text,
            [System.Runtime.InteropServices.In()] System.IntPtr limit,
            [System.Runtime.InteropServices.In()] System.IntPtr endptr);

        /// <summary>
        /// Parses a #GVariant from a text representation.
        /// </summary>
        /// <remarks>
        /// A single #GVariant is parsed from the content of @text.
        /// 
        /// The format is described [here][gvariant-text].
        /// 
        /// The memory at @limit will never be accessed and the parser behaves as
        /// if the character at @limit is the nul terminator.  This has the
        /// effect of bounding @text.
        /// 
        /// If @endptr is non-%NULL then @text is permitted to contain data
        /// following the value that this function parses and @endptr will be
        /// updated to point to the first character past the end of the text
        /// parsed by this function.  If @endptr is %NULL and there is extra data
        /// then an error is returned.
        /// 
        /// If @type is non-%NULL then the value will be parsed to have that
        /// type.  This may result in additional parse errors (in the case that
        /// the parsed value doesn't fit the type) but may also result in fewer
        /// errors (in the case that the type would have been ambiguous, such as
        /// with empty arrays).
        /// 
        /// In the event that the parsing is successful, the resulting #GVariant
        /// is returned.
        /// 
        /// In case of any error, %NULL will be returned.  If @error is non-%NULL
        /// then it will be set to reflect the error that occurred.
        /// 
        /// Officially, the language understood by the parser is "any string
        /// produced by g_variant_print()".
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <param name="text">
        /// a string containing a GVariant in text form
        /// </param>
        /// <param name="limit">
        /// a pointer to the end of @text, or %NULL
        /// </param>
        /// <param name="endptr">
        /// a location to store the end pointer, or %NULL
        /// </param>
        /// <returns>
        /// a reference to a #GVariant, or %NULL
        /// </returns>
        public static GISharp.GLib.Variant Parse(
            GISharp.GLib.VariantType type,
            System.String text,
            System.String limit,
            System.String endptr)
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Pretty-prints a message showing the context of a #GVariant parse
        /// error within the string for which parsing was attempted.
        /// </summary>
        /// <remarks>
        /// The resulting string is suitable for output to the console or other
        /// monospace media where newlines are treated in the usual way.
        /// 
        /// The message will typically look something like one of the following:
        /// 
        /// |[
        /// unterminated string constant:
        ///   (1, 2, 3, 'abc
        ///             ^^^^
        /// ]|
        /// 
        /// or
        /// 
        /// |[
        /// unable to find a common type:
        ///   [1, 2, 3, 'str']
        ///    ^        ^^^^^
        /// ]|
        /// 
        /// The format of the message may change in a future version.
        /// 
        /// @error must have come from a failed attempt to g_variant_parse() and
        /// @source_str must be exactly the same string that caused the error.
        /// If @source_str was not nul-terminated when you passed it to
        /// g_variant_parse() then you must add nul termination before using this
        /// function.
        /// </remarks>
        /// <param name="error">
        /// a #GError from the #GVariantParseError domain
        /// </param>
        /// <param name="sourceStr">
        /// the string that was given to the parser
        /// </param>
        /// <returns>
        /// the printed message
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.IntPtr g_variant_parse_error_print_context(
            [System.Runtime.InteropServices.In()] System.IntPtr error,
            [System.Runtime.InteropServices.In()] System.IntPtr sourceStr);

        /// <summary>
        /// Pretty-prints a message showing the context of a #GVariant parse
        /// error within the string for which parsing was attempted.
        /// </summary>
        /// <remarks>
        /// The resulting string is suitable for output to the console or other
        /// monospace media where newlines are treated in the usual way.
        /// 
        /// The message will typically look something like one of the following:
        /// 
        /// |[
        /// unterminated string constant:
        ///   (1, 2, 3, 'abc
        ///             ^^^^
        /// ]|
        /// 
        /// or
        /// 
        /// |[
        /// unable to find a common type:
        ///   [1, 2, 3, 'str']
        ///    ^        ^^^^^
        /// ]|
        /// 
        /// The format of the message may change in a future version.
        /// 
        /// @error must have come from a failed attempt to g_variant_parse() and
        /// @source_str must be exactly the same string that caused the error.
        /// If @source_str was not nul-terminated when you passed it to
        /// g_variant_parse() then you must add nul termination before using this
        /// function.
        /// </remarks>
        /// <param name="error">
        /// a #GError from the #GVariantParseError domain
        /// </param>
        /// <param name="sourceStr">
        /// the string that was given to the parser
        /// </param>
        /// <returns>
        /// the printed message
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public static System.String ParseErrorPrintContext(
            GISharp.GLib.Error error,
            System.String sourceStr)
        {
            return default(System.String);
        }

        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.Quark g_variant_parse_error_quark();

        public static GISharp.GLib.Quark ParseErrorQuark()
        {
            return default(GISharp.GLib.Quark);
        }

        /// <summary>
        /// Same as g_variant_error_quark().
        /// </summary>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [System.Obsolete("Use g_variant_parse_error_quark() instead.")]
        static extern GISharp.GLib.Quark g_variant_parser_get_error_quark();

        /// <summary>
        /// Same as g_variant_error_quark().
        /// </summary>
        [System.Obsolete("Use g_variant_parse_error_quark() instead.")]
        public static GISharp.GLib.Quark ParserGetErrorQuark()
        {
            return default(GISharp.GLib.Quark);
        }

        /// <summary>
        /// Performs a byteswapping operation on the contents of @value.  The
        /// result is that all multi-byte numeric data contained in @value is
        /// byteswapped.  That includes 16, 32, and 64bit signed and unsigned
        /// integers as well as file handles and double precision floating point
        /// values.
        /// </summary>
        /// <remarks>
        /// This function is an identity mapping on any value that does not
        /// contain multi-byte numeric data.  That include strings, booleans,
        /// bytes and containers containing only these things (recursively).
        /// 
        /// The returned value is always in normal form and is marked as trusted.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the byteswapped form of @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_byteswap(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Performs a byteswapping operation on the contents of @value.  The
        /// result is that all multi-byte numeric data contained in @value is
        /// byteswapped.  That includes 16, 32, and 64bit signed and unsigned
        /// integers as well as file handles and double precision floating point
        /// values.
        /// </summary>
        /// <remarks>
        /// This function is an identity mapping on any value that does not
        /// contain multi-byte numeric data.  That include strings, booleans,
        /// bytes and containers containing only these things (recursively).
        /// 
        /// The returned value is always in normal form and is marked as trusted.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the byteswapped form of @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant Byteswap()
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Checks if calling g_variant_get() with @format_string on @value would
        /// be valid from a type-compatibility standpoint.  @format_string is
        /// assumed to be a valid format string (from a syntactic standpoint).
        /// </summary>
        /// <remarks>
        /// If @copy_only is %TRUE then this function additionally checks that it
        /// would be safe to call g_variant_unref() on @value immediately after
        /// the call to g_variant_get() without invalidating the result.  This is
        /// only possible if deep copies are made (ie: there are no pointers to
        /// the data inside of the soon-to-be-freed #GVariant instance).  If this
        /// check fails then a g_critical() is printed and %FALSE is returned.
        /// 
        /// This function is meant to be used by functions that wish to provide
        /// varargs accessors to #GVariant values of uncertain values (eg:
        /// g_variant_lookup() or g_menu_model_get_item_attribute()).
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="formatString">
        /// a valid #GVariant format string
        /// </param>
        /// <param name="copyOnly">
        /// %TRUE to ensure the format string makes deep copies
        /// </param>
        /// <returns>
        /// %TRUE if @format_string is safe to use
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.34")]
        static extern System.Boolean g_variant_check_format_string(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.In()] System.IntPtr formatString,
            [System.Runtime.InteropServices.In()] System.Boolean copyOnly);

        /// <summary>
        /// Checks if calling g_variant_get() with @format_string on @value would
        /// be valid from a type-compatibility standpoint.  @format_string is
        /// assumed to be a valid format string (from a syntactic standpoint).
        /// </summary>
        /// <remarks>
        /// If @copy_only is %TRUE then this function additionally checks that it
        /// would be safe to call g_variant_unref() on @value immediately after
        /// the call to g_variant_get() without invalidating the result.  This is
        /// only possible if deep copies are made (ie: there are no pointers to
        /// the data inside of the soon-to-be-freed #GVariant instance).  If this
        /// check fails then a g_critical() is printed and %FALSE is returned.
        /// 
        /// This function is meant to be used by functions that wish to provide
        /// varargs accessors to #GVariant values of uncertain values (eg:
        /// g_variant_lookup() or g_menu_model_get_item_attribute()).
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="formatString">
        /// a valid #GVariant format string
        /// </param>
        /// <param name="copyOnly">
        /// %TRUE to ensure the format string makes deep copies
        /// </param>
        /// <returns>
        /// %TRUE if @format_string is safe to use
        /// </returns>
        [GISharp.Core.Since("2.34")]
        public System.Boolean CheckFormatString(
            System.String formatString,
            System.Boolean copyOnly)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Classifies @value according to its top-level type.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the #GVariantClass of @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern GISharp.GLib.VariantClass g_variant_classify(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Classifies @value according to its top-level type.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the #GVariantClass of @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.VariantClass Classify()
        {
            return default(GISharp.GLib.VariantClass);
        }

        /// <summary>
        /// Compares @one and @two.
        /// </summary>
        /// <remarks>
        /// The types of @one and @two are #gconstpointer only to allow use of
        /// this function with #GTree, #GPtrArray, etc.  They must each be a
        /// #GVariant.
        /// 
        /// Comparison is only defined for basic types (ie: booleans, numbers,
        /// strings).  For booleans, %FALSE is less than %TRUE.  Numbers are
        /// ordered in the usual way.  Strings are in ASCII lexographical order.
        /// 
        /// It is a programmer error to attempt to compare container values or
        /// two values that have types that are not exactly equal.  For example,
        /// you cannot compare a 32-bit signed integer with a 32-bit unsigned
        /// integer.  Also note that this function is not particularly
        /// well-behaved when it comes to comparison of doubles; in particular,
        /// the handling of incomparable values (ie: NaN) is undefined.
        /// 
        /// If you only require an equality comparison, g_variant_equal() is more
        /// general.
        /// </remarks>
        /// <param name="one">
        /// a basic-typed #GVariant instance
        /// </param>
        /// <param name="two">
        /// a #GVariant instance of the same type
        /// </param>
        /// <returns>
        /// negative value if a &lt; b;
        ///          zero if a = b;
        ///          positive value if a &gt; b.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Int32 g_variant_compare(
            [System.Runtime.InteropServices.In()] System.IntPtr one,
            [System.Runtime.InteropServices.In()] System.IntPtr two);

        /// <summary>
        /// Compares @one and @two.
        /// </summary>
        /// <remarks>
        /// The types of @one and @two are #gconstpointer only to allow use of
        /// this function with #GTree, #GPtrArray, etc.  They must each be a
        /// #GVariant.
        /// 
        /// Comparison is only defined for basic types (ie: booleans, numbers,
        /// strings).  For booleans, %FALSE is less than %TRUE.  Numbers are
        /// ordered in the usual way.  Strings are in ASCII lexographical order.
        /// 
        /// It is a programmer error to attempt to compare container values or
        /// two values that have types that are not exactly equal.  For example,
        /// you cannot compare a 32-bit signed integer with a 32-bit unsigned
        /// integer.  Also note that this function is not particularly
        /// well-behaved when it comes to comparison of doubles; in particular,
        /// the handling of incomparable values (ie: NaN) is undefined.
        /// 
        /// If you only require an equality comparison, g_variant_equal() is more
        /// general.
        /// </remarks>
        /// <param name="one">
        /// a basic-typed #GVariant instance
        /// </param>
        /// <param name="two">
        /// a #GVariant instance of the same type
        /// </param>
        /// <returns>
        /// negative value if a &lt; b;
        ///          zero if a = b;
        ///          positive value if a &gt; b.
        /// </returns>
        [GISharp.Core.Since("2.26")]
        public System.Int32 CompareTo(
            GISharp.GLib.Variant two)
        {
            return default(System.Int32);
        }

        /// <summary>
        /// Checks if @one and @two have the same type and value.
        /// </summary>
        /// <remarks>
        /// The types of @one and @two are #gconstpointer only to allow use of
        /// this function with #GHashTable.  They must each be a #GVariant.
        /// </remarks>
        /// <param name="one">
        /// a #GVariant instance
        /// </param>
        /// <param name="two">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @one and @two are equal
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_equal(
            [System.Runtime.InteropServices.In()] System.IntPtr one,
            [System.Runtime.InteropServices.In()] System.IntPtr two);

        /// <summary>
        /// Checks if @one and @two have the same type and value.
        /// </summary>
        /// <remarks>
        /// The types of @one and @two are #gconstpointer only to allow use of
        /// this function with #GHashTable.  They must each be a #GVariant.
        /// </remarks>
        /// <param name="one">
        /// a #GVariant instance
        /// </param>
        /// <param name="two">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @one and @two are equal
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Boolean Equals(
            GISharp.GLib.Variant two)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns the boolean value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_BOOLEAN.
        /// </remarks>
        /// <param name="value">
        /// a boolean #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE or %FALSE
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_get_boolean(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the byte value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_BYTE.
        /// </remarks>
        /// <param name="value">
        /// a byte #GVariant instance
        /// </param>
        /// <returns>
        /// a #guchar
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Byte g_variant_get_byte(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the string value of a #GVariant instance with an
        /// array-of-bytes type.  The string has no particular encoding.
        /// </summary>
        /// <remarks>
        /// If the array does not end with a nul terminator character, the empty
        /// string is returned.  For this reason, you can always trust that a
        /// non-%NULL nul-terminated string will be returned by this function.
        /// 
        /// If the array contains a nul terminator character somewhere other than
        /// the last byte then the returned string is the string, up to the first
        /// such nul character.
        /// 
        /// It is an error to call this function with a @value that is not an
        /// array of bytes.
        /// 
        /// The return value remains valid as long as @value exists.
        /// </remarks>
        /// <param name="value">
        /// an array-of-bytes #GVariant instance
        /// </param>
        /// <returns>
        /// 
        ///          the constant string
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.Byte[] g_variant_get_bytestring(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Gets the contents of an array of array of bytes #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result is
        /// stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of array of bytes #GVariant ('aay')
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.26")]
        static extern System.IntPtr g_variant_get_bytestring_array(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Reads a child item out of a container #GVariant instance.  This
        /// includes variants, maybes, arrays, tuples and dictionary
        /// entries.  It is an error to call this function on any other type of
        /// #GVariant.
        /// </summary>
        /// <remarks>
        /// It is an error if @index_ is greater than the number of child items
        /// in the container.  See g_variant_n_children().
        /// 
        /// The returned value is never floating.  You should free it with
        /// g_variant_unref() when you're done with it.
        /// 
        /// This function is O(1).
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <param name="index">
        /// the index of the child to fetch
        /// </param>
        /// <returns>
        /// the child at the specified index
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_child_value(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.In()] System.UInt64 index);

        /// <summary>
        /// Reads a child item out of a container #GVariant instance.  This
        /// includes variants, maybes, arrays, tuples and dictionary
        /// entries.  It is an error to call this function on any other type of
        /// #GVariant.
        /// </summary>
        /// <remarks>
        /// It is an error if @index_ is greater than the number of child items
        /// in the container.  See g_variant_n_children().
        /// 
        /// The returned value is never floating.  You should free it with
        /// g_variant_unref() when you're done with it.
        /// 
        /// This function is O(1).
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <param name="index">
        /// the index of the child to fetch
        /// </param>
        /// <returns>
        /// the child at the specified index
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant GetChildValue(
            System.UInt64 index)
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Returns a pointer to the serialised form of a #GVariant instance.
        /// The returned data may not be in fully-normalised form if read from an
        /// untrusted source.  The returned data must not be freed; it remains
        /// valid for as long as @value exists.
        /// </summary>
        /// <remarks>
        /// If @value is a fixed-sized value that was deserialised from a
        /// corrupted serialised container then %NULL may be returned.  In this
        /// case, the proper thing to do is typically to use the appropriate
        /// number of nul bytes in place of @value.  If @value is not fixed-sized
        /// then %NULL is never returned.
        /// 
        /// In the case that @value is already in serialised form, this function
        /// is O(1).  If the value is not already in serialised form,
        /// serialisation occurs implicitly and is approximately O(n) in the size
        /// of the result.
        /// 
        /// To deserialise the data returned by this function, in addition to the
        /// serialised data, you must know the type of the #GVariant, and (if the
        /// machine might be different) the endianness of the machine that stored
        /// it. As a result, file formats or network messages that incorporate
        /// serialised #GVariants must include this information either
        /// implicitly (for instance "the file always contains a
        /// %G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
        /// explicitly (by storing the type and/or endianness in addition to the
        /// serialised data).
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// the serialised form of @value, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_data(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns a pointer to the serialised form of a #GVariant instance.
        /// The semantics of this function are exactly the same as
        /// g_variant_get_data(), except that the returned #GBytes holds
        /// a reference to the variant data.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// A new #GBytes representing the variant data
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.36")]
        static extern System.IntPtr g_variant_get_data_as_bytes(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the double precision floating point value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_DOUBLE.
        /// </remarks>
        /// <param name="value">
        /// a double #GVariant instance
        /// </param>
        /// <returns>
        /// a #gdouble
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Double g_variant_get_double(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Provides access to the serialised data for an array of fixed-sized
        /// items.
        /// </summary>
        /// <remarks>
        /// @value must be an array with fixed-sized elements.  Numeric types are
        /// fixed-size, as are tuples containing only other fixed-sized types.
        /// 
        /// @element_size must be the size of a single element in the array,
        /// as given by the section on
        /// [serialized data memory][gvariant-serialised-data-memory].
        /// 
        /// In particular, arrays of these fixed-sized types can be interpreted
        /// as an array of the given C type, with @element_size set to the size
        /// the appropriate type:
        /// - %G_VARIANT_TYPE_INT16 (etc.): #gint16 (etc.)
        /// - %G_VARIANT_TYPE_BOOLEAN: #guchar (not #gboolean!)
        /// - %G_VARIANT_TYPE_BYTE: #guchar
        /// - %G_VARIANT_TYPE_HANDLE: #guint32
        /// - %G_VARIANT_TYPE_DOUBLE: #gdouble
        /// 
        /// For example, if calling this function for an array of 32-bit integers,
        /// you might say sizeof(gint32). This value isn't used except for the purpose
        /// of a double-check that the form of the serialised data matches the caller's
        /// expectation.
        /// 
        /// @n_elements, which must be non-%NULL is set equal to the number of
        /// items in the array.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant array with fixed-sized elements
        /// </param>
        /// <param name="nElements">
        /// a pointer to the location to store the number of items
        /// </param>
        /// <param name="elementSize">
        /// the size of each element
        /// </param>
        /// <returns>
        /// a pointer to
        ///     the fixed array
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)]
        static extern System.IntPtr[] g_variant_get_fixed_array(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.Out()] out System.UInt64 nElements,
            [System.Runtime.InteropServices.In()] System.UInt64 elementSize);

        /// <summary>
        /// Provides access to the serialised data for an array of fixed-sized
        /// items.
        /// </summary>
        /// <remarks>
        /// @value must be an array with fixed-sized elements.  Numeric types are
        /// fixed-size, as are tuples containing only other fixed-sized types.
        /// 
        /// @element_size must be the size of a single element in the array,
        /// as given by the section on
        /// [serialized data memory][gvariant-serialised-data-memory].
        /// 
        /// In particular, arrays of these fixed-sized types can be interpreted
        /// as an array of the given C type, with @element_size set to the size
        /// the appropriate type:
        /// - %G_VARIANT_TYPE_INT16 (etc.): #gint16 (etc.)
        /// - %G_VARIANT_TYPE_BOOLEAN: #guchar (not #gboolean!)
        /// - %G_VARIANT_TYPE_BYTE: #guchar
        /// - %G_VARIANT_TYPE_HANDLE: #guint32
        /// - %G_VARIANT_TYPE_DOUBLE: #gdouble
        /// 
        /// For example, if calling this function for an array of 32-bit integers,
        /// you might say sizeof(gint32). This value isn't used except for the purpose
        /// of a double-check that the form of the serialised data matches the caller's
        /// expectation.
        /// 
        /// @n_elements, which must be non-%NULL is set equal to the number of
        /// items in the array.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant array with fixed-sized elements
        /// </param>
        /// <param name="nElements">
        /// a pointer to the location to store the number of items
        /// </param>
        /// <param name="elementSize">
        /// the size of each element
        /// </param>
        /// <returns>
        /// a pointer to
        ///     the fixed array
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.IntPtr[] GetFixedArray(
            System.UInt64 elementSize)
        {
            return default(System.IntPtr[]);
        }

        /// <summary>
        /// Returns the 32-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type other
        /// than %G_VARIANT_TYPE_HANDLE.
        /// 
        /// By convention, handles are indexes into an array of file descriptors
        /// that are sent alongside a D-Bus message.  If you're not interacting
        /// with D-Bus, you probably don't need them.
        /// </remarks>
        /// <param name="value">
        /// a handle #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint32
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Int32 g_variant_get_handle(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the 16-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT16.
        /// </remarks>
        /// <param name="value">
        /// a int16 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint16
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Int16 g_variant_get_int16(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the 32-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT32.
        /// </remarks>
        /// <param name="value">
        /// a int32 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint32
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Int32 g_variant_get_int32(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the 64-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT64.
        /// </remarks>
        /// <param name="value">
        /// a int64 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint64
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Int64 g_variant_get_int64(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Given a maybe-typed #GVariant instance, extract its value.  If the
        /// value is Nothing, then this function returns %NULL.
        /// </summary>
        /// <param name="value">
        /// a maybe-typed value
        /// </param>
        /// <returns>
        /// the contents of @value, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_maybe(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Gets a #GVariant instance that has the same value as @value and is
        /// trusted to be in normal form.
        /// </summary>
        /// <remarks>
        /// If @value is already trusted to be in normal form then a new
        /// reference to @value is returned.
        /// 
        /// If @value is not already trusted, then it is scanned to check if it
        /// is in normal form.  If it is found to be in normal form then it is
        /// marked as trusted and a new reference to it is returned.
        /// 
        /// If @value is found not to be in normal form then a new trusted
        /// #GVariant is created with the same value as @value.
        /// 
        /// It makes sense to call this function if you've received #GVariant
        /// data from untrusted sources and you want to ensure your serialised
        /// output is definitely in normal form.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// a trusted #GVariant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_normal_form(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Gets the contents of an array of object paths #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of object paths #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.30")]
        static extern System.IntPtr g_variant_get_objv(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Determines the number of bytes that would be required to store @value
        /// with g_variant_store().
        /// </summary>
        /// <remarks>
        /// If @value has a fixed-sized type then this function always returned
        /// that fixed size.
        /// 
        /// In the case that @value is already in serialised form or the size has
        /// already been calculated (ie: this function has been called before)
        /// then this function is O(1).  Otherwise, the size is calculated, an
        /// operation which is approximately O(n) in the number of values
        /// involved.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// the serialised size of @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt64 g_variant_get_size(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the string value of a #GVariant instance with a string
        /// type.  This includes the types %G_VARIANT_TYPE_STRING,
        /// %G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.
        /// </summary>
        /// <remarks>
        /// The string will always be utf8 encoded.
        /// 
        /// If @length is non-%NULL then the length of the string (in bytes) is
        /// returned there.  For trusted values, this information is already
        /// known.  For untrusted values, a strlen() will be performed.
        /// 
        /// It is an error to call this function with a @value of any type
        /// other than those three.
        /// 
        /// The return value remains valid as long as @value exists.
        /// </remarks>
        /// <param name="value">
        /// a string #GVariant instance
        /// </param>
        /// <param name="length">
        /// a pointer to a #gsize,
        ///          to store the length
        /// </param>
        /// <returns>
        /// the constant string, utf8 encoded
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_string(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Returns the string value of a #GVariant instance with a string
        /// type.  This includes the types %G_VARIANT_TYPE_STRING,
        /// %G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.
        /// </summary>
        /// <remarks>
        /// The string will always be utf8 encoded.
        /// 
        /// If @length is non-%NULL then the length of the string (in bytes) is
        /// returned there.  For trusted values, this information is already
        /// known.  For untrusted values, a strlen() will be performed.
        /// 
        /// It is an error to call this function with a @value of any type
        /// other than those three.
        /// 
        /// The return value remains valid as long as @value exists.
        /// </remarks>
        /// <param name="value">
        /// a string #GVariant instance
        /// </param>
        /// <param name="length">
        /// a pointer to a #gsize,
        ///          to store the length
        /// </param>
        /// <returns>
        /// the constant string, utf8 encoded
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.String GetString(
            out System.UInt64 length)
        {
            length = default(System.UInt64);
            return default(System.String);
        }

        /// <summary>
        /// Gets the contents of an array of strings #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of strings #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_strv(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.Out()] out System.UInt64 length);

        /// <summary>
        /// Determines the type of @value.
        /// </summary>
        /// <remarks>
        /// The return value is valid for the lifetime of @value and must not
        /// be freed.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// a #GVariantType
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_type(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the type string of @value.  Unlike the result of calling
        /// g_variant_type_peek_string(), this string is nul-terminated.  This
        /// string belongs to #GVariant and must not be freed.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the type string for the type of @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_type_string(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the 16-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT16.
        /// </remarks>
        /// <param name="value">
        /// a uint16 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint16
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt16 g_variant_get_uint16(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the 32-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT32.
        /// </remarks>
        /// <param name="value">
        /// a uint32 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint32
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt32 g_variant_get_uint32(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Returns the 64-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT64.
        /// </remarks>
        /// <param name="value">
        /// a uint64 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint64
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt64 g_variant_get_uint64(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// This function is intended to be used by libraries based on #GVariant
        /// that want to provide g_variant_get()-like functionality to their
        /// users.
        /// </summary>
        /// <remarks>
        /// The API is more general than g_variant_get() to allow a wider range
        /// of possible uses.
        /// 
        /// @format_string must still point to a valid format string, but it only
        /// need to be nul-terminated if @endptr is %NULL.  If @endptr is
        /// non-%NULL then it is updated to point to the first character past the
        /// end of the format string.
        /// 
        /// @app is a pointer to a #va_list.  The arguments, according to
        /// @format_string, are collected from this #va_list and the list is left
        /// pointing to the argument following the last.
        /// 
        /// These two generalisations allow mixing of multiple calls to
        /// g_variant_new_va() and g_variant_get_va() within a single actual
        /// varargs call by the user.
        /// 
        /// @format_string determines the C types that are used for unpacking
        /// the values and also determines if the values are copied or borrowed,
        /// see the section on
        /// [GVariant format strings][gvariant-format-strings-pointers].
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="formatString">
        /// a string that is prefixed with a format string
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer,
        ///          or %NULL
        /// </param>
        /// <param name="app">
        /// a pointer to a #va_list
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_get_va(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.In()] System.IntPtr formatString,
            [System.Runtime.InteropServices.In()] System.IntPtr endptr,
            [System.Runtime.InteropServices.In()] System.IntPtr app);

        /// <summary>
        /// This function is intended to be used by libraries based on #GVariant
        /// that want to provide g_variant_get()-like functionality to their
        /// users.
        /// </summary>
        /// <remarks>
        /// The API is more general than g_variant_get() to allow a wider range
        /// of possible uses.
        /// 
        /// @format_string must still point to a valid format string, but it only
        /// need to be nul-terminated if @endptr is %NULL.  If @endptr is
        /// non-%NULL then it is updated to point to the first character past the
        /// end of the format string.
        /// 
        /// @app is a pointer to a #va_list.  The arguments, according to
        /// @format_string, are collected from this #va_list and the list is left
        /// pointing to the argument following the last.
        /// 
        /// These two generalisations allow mixing of multiple calls to
        /// g_variant_new_va() and g_variant_get_va() within a single actual
        /// varargs call by the user.
        /// 
        /// @format_string determines the C types that are used for unpacking
        /// the values and also determines if the values are copied or borrowed,
        /// see the section on
        /// [GVariant format strings][gvariant-format-strings-pointers].
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="formatString">
        /// a string that is prefixed with a format string
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer,
        ///          or %NULL
        /// </param>
        /// <param name="app">
        /// a pointer to a #va_list
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void GetVa(
            System.String formatString,
            System.String endptr,
            System.Object[] app)
        {
        }

        /// <summary>
        /// Unboxes @value.  The result is the #GVariant instance that was
        /// contained in @value.
        /// </summary>
        /// <param name="value">
        /// a variant #GVariant instance
        /// </param>
        /// <returns>
        /// the item contained in the variant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_get_variant(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Generates a hash value for a #GVariant instance.
        /// </summary>
        /// <remarks>
        /// The output of this function is guaranteed to be the same for a given
        /// value only per-process.  It may change between different processor
        /// architectures or even different versions of GLib.  Do not use this
        /// function as a basis for building protocols or file formats.
        /// 
        /// The type of @value is #gconstpointer only to allow use of this
        /// function with #GHashTable.  @value must be a #GVariant.
        /// </remarks>
        /// <param name="value">
        /// a basic #GVariant value as a #gconstpointer
        /// </param>
        /// <returns>
        /// a hash value corresponding to @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt32 g_variant_hash(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Generates a hash value for a #GVariant instance.
        /// </summary>
        /// <remarks>
        /// The output of this function is guaranteed to be the same for a given
        /// value only per-process.  It may change between different processor
        /// architectures or even different versions of GLib.  Do not use this
        /// function as a basis for building protocols or file formats.
        /// 
        /// The type of @value is #gconstpointer only to allow use of this
        /// function with #GHashTable.  @value must be a #GVariant.
        /// </remarks>
        /// <param name="value">
        /// a basic #GVariant value as a #gconstpointer
        /// </param>
        /// <returns>
        /// a hash value corresponding to @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        protected System.UInt32 Hash()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Checks if @value is a container.
        /// </summary>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @value is a container
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_is_container(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Checks if @value is in normal form.
        /// </summary>
        /// <remarks>
        /// The main reason to do this is to detect if a given chunk of
        /// serialised data is in normal form: load the data into a #GVariant
        /// using g_variant_new_from_data() and then use this function to
        /// check.
        /// 
        /// If @value is found to be in normal form then it will be marked as
        /// being trusted.  If the value was already marked as being trusted then
        /// this function will immediately return %TRUE.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @value is in normal form
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_is_normal_form(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Checks if a value has a type matching the provided type.
        /// </summary>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if the type of @value matches @type
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_is_of_type(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Checks if a value has a type matching the provided type.
        /// </summary>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if the type of @value matches @type
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.Boolean IsOfType(
            GISharp.GLib.VariantType type)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Creates a heap-allocated #GVariantIter for iterating over the items
        /// in @value.
        /// </summary>
        /// <remarks>
        /// Use g_variant_iter_free() to free the return value when you no longer
        /// need it.
        /// 
        /// A reference is taken to @value and will be released only when
        /// g_variant_iter_free() is called.
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// a new heap-allocated #GVariantIter
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_iter_new(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Creates a heap-allocated #GVariantIter for iterating over the items
        /// in @value.
        /// </summary>
        /// <remarks>
        /// Use g_variant_iter_free() to free the return value when you no longer
        /// need it.
        /// 
        /// A reference is taken to @value and will be released only when
        /// g_variant_iter_free() is called.
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// a new heap-allocated #GVariantIter
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.VariantIter IterNew()
        {
            return default(GISharp.GLib.VariantIter);
        }

        /// <summary>
        /// Looks up a value in a dictionary #GVariant.
        /// </summary>
        /// <remarks>
        /// This function works with dictionaries of the type a{s*} (and equally
        /// well with type a{o*}, but we only further discuss the string case
        /// for sake of clarity).
        /// 
        /// In the event that @dictionary has the type a{sv}, the @expected_type
        /// string specifies what type of value is expected to be inside of the
        /// variant. If the value inside the variant has a different type then
        /// %NULL is returned. In the event that @dictionary has a value type other
        /// than v then @expected_type must directly match the key type and it is
        /// used to unpack the value directly or an error occurs.
        /// 
        /// In either case, if @key is not found in @dictionary, %NULL is returned.
        /// 
        /// If the key is found and the value has the correct type, it is
        /// returned.  If @expected_type was specified then any non-%NULL return
        /// value will have this type.
        /// 
        /// This function is currently implemented with a linear scan.  If you
        /// plan to do many lookups then #GVariantDict may be more efficient.
        /// </remarks>
        /// <param name="dictionary">
        /// a dictionary #GVariant
        /// </param>
        /// <param name="key">
        /// the key to lookup in the dictionary
        /// </param>
        /// <param name="expectedType">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <returns>
        /// the value of the dictionary key, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.28")]
        static extern System.IntPtr g_variant_lookup_value(
            [System.Runtime.InteropServices.In()] System.IntPtr dictionary,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr expectedType);

        /// <summary>
        /// Looks up a value in a dictionary #GVariant.
        /// </summary>
        /// <remarks>
        /// This function works with dictionaries of the type a{s*} (and equally
        /// well with type a{o*}, but we only further discuss the string case
        /// for sake of clarity).
        /// 
        /// In the event that @dictionary has the type a{sv}, the @expected_type
        /// string specifies what type of value is expected to be inside of the
        /// variant. If the value inside the variant has a different type then
        /// %NULL is returned. In the event that @dictionary has a value type other
        /// than v then @expected_type must directly match the key type and it is
        /// used to unpack the value directly or an error occurs.
        /// 
        /// In either case, if @key is not found in @dictionary, %NULL is returned.
        /// 
        /// If the key is found and the value has the correct type, it is
        /// returned.  If @expected_type was specified then any non-%NULL return
        /// value will have this type.
        /// 
        /// This function is currently implemented with a linear scan.  If you
        /// plan to do many lookups then #GVariantDict may be more efficient.
        /// </remarks>
        /// <param name="dictionary">
        /// a dictionary #GVariant
        /// </param>
        /// <param name="key">
        /// the key to lookup in the dictionary
        /// </param>
        /// <param name="expectedType">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <returns>
        /// the value of the dictionary key, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.28")]
        public GISharp.GLib.Variant LookupValue(
            System.String key,
            GISharp.GLib.VariantType expectedType)
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Determines the number of children in a container #GVariant instance.
        /// This includes variants, maybes, arrays, tuples and dictionary
        /// entries.  It is an error to call this function on any other type of
        /// #GVariant.
        /// </summary>
        /// <remarks>
        /// For variants, the return value is always 1.  For values with maybe
        /// types, it is always zero or one.  For arrays, it is the length of the
        /// array.  For tuples it is the number of tuple items (which depends
        /// only on the type).  For dictionary entries, it is always 2
        /// 
        /// This function is O(1).
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// the number of children in the container
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt64 g_variant_n_children(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Determines the number of children in a container #GVariant instance.
        /// This includes variants, maybes, arrays, tuples and dictionary
        /// entries.  It is an error to call this function on any other type of
        /// #GVariant.
        /// </summary>
        /// <remarks>
        /// For variants, the return value is always 1.  For values with maybe
        /// types, it is always zero or one.  For arrays, it is the length of the
        /// array.  For tuples it is the number of tuple items (which depends
        /// only on the type).  For dictionary entries, it is always 2
        /// 
        /// This function is O(1).
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// the number of children in the container
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt64 NChildren()
        {
            return default(System.UInt64);
        }

        /// <summary>
        /// Pretty-prints @value in the format understood by g_variant_parse().
        /// </summary>
        /// <remarks>
        /// The format is described [here][gvariant-text].
        /// 
        /// If @type_annotate is %TRUE, then type information is included in
        /// the output.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="typeAnnotate">
        /// %TRUE if type information should be included in
        ///                 the output
        /// </param>
        /// <returns>
        /// a newly-allocated string holding the result.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_print(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.In()] System.Boolean typeAnnotate);

        /// <summary>
        /// Pretty-prints @value in the format understood by g_variant_parse().
        /// </summary>
        /// <remarks>
        /// The format is described [here][gvariant-text].
        /// 
        /// If @type_annotate is %TRUE, then type information is included in
        /// the output.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="typeAnnotate">
        /// %TRUE if type information should be included in
        ///                 the output
        /// </param>
        /// <returns>
        /// a newly-allocated string holding the result.
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.String Print(
            System.Boolean typeAnnotate)
        {
            return default(System.String);
        }

        /// <summary>
        /// #GVariant uses a floating reference count system.  All functions with
        /// names starting with `g_variant_new_` return floating
        /// references.
        /// </summary>
        /// <remarks>
        /// Calling g_variant_ref_sink() on a #GVariant with a floating reference
        /// will convert the floating reference into a full reference.  Calling
        /// g_variant_ref_sink() on a non-floating #GVariant results in an
        /// additional normal reference being added.
        /// 
        /// In other words, if the @value is floating, then this call "assumes
        /// ownership" of the floating reference, converting it to a normal
        /// reference.  If the @value is not floating, then this call adds a
        /// new normal reference increasing the reference count by one.
        /// 
        /// All calls that result in a #GVariant instance being inserted into a
        /// container will call g_variant_ref_sink() on the instance.  This means
        /// that if the value was just created (and has only its floating
        /// reference) then the container will assume sole ownership of the value
        /// at that point and the caller will not need to unreference it.  This
        /// makes certain common styles of programming much easier while still
        /// maintaining normal refcounting semantics in situations where values
        /// are not floating.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the same @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_ref_sink(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// #GVariant uses a floating reference count system.  All functions with
        /// names starting with `g_variant_new_` return floating
        /// references.
        /// </summary>
        /// <remarks>
        /// Calling g_variant_ref_sink() on a #GVariant with a floating reference
        /// will convert the floating reference into a full reference.  Calling
        /// g_variant_ref_sink() on a non-floating #GVariant results in an
        /// additional normal reference being added.
        /// 
        /// In other words, if the @value is floating, then this call "assumes
        /// ownership" of the floating reference, converting it to a normal
        /// reference.  If the @value is not floating, then this call adds a
        /// new normal reference increasing the reference count by one.
        /// 
        /// All calls that result in a #GVariant instance being inserted into a
        /// container will call g_variant_ref_sink() on the instance.  This means
        /// that if the value was just created (and has only its floating
        /// reference) then the container will assume sole ownership of the value
        /// at that point and the caller will not need to unreference it.  This
        /// makes certain common styles of programming much easier while still
        /// maintaining normal refcounting semantics in situations where values
        /// are not floating.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the same @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Stores the serialised form of @value at @data.  @data should be
        /// large enough.  See g_variant_get_size().
        /// </summary>
        /// <remarks>
        /// The stored data is in machine native byte order but may not be in
        /// fully-normalised form if read from an untrusted source.  See
        /// g_variant_get_normal_form() for a solution.
        /// 
        /// As with g_variant_get_data(), to be able to deserialise the
        /// serialised variant successfully, its type and (if the destination
        /// machine might be different) its endianness must also be available.
        /// 
        /// This function is approximately O(n) in the size of @data.
        /// </remarks>
        /// <param name="value">
        /// the #GVariant to store
        /// </param>
        /// <param name="data">
        /// the location to store the serialised data at
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_store(
            [System.Runtime.InteropServices.In()] System.IntPtr value,
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Stores the serialised form of @value at @data.  @data should be
        /// large enough.  See g_variant_get_size().
        /// </summary>
        /// <remarks>
        /// The stored data is in machine native byte order but may not be in
        /// fully-normalised form if read from an untrusted source.  See
        /// g_variant_get_normal_form() for a solution.
        /// 
        /// As with g_variant_get_data(), to be able to deserialise the
        /// serialised variant successfully, its type and (if the destination
        /// machine might be different) its endianness must also be available.
        /// 
        /// This function is approximately O(n) in the size of @data.
        /// </remarks>
        /// <param name="value">
        /// the #GVariant to store
        /// </param>
        /// <param name="data">
        /// the location to store the serialised data at
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void Store(
            System.IntPtr data)
        {
        }

        /// <summary>
        /// Decreases the reference count of @value.  When its reference count
        /// drops to 0, the memory used by the variant is freed.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Decreases the reference count of @value.  When its reference count
        /// drops to 0, the memory used by the variant is freed.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        [GISharp.Core.Since("2.24")]
        public override void Unref()
        {
        }

        public static bool operator <(GISharp.GLib.Variant one, GISharp.GLib.Variant two)
        {
            return one.CompareTo(two) < 0;
        }

        public static bool operator <=(GISharp.GLib.Variant one, GISharp.GLib.Variant two)
        {
            return one.CompareTo(two) <= 0;
        }

        public static bool operator >=(GISharp.GLib.Variant one, GISharp.GLib.Variant two)
        {
            return one.CompareTo(two) >= 0;
        }

        public static bool operator >(GISharp.GLib.Variant one, GISharp.GLib.Variant two)
        {
            return one.CompareTo(two) > 0;
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as GISharp.GLib.Variant);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public static bool operator ==(GISharp.GLib.Variant one, GISharp.GLib.Variant two)
        {
            if ((object)one == null)
            {
                return (object)two == null;
            }
            return one.Equals(two);
        }

        public static bool operator !=(GISharp.GLib.Variant one, GISharp.GLib.Variant two)
        {
            return !(one == two);
        }
    }

    /// <summary>
    /// A utility type for constructing container-type #GVariant instances.
    /// </summary>
    /// <remarks>
    /// This is an opaque structure and may only be accessed using the
    /// following functions.
    /// 
    /// #GVariantBuilder is not threadsafe in any way.  Do not attempt to
    /// access it from more than one thread.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"VariantBuilder\" c:type=\"GVariantBuilder\" glib:type-name=\"GVariantBuilder\" glib:get-type=\"g_variant_builder_get_type\" c:symbol-prefix=\"variant_builder\" gs:managed-name=\"VariantBuilder\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">A utility type for constructing container-type #GVariant instances.\n\nThis is an opaque structure and may only be accessed using the\nfollowing functions.\n\n#GVariantBuilder is not threadsafe in any way.  Do not attempt to\naccess it from more than one thread.</doc>\n  <constructor name=\"new\" c:identifier=\"g_variant_builder_new\" version=\"2.24\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Allocates and initialises a new #GVariantBuilder.\n\nYou should call g_variant_builder_unref() on the return value when it\nis no longer needed.  The memory will not be automatically freed by\nany other call.\n\nIn most cases it is easier to place a #GVariantBuilder directly on\nthe stack of the calling function and initialise it with\ng_variant_builder_init().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n      <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container type</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container type</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"add_value\" c:identifier=\"g_variant_builder_add_value\" version=\"2.24\" gs:managed-name=\"AddValue\">\n    <doc xml:space=\"preserve\">Adds @value to @builder.\n\nIt is an error to call this function in any way that would create an\ninconsistent value to be constructed.  Some examples of this are\nputting different types of items into an array, putting the wrong\ntypes or number of items in a tuple, putting more than one value into\na variant, etc.\n\nIf @value is a floating reference (see g_variant_ref_sink()),\nthe @builder instance takes ownership of @value.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"clear\" c:identifier=\"g_variant_builder_clear\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"Clear\">\n    <doc xml:space=\"preserve\">Releases all memory associated with a #GVariantBuilder without\nfreeing the #GVariantBuilder structure itself.\n\nIt typically only makes sense to do this on a stack-allocated\n#GVariantBuilder if you want to abort building the value part-way\nthrough.  This function need not be called if you call\ng_variant_builder_end() and it also doesn't need to be called on\nbuilders allocated with g_variant_builder_new (see\ng_variant_builder_unref() for that).\n\nThis function leaves the #GVariantBuilder structure set to all-zeros.\nIt is valid to call this function on either an initialised\n#GVariantBuilder or one that is set to all-zeros but it is not valid\nto call this function on uninitialised memory.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"close\" c:identifier=\"g_variant_builder_close\" version=\"2.24\" gs:managed-name=\"Close\">\n    <doc xml:space=\"preserve\">Closes the subcontainer inside the given @builder that was opened by\nthe most recent call to g_variant_builder_open().\n\nIt is an error to call this function in any way that would create an\ninconsistent value to be constructed (ie: too few values added to the\nsubcontainer).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"end\" c:identifier=\"g_variant_builder_end\" version=\"2.24\" gs:managed-name=\"End\">\n    <doc xml:space=\"preserve\">Ends the builder process and returns the constructed value.\n\nIt is not permissible to use @builder in any way after this call\nexcept for reference counting operations (in the case of a\nheap-allocated #GVariantBuilder) or by reinitialising it with\ng_variant_builder_init() (in the case of stack-allocated).\n\nIt is an error to call this function in any way that would create an\ninconsistent value to be constructed (ie: insufficient number of\nitems added to a container with a specific number of children\nrequired).  It is also an error to call this function if the builder\nwas created with an indefinite array or maybe type and no children\nhave been added; in this case it is impossible to infer the type of\nthe empty array.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new, floating, #GVariant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"init\" c:identifier=\"g_variant_builder_init\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"Init\">\n    <doc xml:space=\"preserve\">Initialises a #GVariantBuilder structure.\n\n@type must be non-%NULL.  It specifies the type of container to\nconstruct.  It can be an indefinite type such as\n%G_VARIANT_TYPE_ARRAY or a definite type such as \"as\" or \"(ii)\".\nMaybe, array, tuple, dictionary entry and variant-typed values may be\nconstructed.\n\nAfter the builder is initialised, values are added using\ng_variant_builder_add_value() or g_variant_builder_add().\n\nAfter all the child values are added, g_variant_builder_end() frees\nthe memory associated with the builder and returns the #GVariant that\nwas created.\n\nThis function completely ignores the previous contents of @builder.\nOn one hand this means that it is valid to pass in completely\nuninitialised memory.  On the other hand, this means that if you are\ninitialising over top of an existing #GVariantBuilder you need to\nfirst call g_variant_builder_clear() in order to avoid leaking\nmemory.\n\nYou must not call g_variant_builder_ref() or\ng_variant_builder_unref() on a #GVariantBuilder that was initialised\nwith this function.  If you ever pass a reference to a\n#GVariantBuilder outside of the control of your own code then you\nshould assume that the person receiving that reference may try to use\nreference counting; you should use g_variant_builder_new() instead of\nthis function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container type</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container type</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"open\" c:identifier=\"g_variant_builder_open\" version=\"2.24\" gs:managed-name=\"Open\">\n    <doc xml:space=\"preserve\">Opens a subcontainer inside the given @builder.  When done adding\nitems to the subcontainer, g_variant_builder_close() must be called.\n\nIt is an error to call this function in any way that would cause an\ninconsistent value to be constructed (ie: adding too many values or\na value of an incorrect type).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_variant_builder_ref\" version=\"2.24\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count on @builder.\n\nDon't call this on stack-allocated #GVariantBuilder instances or bad\nthings will happen.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new reference to @builder</doc>\n      <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"none\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder allocated by g_variant_builder_new()</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"unref\" c:identifier=\"g_variant_builder_unref\" version=\"2.24\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count on @builder.\n\nIn the event that there are no more references, releases all memory\nassociated with the #GVariantBuilder.\n\nDon't call this on stack-allocated #GVariantBuilder instances or bad\nthings will happen.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"builder\" transfer-ownership=\"full\" gs:managed-name=\"builder\" gs:managed-type=\"VariantBuilder\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantBuilder allocated by g_variant_builder_new()</doc>\n        <type name=\"VariantBuilder\" c:type=\"GVariantBuilder*\" gs:managed-name=\"VariantBuilder\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    public partial class VariantBuilder : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.VariantBuilder>
    {
        public VariantBuilder(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Allocates and initialises a new #GVariantBuilder.
        /// </summary>
        /// <remarks>
        /// You should call g_variant_builder_unref() on the return value when it
        /// is no longer needed.  The memory will not be automatically freed by
        /// any other call.
        /// 
        /// In most cases it is easier to place a #GVariantBuilder directly on
        /// the stack of the calling function and initialise it with
        /// g_variant_builder_init().
        /// </remarks>
        /// <param name="type">
        /// a container type
        /// </param>
        /// <returns>
        /// a #GVariantBuilder
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public VariantBuilder(
            GISharp.GLib.VariantType type) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Allocates and initialises a new #GVariantBuilder.
        /// </summary>
        /// <remarks>
        /// You should call g_variant_builder_unref() on the return value when it
        /// is no longer needed.  The memory will not be automatically freed by
        /// any other call.
        /// 
        /// In most cases it is easier to place a #GVariantBuilder directly on
        /// the stack of the calling function and initialise it with
        /// g_variant_builder_init().
        /// </remarks>
        /// <param name="type">
        /// a container type
        /// </param>
        /// <returns>
        /// a #GVariantBuilder
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_builder_new(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Adds @value to @builder.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function in any way that would create an
        /// inconsistent value to be constructed.  Some examples of this are
        /// putting different types of items into an array, putting the wrong
        /// types or number of items in a tuple, putting more than one value into
        /// a variant, etc.
        /// 
        /// If @value is a floating reference (see g_variant_ref_sink()),
        /// the @builder instance takes ownership of @value.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_builder_add_value(
            [System.Runtime.InteropServices.In()] System.IntPtr builder,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Adds @value to @builder.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function in any way that would create an
        /// inconsistent value to be constructed.  Some examples of this are
        /// putting different types of items into an array, putting the wrong
        /// types or number of items in a tuple, putting more than one value into
        /// a variant, etc.
        /// 
        /// If @value is a floating reference (see g_variant_ref_sink()),
        /// the @builder instance takes ownership of @value.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void AddValue(
            GISharp.GLib.Variant value)
        {
        }

        /// <summary>
        /// Releases all memory associated with a #GVariantBuilder without
        /// freeing the #GVariantBuilder structure itself.
        /// </summary>
        /// <remarks>
        /// It typically only makes sense to do this on a stack-allocated
        /// #GVariantBuilder if you want to abort building the value part-way
        /// through.  This function need not be called if you call
        /// g_variant_builder_end() and it also doesn't need to be called on
        /// builders allocated with g_variant_builder_new (see
        /// g_variant_builder_unref() for that).
        /// 
        /// This function leaves the #GVariantBuilder structure set to all-zeros.
        /// It is valid to call this function on either an initialised
        /// #GVariantBuilder or one that is set to all-zeros but it is not valid
        /// to call this function on uninitialised memory.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_builder_clear(
            [System.Runtime.InteropServices.In()] System.IntPtr builder);

        /// <summary>
        /// Releases all memory associated with a #GVariantBuilder without
        /// freeing the #GVariantBuilder structure itself.
        /// </summary>
        /// <remarks>
        /// It typically only makes sense to do this on a stack-allocated
        /// #GVariantBuilder if you want to abort building the value part-way
        /// through.  This function need not be called if you call
        /// g_variant_builder_end() and it also doesn't need to be called on
        /// builders allocated with g_variant_builder_new (see
        /// g_variant_builder_unref() for that).
        /// 
        /// This function leaves the #GVariantBuilder structure set to all-zeros.
        /// It is valid to call this function on either an initialised
        /// #GVariantBuilder or one that is set to all-zeros but it is not valid
        /// to call this function on uninitialised memory.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void Clear()
        {
        }

        /// <summary>
        /// Closes the subcontainer inside the given @builder that was opened by
        /// the most recent call to g_variant_builder_open().
        /// </summary>
        /// <remarks>
        /// It is an error to call this function in any way that would create an
        /// inconsistent value to be constructed (ie: too few values added to the
        /// subcontainer).
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_builder_close(
            [System.Runtime.InteropServices.In()] System.IntPtr builder);

        /// <summary>
        /// Closes the subcontainer inside the given @builder that was opened by
        /// the most recent call to g_variant_builder_open().
        /// </summary>
        /// <remarks>
        /// It is an error to call this function in any way that would create an
        /// inconsistent value to be constructed (ie: too few values added to the
        /// subcontainer).
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void Close()
        {
        }

        /// <summary>
        /// Ends the builder process and returns the constructed value.
        /// </summary>
        /// <remarks>
        /// It is not permissible to use @builder in any way after this call
        /// except for reference counting operations (in the case of a
        /// heap-allocated #GVariantBuilder) or by reinitialising it with
        /// g_variant_builder_init() (in the case of stack-allocated).
        /// 
        /// It is an error to call this function in any way that would create an
        /// inconsistent value to be constructed (ie: insufficient number of
        /// items added to a container with a specific number of children
        /// required).  It is also an error to call this function if the builder
        /// was created with an indefinite array or maybe type and no children
        /// have been added; in this case it is impossible to infer the type of
        /// the empty array.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <returns>
        /// a new, floating, #GVariant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_builder_end(
            [System.Runtime.InteropServices.In()] System.IntPtr builder);

        /// <summary>
        /// Ends the builder process and returns the constructed value.
        /// </summary>
        /// <remarks>
        /// It is not permissible to use @builder in any way after this call
        /// except for reference counting operations (in the case of a
        /// heap-allocated #GVariantBuilder) or by reinitialising it with
        /// g_variant_builder_init() (in the case of stack-allocated).
        /// 
        /// It is an error to call this function in any way that would create an
        /// inconsistent value to be constructed (ie: insufficient number of
        /// items added to a container with a specific number of children
        /// required).  It is also an error to call this function if the builder
        /// was created with an indefinite array or maybe type and no children
        /// have been added; in this case it is impossible to infer the type of
        /// the empty array.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <returns>
        /// a new, floating, #GVariant
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant End()
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Initialises a #GVariantBuilder structure.
        /// </summary>
        /// <remarks>
        /// @type must be non-%NULL.  It specifies the type of container to
        /// construct.  It can be an indefinite type such as
        /// %G_VARIANT_TYPE_ARRAY or a definite type such as "as" or "(ii)".
        /// Maybe, array, tuple, dictionary entry and variant-typed values may be
        /// constructed.
        /// 
        /// After the builder is initialised, values are added using
        /// g_variant_builder_add_value() or g_variant_builder_add().
        /// 
        /// After all the child values are added, g_variant_builder_end() frees
        /// the memory associated with the builder and returns the #GVariant that
        /// was created.
        /// 
        /// This function completely ignores the previous contents of @builder.
        /// On one hand this means that it is valid to pass in completely
        /// uninitialised memory.  On the other hand, this means that if you are
        /// initialising over top of an existing #GVariantBuilder you need to
        /// first call g_variant_builder_clear() in order to avoid leaking
        /// memory.
        /// 
        /// You must not call g_variant_builder_ref() or
        /// g_variant_builder_unref() on a #GVariantBuilder that was initialised
        /// with this function.  If you ever pass a reference to a
        /// #GVariantBuilder outside of the control of your own code then you
        /// should assume that the person receiving that reference may try to use
        /// reference counting; you should use g_variant_builder_new() instead of
        /// this function.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <param name="type">
        /// a container type
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_builder_init(
            [System.Runtime.InteropServices.In()] System.IntPtr builder,
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Initialises a #GVariantBuilder structure.
        /// </summary>
        /// <remarks>
        /// @type must be non-%NULL.  It specifies the type of container to
        /// construct.  It can be an indefinite type such as
        /// %G_VARIANT_TYPE_ARRAY or a definite type such as "as" or "(ii)".
        /// Maybe, array, tuple, dictionary entry and variant-typed values may be
        /// constructed.
        /// 
        /// After the builder is initialised, values are added using
        /// g_variant_builder_add_value() or g_variant_builder_add().
        /// 
        /// After all the child values are added, g_variant_builder_end() frees
        /// the memory associated with the builder and returns the #GVariant that
        /// was created.
        /// 
        /// This function completely ignores the previous contents of @builder.
        /// On one hand this means that it is valid to pass in completely
        /// uninitialised memory.  On the other hand, this means that if you are
        /// initialising over top of an existing #GVariantBuilder you need to
        /// first call g_variant_builder_clear() in order to avoid leaking
        /// memory.
        /// 
        /// You must not call g_variant_builder_ref() or
        /// g_variant_builder_unref() on a #GVariantBuilder that was initialised
        /// with this function.  If you ever pass a reference to a
        /// #GVariantBuilder outside of the control of your own code then you
        /// should assume that the person receiving that reference may try to use
        /// reference counting; you should use g_variant_builder_new() instead of
        /// this function.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <param name="type">
        /// a container type
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void Init(
            GISharp.GLib.VariantType type)
        {
        }

        /// <summary>
        /// Opens a subcontainer inside the given @builder.  When done adding
        /// items to the subcontainer, g_variant_builder_close() must be called.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function in any way that would cause an
        /// inconsistent value to be constructed (ie: adding too many values or
        /// a value of an incorrect type).
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_builder_open(
            [System.Runtime.InteropServices.In()] System.IntPtr builder,
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Opens a subcontainer inside the given @builder.  When done adding
        /// items to the subcontainer, g_variant_builder_close() must be called.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function in any way that would cause an
        /// inconsistent value to be constructed (ie: adding too many values or
        /// a value of an incorrect type).
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder
        /// </param>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        [GISharp.Core.Since("2.24")]
        public void Open(
            GISharp.GLib.VariantType type)
        {
        }

        /// <summary>
        /// Increases the reference count on @builder.
        /// </summary>
        /// <remarks>
        /// Don't call this on stack-allocated #GVariantBuilder instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder allocated by g_variant_builder_new()
        /// </param>
        /// <returns>
        /// a new reference to @builder
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_builder_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr builder);

        /// <summary>
        /// Increases the reference count on @builder.
        /// </summary>
        /// <remarks>
        /// Don't call this on stack-allocated #GVariantBuilder instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder allocated by g_variant_builder_new()
        /// </param>
        /// <returns>
        /// a new reference to @builder
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Decreases the reference count on @builder.
        /// </summary>
        /// <remarks>
        /// In the event that there are no more references, releases all memory
        /// associated with the #GVariantBuilder.
        /// 
        /// Don't call this on stack-allocated #GVariantBuilder instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder allocated by g_variant_builder_new()
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_builder_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr builder);

        /// <summary>
        /// Decreases the reference count on @builder.
        /// </summary>
        /// <remarks>
        /// In the event that there are no more references, releases all memory
        /// associated with the #GVariantBuilder.
        /// 
        /// Don't call this on stack-allocated #GVariantBuilder instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="builder">
        /// a #GVariantBuilder allocated by g_variant_builder_new()
        /// </param>
        [GISharp.Core.Since("2.24")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// The range of possible top-level types of #GVariant instances.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"VariantClass\" version=\"2.24\" c:type=\"GVariantClass\" gs:managed-name=\"VariantClass\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">The range of possible top-level types of #GVariant instances.</doc>\n  <member name=\"boolean\" value=\"98\" c:identifier=\"G_VARIANT_CLASS_BOOLEAN\" gs:managed-name=\"Boolean\">\n    <doc xml:space=\"preserve\">The #GVariant is a boolean.</doc>\n  </member>\n  <member name=\"byte\" value=\"121\" c:identifier=\"G_VARIANT_CLASS_BYTE\" gs:managed-name=\"Byte\">\n    <doc xml:space=\"preserve\">The #GVariant is a byte.</doc>\n  </member>\n  <member name=\"int16\" value=\"110\" c:identifier=\"G_VARIANT_CLASS_INT16\" gs:managed-name=\"Int16\">\n    <doc xml:space=\"preserve\">The #GVariant is a signed 16 bit integer.</doc>\n  </member>\n  <member name=\"uint16\" value=\"113\" c:identifier=\"G_VARIANT_CLASS_UINT16\" gs:managed-name=\"Uint16\">\n    <doc xml:space=\"preserve\">The #GVariant is an unsigned 16 bit integer.</doc>\n  </member>\n  <member name=\"int32\" value=\"105\" c:identifier=\"G_VARIANT_CLASS_INT32\" gs:managed-name=\"Int32\">\n    <doc xml:space=\"preserve\">The #GVariant is a signed 32 bit integer.</doc>\n  </member>\n  <member name=\"uint32\" value=\"117\" c:identifier=\"G_VARIANT_CLASS_UINT32\" gs:managed-name=\"Uint32\">\n    <doc xml:space=\"preserve\">The #GVariant is an unsigned 32 bit integer.</doc>\n  </member>\n  <member name=\"int64\" value=\"120\" c:identifier=\"G_VARIANT_CLASS_INT64\" gs:managed-name=\"Int64\">\n    <doc xml:space=\"preserve\">The #GVariant is a signed 64 bit integer.</doc>\n  </member>\n  <member name=\"uint64\" value=\"116\" c:identifier=\"G_VARIANT_CLASS_UINT64\" gs:managed-name=\"Uint64\">\n    <doc xml:space=\"preserve\">The #GVariant is an unsigned 64 bit integer.</doc>\n  </member>\n  <member name=\"handle\" value=\"104\" c:identifier=\"G_VARIANT_CLASS_HANDLE\" gs:managed-name=\"Handle\">\n    <doc xml:space=\"preserve\">The #GVariant is a file handle index.</doc>\n  </member>\n  <member name=\"double\" value=\"100\" c:identifier=\"G_VARIANT_CLASS_DOUBLE\" gs:managed-name=\"Double\">\n    <doc xml:space=\"preserve\">The #GVariant is a double precision floating\n                         point value.</doc>\n  </member>\n  <member name=\"string\" value=\"115\" c:identifier=\"G_VARIANT_CLASS_STRING\" gs:managed-name=\"String\">\n    <doc xml:space=\"preserve\">The #GVariant is a normal string.</doc>\n  </member>\n  <member name=\"object_path\" value=\"111\" c:identifier=\"G_VARIANT_CLASS_OBJECT_PATH\" gs:managed-name=\"ObjectPath\">\n    <doc xml:space=\"preserve\">The #GVariant is a D-Bus object path\n                              string.</doc>\n  </member>\n  <member name=\"signature\" value=\"103\" c:identifier=\"G_VARIANT_CLASS_SIGNATURE\" gs:managed-name=\"Signature\">\n    <doc xml:space=\"preserve\">The #GVariant is a D-Bus signature string.</doc>\n  </member>\n  <member name=\"variant\" value=\"118\" c:identifier=\"G_VARIANT_CLASS_VARIANT\" gs:managed-name=\"Variant\">\n    <doc xml:space=\"preserve\">The #GVariant is a variant.</doc>\n  </member>\n  <member name=\"maybe\" value=\"109\" c:identifier=\"G_VARIANT_CLASS_MAYBE\" gs:managed-name=\"Maybe\">\n    <doc xml:space=\"preserve\">The #GVariant is a maybe-typed value.</doc>\n  </member>\n  <member name=\"array\" value=\"97\" c:identifier=\"G_VARIANT_CLASS_ARRAY\" gs:managed-name=\"Array\">\n    <doc xml:space=\"preserve\">The #GVariant is an array.</doc>\n  </member>\n  <member name=\"tuple\" value=\"40\" c:identifier=\"G_VARIANT_CLASS_TUPLE\" gs:managed-name=\"Tuple\">\n    <doc xml:space=\"preserve\">The #GVariant is a tuple.</doc>\n  </member>\n  <member name=\"dict_entry\" value=\"123\" c:identifier=\"G_VARIANT_CLASS_DICT_ENTRY\" gs:managed-name=\"DictEntry\">\n    <doc xml:space=\"preserve\">The #GVariant is a dictionary entry.</doc>\n  </member>\n</enumeration>")]
    [GISharp.Core.Since("2.24")]
    public enum VariantClass
    {
        /// <summary>
        /// The #GVariant is a boolean.
        /// </summary>
        Boolean = 98,
        /// <summary>
        /// The #GVariant is a byte.
        /// </summary>
        Byte = 121,
        /// <summary>
        /// The #GVariant is a signed 16 bit integer.
        /// </summary>
        Int16 = 110,
        /// <summary>
        /// The #GVariant is an unsigned 16 bit integer.
        /// </summary>
        Uint16 = 113,
        /// <summary>
        /// The #GVariant is a signed 32 bit integer.
        /// </summary>
        Int32 = 105,
        /// <summary>
        /// The #GVariant is an unsigned 32 bit integer.
        /// </summary>
        Uint32 = 117,
        /// <summary>
        /// The #GVariant is a signed 64 bit integer.
        /// </summary>
        Int64 = 120,
        /// <summary>
        /// The #GVariant is an unsigned 64 bit integer.
        /// </summary>
        Uint64 = 116,
        /// <summary>
        /// The #GVariant is a file handle index.
        /// </summary>
        Handle = 104,
        /// <summary>
        /// The #GVariant is a double precision floating
        ///                          point value.
        /// </summary>
        Double = 100,
        /// <summary>
        /// The #GVariant is a normal string.
        /// </summary>
        String = 115,
        /// <summary>
        /// The #GVariant is a D-Bus object path
        ///                               string.
        /// </summary>
        ObjectPath = 111,
        /// <summary>
        /// The #GVariant is a D-Bus signature string.
        /// </summary>
        Signature = 103,
        /// <summary>
        /// The #GVariant is a variant.
        /// </summary>
        Variant = 118,
        /// <summary>
        /// The #GVariant is a maybe-typed value.
        /// </summary>
        Maybe = 109,
        /// <summary>
        /// The #GVariant is an array.
        /// </summary>
        Array = 97,
        /// <summary>
        /// The #GVariant is a tuple.
        /// </summary>
        Tuple = 40,
        /// <summary>
        /// The #GVariant is a dictionary entry.
        /// </summary>
        DictEntry = 123
    }

    /// <summary>
    /// #GVariantDict is a mutable interface to #GVariant dictionaries.
    /// </summary>
    /// <remarks>
    /// It can be used for doing a sequence of dictionary lookups in an
    /// efficient way on an existing #GVariant dictionary or it can be used
    /// to construct new dictionaries with a hashtable-like interface.  It
    /// can also be used for taking existing dictionaries and modifying them
    /// in order to create new ones.
    /// 
    /// #GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT
    /// dictionaries.
    /// 
    /// It is possible to use #GVariantDict allocated on the stack or on the
    /// heap.  When using a stack-allocated #GVariantDict, you begin with a
    /// call to g_variant_dict_init() and free the resources with a call to
    /// g_variant_dict_clear().
    /// 
    /// Heap-allocated #GVariantDict follows normal refcounting rules: you
    /// allocate it with g_variant_dict_new() and use g_variant_dict_ref()
    /// and g_variant_dict_unref().
    /// 
    /// g_variant_dict_end() is used to convert the #GVariantDict back into a
    /// dictionary-type #GVariant.  When used with stack-allocated instances,
    /// this also implicitly frees all associated memory, but for
    /// heap-allocated instances, you must still call g_variant_dict_unref()
    /// afterwards.
    /// 
    /// You will typically want to use a heap-allocated #GVariantDict when
    /// you expose it as part of an API.  For most other uses, the
    /// stack-allocated form will be more convenient.
    /// 
    /// Consider the following two examples that do the same thing in each
    /// style: take an existing dictionary and look up the "count" uint32
    /// key, adding 1 to it if it is found, or returning an error if the
    /// key is not found.  Each returns the new dictionary as a floating
    /// #GVariant.
    /// 
    /// ## Using a stack-allocated GVariantDict
    /// 
    /// |[&lt;!-- language="C" --&gt;
    ///   GVariant *
    ///   add_to_count (GVariant  *orig,
    ///                 GError   **error)
    ///   {
    ///     GVariantDict dict;
    ///     guint32 count;
    /// 
    ///     g_variant_dict_init (&amp;dict, orig);
    ///     if (!g_variant_dict_lookup (&amp;dict, "count", "u", &amp;count))
    ///       {
    ///         g_set_error (...);
    ///         g_variant_dict_clear (&amp;dict);
    ///         return NULL;
    ///       }
    /// 
    ///     g_variant_dict_insert (&amp;dict, "count", "u", count + 1);
    /// 
    ///     return g_variant_dict_end (&amp;dict);
    ///   }
    /// ]|
    /// 
    /// ## Using heap-allocated GVariantDict
    /// 
    /// |[&lt;!-- language="C" --&gt;
    ///   GVariant *
    ///   add_to_count (GVariant  *orig,
    ///                 GError   **error)
    ///   {
    ///     GVariantDict *dict;
    ///     GVariant *result;
    ///     guint32 count;
    /// 
    ///     dict = g_variant_dict_new (orig);
    /// 
    ///     if (g_variant_dict_lookup (dict, "count", "u", &amp;count))
    ///       {
    ///         g_variant_dict_insert (dict, "count", "u", count + 1);
    ///         result = g_variant_dict_end (dict);
    ///       }
    ///     else
    ///       {
    ///         g_set_error (...);
    ///         result = NULL;
    ///       }
    /// 
    ///     g_variant_dict_unref (dict);
    /// 
    ///     return result;
    ///   }
    /// ]|
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"VariantDict\" c:type=\"GVariantDict\" version=\"2.40\" glib:type-name=\"GVariantDict\" glib:get-type=\"g_variant_dict_get_type\" c:symbol-prefix=\"variant_dict\" gs:managed-name=\"VariantDict\" gs:opaque=\"ref-counted\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">#GVariantDict is a mutable interface to #GVariant dictionaries.\n\nIt can be used for doing a sequence of dictionary lookups in an\nefficient way on an existing #GVariant dictionary or it can be used\nto construct new dictionaries with a hashtable-like interface.  It\ncan also be used for taking existing dictionaries and modifying them\nin order to create new ones.\n\n#GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT\ndictionaries.\n\nIt is possible to use #GVariantDict allocated on the stack or on the\nheap.  When using a stack-allocated #GVariantDict, you begin with a\ncall to g_variant_dict_init() and free the resources with a call to\ng_variant_dict_clear().\n\nHeap-allocated #GVariantDict follows normal refcounting rules: you\nallocate it with g_variant_dict_new() and use g_variant_dict_ref()\nand g_variant_dict_unref().\n\ng_variant_dict_end() is used to convert the #GVariantDict back into a\ndictionary-type #GVariant.  When used with stack-allocated instances,\nthis also implicitly frees all associated memory, but for\nheap-allocated instances, you must still call g_variant_dict_unref()\nafterwards.\n\nYou will typically want to use a heap-allocated #GVariantDict when\nyou expose it as part of an API.  For most other uses, the\nstack-allocated form will be more convenient.\n\nConsider the following two examples that do the same thing in each\nstyle: take an existing dictionary and look up the \"count\" uint32\nkey, adding 1 to it if it is found, or returning an error if the\nkey is not found.  Each returns the new dictionary as a floating\n#GVariant.\n\n## Using a stack-allocated GVariantDict\n\n|[&lt;!-- language=\"C\" --&gt;\n  GVariant *\n  add_to_count (GVariant  *orig,\n                GError   **error)\n  {\n    GVariantDict dict;\n    guint32 count;\n\n    g_variant_dict_init (&amp;dict, orig);\n    if (!g_variant_dict_lookup (&amp;dict, \"count\", \"u\", &amp;count))\n      {\n        g_set_error (...);\n        g_variant_dict_clear (&amp;dict);\n        return NULL;\n      }\n\n    g_variant_dict_insert (&amp;dict, \"count\", \"u\", count + 1);\n\n    return g_variant_dict_end (&amp;dict);\n  }\n]|\n\n## Using heap-allocated GVariantDict\n\n|[&lt;!-- language=\"C\" --&gt;\n  GVariant *\n  add_to_count (GVariant  *orig,\n                GError   **error)\n  {\n    GVariantDict *dict;\n    GVariant *result;\n    guint32 count;\n\n    dict = g_variant_dict_new (orig);\n\n    if (g_variant_dict_lookup (dict, \"count\", \"u\", &amp;count))\n      {\n        g_variant_dict_insert (dict, \"count\", \"u\", count + 1);\n        result = g_variant_dict_end (dict);\n      }\n    else\n      {\n        g_set_error (...);\n        result = NULL;\n      }\n\n    g_variant_dict_unref (dict);\n\n    return result;\n  }\n]|</doc>\n  <constructor name=\"new\" c:identifier=\"g_variant_dict_new\" version=\"2.40\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Allocates and initialises a new #GVariantDict.\n\nYou should call g_variant_dict_unref() on the return value when it\nis no longer needed.  The memory will not be automatically freed by\nany other call.\n\nIn some cases it may be easier to place a #GVariantDict directly on\nthe stack of the calling function and initialise it with\ng_variant_dict_init().  This is particularly useful when you are\nusing #GVariantDict to construct a #GVariant.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GVariantDict</doc>\n      <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"from_asv\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"fromAsv\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariant with which to initialise the\n  dictionary</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"from_asv\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"fromAsv\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the #GVariant with which to initialise the\n  dictionary</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <method name=\"clear\" c:identifier=\"g_variant_dict_clear\" version=\"2.40\" gs:managed-name=\"Clear\">\n    <doc xml:space=\"preserve\">Releases all memory associated with a #GVariantDict without freeing\nthe #GVariantDict structure itself.\n\nIt typically only makes sense to do this on a stack-allocated\n#GVariantDict if you want to abort building the value part-way\nthrough.  This function need not be called if you call\ng_variant_dict_end() and it also doesn't need to be called on dicts\nallocated with g_variant_dict_new (see g_variant_dict_unref() for\nthat).\n\nIt is valid to call this function on either an initialised\n#GVariantDict or one that was previously cleared by an earlier call\nto g_variant_dict_clear() but it is not valid to call this function\non uninitialised memory.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"contains\" c:identifier=\"g_variant_dict_contains\" version=\"2.40\" gs:managed-name=\"Contains\">\n    <doc xml:space=\"preserve\">Checks if @key exists in @dict.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @key is in @dict</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to lookup in the dictionary</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to lookup in the dictionary</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"end\" c:identifier=\"g_variant_dict_end\" version=\"2.40\" gs:managed-name=\"End\">\n    <doc xml:space=\"preserve\">Returns the current value of @dict as a #GVariant of type\n%G_VARIANT_TYPE_VARDICT, clearing it in the process.\n\nIt is not permissible to use @dict in any way after this call except\nfor reference counting operations (in the case of a heap-allocated\n#GVariantDict) or by reinitialising it with g_variant_dict_init() (in\nthe case of stack-allocated).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new, floating, #GVariant</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"init\" c:identifier=\"g_variant_dict_init\" version=\"2.40\" introspectable=\"0\" gs:managed-name=\"Init\">\n    <doc xml:space=\"preserve\">Initialises a #GVariantDict structure.\n\nIf @from_asv is given, it is used to initialise the dictionary.\n\nThis function completely ignores the previous contents of @dict.  On\none hand this means that it is valid to pass in completely\nuninitialised memory.  On the other hand, this means that if you are\ninitialising over top of an existing #GVariantDict you need to first\ncall g_variant_dict_clear() in order to avoid leaking memory.\n\nYou must not call g_variant_dict_ref() or g_variant_dict_unref() on a\n#GVariantDict that was initialised with this function.  If you ever\npass a reference to a #GVariantDict outside of the control of your\nown code then you should assume that the person receiving that\nreference may try to use reference counting; you should use\ng_variant_dict_new() instead of this function.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n      <parameter name=\"from_asv\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"fromAsv\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the initial value for @dict</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"from_asv\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"fromAsv\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the initial value for @dict</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"insert_value\" c:identifier=\"g_variant_dict_insert_value\" version=\"2.40\" gs:managed-name=\"InsertValue\">\n    <doc xml:space=\"preserve\">Inserts (or replaces) a key in a #GVariantDict.\n\n@value is consumed if it is floating.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to insert a value for</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value to insert</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to insert a value for</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the value to insert</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"lookup_value\" c:identifier=\"g_variant_dict_lookup_value\" version=\"2.40\" gs:managed-name=\"LookupValue\">\n    <doc xml:space=\"preserve\">Looks up a value in a #GVariantDict.\n\nIf @key is not found in @dictionary, %NULL is returned.\n\nThe @expected_type string specifies what type of value is expected.\nIf the value associated with @key has a different type then %NULL is\nreturned.\n\nIf the key is found and the value has the correct type, it is\nreturned.  If @expected_type was specified then any non-%NULL return\nvalue will have this type.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value of the dictionary key, or %NULL</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to lookup in the dictionary</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"expected_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"expectedType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to lookup in the dictionary</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"expected_type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"expectedType\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"ref\" c:identifier=\"g_variant_dict_ref\" version=\"2.40\" gs:managed-name=\"Ref\" gs:special-func=\"ref\">\n    <doc xml:space=\"preserve\">Increases the reference count on @dict.\n\nDon't call this on stack-allocated #GVariantDict instances or bad\nthings will happen.</doc>\n    <return-value transfer-ownership=\"full\" skip=\"1\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new reference to @dict</doc>\n      <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a heap-allocated #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"remove\" c:identifier=\"g_variant_dict_remove\" version=\"2.40\" gs:managed-name=\"Remove\">\n    <doc xml:space=\"preserve\">Removes a key and its associated value from a #GVariantDict.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if the key was found and removed</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"none\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to remove</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the key to remove</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"unref\" c:identifier=\"g_variant_dict_unref\" version=\"2.40\" gs:managed-name=\"Unref\" gs:special-func=\"unref\">\n    <doc xml:space=\"preserve\">Decreases the reference count on @dict.\n\nIn the event that there are no more references, releases all memory\nassociated with the #GVariantDict.\n\nDon't call this on stack-allocated #GVariantDict instances or bad\nthings will happen.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"dict\" transfer-ownership=\"full\" gs:managed-name=\"dict\" gs:managed-type=\"VariantDict\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a heap-allocated #GVariantDict</doc>\n        <type name=\"VariantDict\" c:type=\"GVariantDict*\" gs:managed-name=\"VariantDict\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    [GISharp.Core.Since("2.40")]
    public partial class VariantDict : GISharp.Core.ReferenceCountedOpaque<GISharp.GLib.VariantDict>
    {
        public VariantDict(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Allocates and initialises a new #GVariantDict.
        /// </summary>
        /// <remarks>
        /// You should call g_variant_dict_unref() on the return value when it
        /// is no longer needed.  The memory will not be automatically freed by
        /// any other call.
        /// 
        /// In some cases it may be easier to place a #GVariantDict directly on
        /// the stack of the calling function and initialise it with
        /// g_variant_dict_init().  This is particularly useful when you are
        /// using #GVariantDict to construct a #GVariant.
        /// </remarks>
        /// <param name="fromAsv">
        /// the #GVariant with which to initialise the
        ///   dictionary
        /// </param>
        /// <returns>
        /// a #GVariantDict
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public VariantDict(
            GISharp.GLib.Variant fromAsv) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Allocates and initialises a new #GVariantDict.
        /// </summary>
        /// <remarks>
        /// You should call g_variant_dict_unref() on the return value when it
        /// is no longer needed.  The memory will not be automatically freed by
        /// any other call.
        /// 
        /// In some cases it may be easier to place a #GVariantDict directly on
        /// the stack of the calling function and initialise it with
        /// g_variant_dict_init().  This is particularly useful when you are
        /// using #GVariantDict to construct a #GVariant.
        /// </remarks>
        /// <param name="fromAsv">
        /// the #GVariant with which to initialise the
        ///   dictionary
        /// </param>
        /// <returns>
        /// a #GVariantDict
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.IntPtr g_variant_dict_new(
            [System.Runtime.InteropServices.In()] System.IntPtr fromAsv);

        /// <summary>
        /// Releases all memory associated with a #GVariantDict without freeing
        /// the #GVariantDict structure itself.
        /// </summary>
        /// <remarks>
        /// It typically only makes sense to do this on a stack-allocated
        /// #GVariantDict if you want to abort building the value part-way
        /// through.  This function need not be called if you call
        /// g_variant_dict_end() and it also doesn't need to be called on dicts
        /// allocated with g_variant_dict_new (see g_variant_dict_unref() for
        /// that).
        /// 
        /// It is valid to call this function on either an initialised
        /// #GVariantDict or one that was previously cleared by an earlier call
        /// to g_variant_dict_clear() but it is not valid to call this function
        /// on uninitialised memory.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern void g_variant_dict_clear(
            [System.Runtime.InteropServices.In()] System.IntPtr dict);

        /// <summary>
        /// Releases all memory associated with a #GVariantDict without freeing
        /// the #GVariantDict structure itself.
        /// </summary>
        /// <remarks>
        /// It typically only makes sense to do this on a stack-allocated
        /// #GVariantDict if you want to abort building the value part-way
        /// through.  This function need not be called if you call
        /// g_variant_dict_end() and it also doesn't need to be called on dicts
        /// allocated with g_variant_dict_new (see g_variant_dict_unref() for
        /// that).
        /// 
        /// It is valid to call this function on either an initialised
        /// #GVariantDict or one that was previously cleared by an earlier call
        /// to g_variant_dict_clear() but it is not valid to call this function
        /// on uninitialised memory.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        [GISharp.Core.Since("2.40")]
        public void Clear()
        {
        }

        /// <summary>
        /// Checks if @key exists in @dict.
        /// </summary>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to lookup in the dictionary
        /// </param>
        /// <returns>
        /// %TRUE if @key is in @dict
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.Boolean g_variant_dict_contains(
            [System.Runtime.InteropServices.In()] System.IntPtr dict,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Checks if @key exists in @dict.
        /// </summary>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to lookup in the dictionary
        /// </param>
        /// <returns>
        /// %TRUE if @key is in @dict
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public System.Boolean Contains(
            System.String key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Returns the current value of @dict as a #GVariant of type
        /// %G_VARIANT_TYPE_VARDICT, clearing it in the process.
        /// </summary>
        /// <remarks>
        /// It is not permissible to use @dict in any way after this call except
        /// for reference counting operations (in the case of a heap-allocated
        /// #GVariantDict) or by reinitialising it with g_variant_dict_init() (in
        /// the case of stack-allocated).
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <returns>
        /// a new, floating, #GVariant
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.IntPtr g_variant_dict_end(
            [System.Runtime.InteropServices.In()] System.IntPtr dict);

        /// <summary>
        /// Returns the current value of @dict as a #GVariant of type
        /// %G_VARIANT_TYPE_VARDICT, clearing it in the process.
        /// </summary>
        /// <remarks>
        /// It is not permissible to use @dict in any way after this call except
        /// for reference counting operations (in the case of a heap-allocated
        /// #GVariantDict) or by reinitialising it with g_variant_dict_init() (in
        /// the case of stack-allocated).
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <returns>
        /// a new, floating, #GVariant
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public GISharp.GLib.Variant End()
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Initialises a #GVariantDict structure.
        /// </summary>
        /// <remarks>
        /// If @from_asv is given, it is used to initialise the dictionary.
        /// 
        /// This function completely ignores the previous contents of @dict.  On
        /// one hand this means that it is valid to pass in completely
        /// uninitialised memory.  On the other hand, this means that if you are
        /// initialising over top of an existing #GVariantDict you need to first
        /// call g_variant_dict_clear() in order to avoid leaking memory.
        /// 
        /// You must not call g_variant_dict_ref() or g_variant_dict_unref() on a
        /// #GVariantDict that was initialised with this function.  If you ever
        /// pass a reference to a #GVariantDict outside of the control of your
        /// own code then you should assume that the person receiving that
        /// reference may try to use reference counting; you should use
        /// g_variant_dict_new() instead of this function.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="fromAsv">
        /// the initial value for @dict
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern void g_variant_dict_init(
            [System.Runtime.InteropServices.In()] System.IntPtr dict,
            [System.Runtime.InteropServices.In()] System.IntPtr fromAsv);

        /// <summary>
        /// Initialises a #GVariantDict structure.
        /// </summary>
        /// <remarks>
        /// If @from_asv is given, it is used to initialise the dictionary.
        /// 
        /// This function completely ignores the previous contents of @dict.  On
        /// one hand this means that it is valid to pass in completely
        /// uninitialised memory.  On the other hand, this means that if you are
        /// initialising over top of an existing #GVariantDict you need to first
        /// call g_variant_dict_clear() in order to avoid leaking memory.
        /// 
        /// You must not call g_variant_dict_ref() or g_variant_dict_unref() on a
        /// #GVariantDict that was initialised with this function.  If you ever
        /// pass a reference to a #GVariantDict outside of the control of your
        /// own code then you should assume that the person receiving that
        /// reference may try to use reference counting; you should use
        /// g_variant_dict_new() instead of this function.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="fromAsv">
        /// the initial value for @dict
        /// </param>
        [GISharp.Core.Since("2.40")]
        public void Init(
            GISharp.GLib.Variant fromAsv)
        {
        }

        /// <summary>
        /// Inserts (or replaces) a key in a #GVariantDict.
        /// </summary>
        /// <remarks>
        /// @value is consumed if it is floating.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to insert a value for
        /// </param>
        /// <param name="value">
        /// the value to insert
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern void g_variant_dict_insert_value(
            [System.Runtime.InteropServices.In()] System.IntPtr dict,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Inserts (or replaces) a key in a #GVariantDict.
        /// </summary>
        /// <remarks>
        /// @value is consumed if it is floating.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to insert a value for
        /// </param>
        /// <param name="value">
        /// the value to insert
        /// </param>
        [GISharp.Core.Since("2.40")]
        public void InsertValue(
            System.String key,
            GISharp.GLib.Variant value)
        {
        }

        /// <summary>
        /// Looks up a value in a #GVariantDict.
        /// </summary>
        /// <remarks>
        /// If @key is not found in @dictionary, %NULL is returned.
        /// 
        /// The @expected_type string specifies what type of value is expected.
        /// If the value associated with @key has a different type then %NULL is
        /// returned.
        /// 
        /// If the key is found and the value has the correct type, it is
        /// returned.  If @expected_type was specified then any non-%NULL return
        /// value will have this type.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to lookup in the dictionary
        /// </param>
        /// <param name="expectedType">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <returns>
        /// the value of the dictionary key, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.IntPtr g_variant_dict_lookup_value(
            [System.Runtime.InteropServices.In()] System.IntPtr dict,
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr expectedType);

        /// <summary>
        /// Looks up a value in a #GVariantDict.
        /// </summary>
        /// <remarks>
        /// If @key is not found in @dictionary, %NULL is returned.
        /// 
        /// The @expected_type string specifies what type of value is expected.
        /// If the value associated with @key has a different type then %NULL is
        /// returned.
        /// 
        /// If the key is found and the value has the correct type, it is
        /// returned.  If @expected_type was specified then any non-%NULL return
        /// value will have this type.
        /// </remarks>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to lookup in the dictionary
        /// </param>
        /// <param name="expectedType">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <returns>
        /// the value of the dictionary key, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public GISharp.GLib.Variant LookupValue(
            System.String key,
            GISharp.GLib.VariantType expectedType)
        {
            return default(GISharp.GLib.Variant);
        }

        /// <summary>
        /// Increases the reference count on @dict.
        /// </summary>
        /// <remarks>
        /// Don't call this on stack-allocated #GVariantDict instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="dict">
        /// a heap-allocated #GVariantDict
        /// </param>
        /// <returns>
        /// a new reference to @dict
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.IntPtr g_variant_dict_ref(
            [System.Runtime.InteropServices.In()] System.IntPtr dict);

        /// <summary>
        /// Increases the reference count on @dict.
        /// </summary>
        /// <remarks>
        /// Don't call this on stack-allocated #GVariantDict instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="dict">
        /// a heap-allocated #GVariantDict
        /// </param>
        /// <returns>
        /// a new reference to @dict
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public override void Ref()
        {
        }

        /// <summary>
        /// Removes a key and its associated value from a #GVariantDict.
        /// </summary>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was found and removed
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern System.Boolean g_variant_dict_remove(
            [System.Runtime.InteropServices.In()] System.IntPtr dict,
            [System.Runtime.InteropServices.In()] System.IntPtr key);

        /// <summary>
        /// Removes a key and its associated value from a #GVariantDict.
        /// </summary>
        /// <param name="dict">
        /// a #GVariantDict
        /// </param>
        /// <param name="key">
        /// the key to remove
        /// </param>
        /// <returns>
        /// %TRUE if the key was found and removed
        /// </returns>
        [GISharp.Core.Since("2.40")]
        public System.Boolean Remove(
            System.String key)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Decreases the reference count on @dict.
        /// </summary>
        /// <remarks>
        /// In the event that there are no more references, releases all memory
        /// associated with the #GVariantDict.
        /// 
        /// Don't call this on stack-allocated #GVariantDict instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="dict">
        /// a heap-allocated #GVariantDict
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.40")]
        static extern void g_variant_dict_unref(
            [System.Runtime.InteropServices.In()] System.IntPtr dict);

        /// <summary>
        /// Decreases the reference count on @dict.
        /// </summary>
        /// <remarks>
        /// In the event that there are no more references, releases all memory
        /// associated with the #GVariantDict.
        /// 
        /// Don't call this on stack-allocated #GVariantDict instances or bad
        /// things will happen.
        /// </remarks>
        /// <param name="dict">
        /// a heap-allocated #GVariantDict
        /// </param>
        [GISharp.Core.Since("2.40")]
        public override void Unref()
        {
        }
    }

    /// <summary>
    /// #GVariantIter is an opaque data structure and can only be accessed
    /// using the following functions.
    /// </summary>
    [GISharp.Core.GirXml("<record name=\"VariantIter\" c:type=\"GVariantIter\" introspectable=\"0\" gs:managed-name=\"VariantIter\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">#GVariantIter is an opaque data structure and can only be accessed\nusing the following functions.</doc>\n  <method name=\"copy\" c:identifier=\"g_variant_iter_copy\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"Copy\" gs:special-func=\"copy\">\n    <doc xml:space=\"preserve\">Creates a new heap-allocated #GVariantIter to iterate over the\ncontainer that was being iterated over by @iter.  Iteration begins on\nthe new iterator from the current position of the old iterator but\nthe two copies are independent past that point.\n\nUse g_variant_iter_free() to free the return value when you no longer\nneed it.\n\nA reference is taken to the container that @iter is iterating over\nand will be releated only when g_variant_iter_free() is called.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new heap-allocated #GVariantIter</doc>\n      <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantIter</doc>\n        <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free\" c:identifier=\"g_variant_iter_free\" version=\"2.24\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees a heap-allocated #GVariantIter.  Only call this function on\niterators that were returned by g_variant_iter_new() or\ng_variant_iter_copy().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"full\" gs:managed-name=\"iter\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a heap-allocated #GVariantIter</doc>\n        <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"init\" c:identifier=\"g_variant_iter_init\" version=\"2.24\" introspectable=\"0\" gs:managed-name=\"Init\">\n    <doc xml:space=\"preserve\">Initialises (without allocating) a #GVariantIter.  @iter may be\ncompletely uninitialised prior to this call; its old value is\nignored.\n\nThe iterator remains valid for as long as @value exists, and need not\nbe freed in any way.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the number of items in @value</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to a #GVariantIter</doc>\n        <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n      </instance-parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a container #GVariant</doc>\n        <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"n_children\" c:identifier=\"g_variant_iter_n_children\" version=\"2.24\" gs:managed-name=\"NChildren\">\n    <doc xml:space=\"preserve\">Queries the number of child items in the container that we are\niterating over.  This is the total number of items -- not the number\nof items remaining.\n\nThis function might be useful for preallocation of arrays.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the number of children in the container</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantIter</doc>\n        <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"next_value\" c:identifier=\"g_variant_iter_next_value\" version=\"2.24\" gs:managed-name=\"NextValue\">\n    <doc xml:space=\"preserve\">Gets the next item in the container.  If no more items remain then\n%NULL is returned.\n\nUse g_variant_unref() to drop your reference on the return value when\nyou no longer need it.\n\nHere is an example for iterating with g_variant_iter_next_value():\n|[&lt;!-- language=\"C\" --&gt;\n  // recursively iterate a container\n  void\n  iterate_container_recursive (GVariant *container)\n  {\n    GVariantIter iter;\n    GVariant *child;\n\n    g_variant_iter_init (&amp;iter, container);\n    while ((child = g_variant_iter_next_value (&amp;iter)))\n      {\n        g_print (\"type '%s'\\n\", g_variant_get_type_string (child));\n\n        if (g_variant_is_container (child))\n          iterate_container_recursive (child);\n\n        g_variant_unref (child);\n      }\n  }\n]|</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Variant\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a #GVariant, or %NULL</doc>\n      <type name=\"Variant\" c:type=\"GVariant*\" gs:managed-name=\"Variant\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"iter\" transfer-ownership=\"none\" gs:managed-name=\"iter\" gs:managed-type=\"VariantIter\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantIter</doc>\n        <type name=\"VariantIter\" c:type=\"GVariantIter*\" gs:managed-name=\"VariantIter\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n</record>")]
    public partial class VariantIter : GISharp.Core.OwnedOpaque<GISharp.GLib.VariantIter>
    {
        public VariantIter(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new heap-allocated #GVariantIter to iterate over the
        /// container that was being iterated over by @iter.  Iteration begins on
        /// the new iterator from the current position of the old iterator but
        /// the two copies are independent past that point.
        /// </summary>
        /// <remarks>
        /// Use g_variant_iter_free() to free the return value when you no longer
        /// need it.
        /// 
        /// A reference is taken to the container that @iter is iterating over
        /// and will be releated only when g_variant_iter_free() is called.
        /// </remarks>
        /// <param name="iter">
        /// a #GVariantIter
        /// </param>
        /// <returns>
        /// a new heap-allocated #GVariantIter
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_iter_copy(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Creates a new heap-allocated #GVariantIter to iterate over the
        /// container that was being iterated over by @iter.  Iteration begins on
        /// the new iterator from the current position of the old iterator but
        /// the two copies are independent past that point.
        /// </summary>
        /// <remarks>
        /// Use g_variant_iter_free() to free the return value when you no longer
        /// need it.
        /// 
        /// A reference is taken to the container that @iter is iterating over
        /// and will be releated only when g_variant_iter_free() is called.
        /// </remarks>
        /// <param name="iter">
        /// a #GVariantIter
        /// </param>
        /// <returns>
        /// a new heap-allocated #GVariantIter
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public override GISharp.GLib.VariantIter Copy()
        {
            return default(GISharp.GLib.VariantIter);
        }

        /// <summary>
        /// Frees a heap-allocated #GVariantIter.  Only call this function on
        /// iterators that were returned by g_variant_iter_new() or
        /// g_variant_iter_copy().
        /// </summary>
        /// <param name="iter">
        /// a heap-allocated #GVariantIter
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern void g_variant_iter_free(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Frees a heap-allocated #GVariantIter.  Only call this function on
        /// iterators that were returned by g_variant_iter_new() or
        /// g_variant_iter_copy().
        /// </summary>
        /// <param name="iter">
        /// a heap-allocated #GVariantIter
        /// </param>
        [GISharp.Core.Since("2.24")]
        protected override void Free()
        {
        }

        /// <summary>
        /// Initialises (without allocating) a #GVariantIter.  @iter may be
        /// completely uninitialised prior to this call; its old value is
        /// ignored.
        /// </summary>
        /// <remarks>
        /// The iterator remains valid for as long as @value exists, and need not
        /// be freed in any way.
        /// </remarks>
        /// <param name="iter">
        /// a pointer to a #GVariantIter
        /// </param>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// the number of items in @value
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt64 g_variant_iter_init(
            [System.Runtime.InteropServices.In()] System.IntPtr iter,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Initialises (without allocating) a #GVariantIter.  @iter may be
        /// completely uninitialised prior to this call; its old value is
        /// ignored.
        /// </summary>
        /// <remarks>
        /// The iterator remains valid for as long as @value exists, and need not
        /// be freed in any way.
        /// </remarks>
        /// <param name="iter">
        /// a pointer to a #GVariantIter
        /// </param>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// the number of items in @value
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt64 Init(
            GISharp.GLib.Variant value)
        {
            return default(System.UInt64);
        }

        /// <summary>
        /// Queries the number of child items in the container that we are
        /// iterating over.  This is the total number of items -- not the number
        /// of items remaining.
        /// </summary>
        /// <remarks>
        /// This function might be useful for preallocation of arrays.
        /// </remarks>
        /// <param name="iter">
        /// a #GVariantIter
        /// </param>
        /// <returns>
        /// the number of children in the container
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.UInt64 g_variant_iter_n_children(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Queries the number of child items in the container that we are
        /// iterating over.  This is the total number of items -- not the number
        /// of items remaining.
        /// </summary>
        /// <remarks>
        /// This function might be useful for preallocation of arrays.
        /// </remarks>
        /// <param name="iter">
        /// a #GVariantIter
        /// </param>
        /// <returns>
        /// the number of children in the container
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public System.UInt64 NChildren()
        {
            return default(System.UInt64);
        }

        /// <summary>
        /// Gets the next item in the container.  If no more items remain then
        /// %NULL is returned.
        /// </summary>
        /// <remarks>
        /// Use g_variant_unref() to drop your reference on the return value when
        /// you no longer need it.
        /// 
        /// Here is an example for iterating with g_variant_iter_next_value():
        /// |[&lt;!-- language="C" --&gt;
        ///   // recursively iterate a container
        ///   void
        ///   iterate_container_recursive (GVariant *container)
        ///   {
        ///     GVariantIter iter;
        ///     GVariant *child;
        /// 
        ///     g_variant_iter_init (&amp;iter, container);
        ///     while ((child = g_variant_iter_next_value (&amp;iter)))
        ///       {
        ///         g_print ("type '%s'\n", g_variant_get_type_string (child));
        /// 
        ///         if (g_variant_is_container (child))
        ///           iterate_container_recursive (child);
        /// 
        ///         g_variant_unref (child);
        ///       }
        ///   }
        /// ]|
        /// </remarks>
        /// <param name="iter">
        /// a #GVariantIter
        /// </param>
        /// <returns>
        /// a #GVariant, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_iter_next_value(
            [System.Runtime.InteropServices.In()] System.IntPtr iter);

        /// <summary>
        /// Gets the next item in the container.  If no more items remain then
        /// %NULL is returned.
        /// </summary>
        /// <remarks>
        /// Use g_variant_unref() to drop your reference on the return value when
        /// you no longer need it.
        /// 
        /// Here is an example for iterating with g_variant_iter_next_value():
        /// |[&lt;!-- language="C" --&gt;
        ///   // recursively iterate a container
        ///   void
        ///   iterate_container_recursive (GVariant *container)
        ///   {
        ///     GVariantIter iter;
        ///     GVariant *child;
        /// 
        ///     g_variant_iter_init (&amp;iter, container);
        ///     while ((child = g_variant_iter_next_value (&amp;iter)))
        ///       {
        ///         g_print ("type '%s'\n", g_variant_get_type_string (child));
        /// 
        ///         if (g_variant_is_container (child))
        ///           iterate_container_recursive (child);
        /// 
        ///         g_variant_unref (child);
        ///       }
        ///   }
        /// ]|
        /// </remarks>
        /// <param name="iter">
        /// a #GVariantIter
        /// </param>
        /// <returns>
        /// a #GVariant, or %NULL
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public GISharp.GLib.Variant NextValue()
        {
            return default(GISharp.GLib.Variant);
        }
    }

    /// <summary>
    /// Error codes returned by parsing text-format GVariants.
    /// </summary>
    [GISharp.Core.GirXml("<enumeration name=\"VariantParseError\" c:type=\"GVariantParseError\" glib:error-domain=\"g-variant-parse-error-quark\" gs:managed-name=\"VariantParseError\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Error codes returned by parsing text-format GVariants.</doc>\n  <member name=\"failed\" value=\"0\" c:identifier=\"G_VARIANT_PARSE_ERROR_FAILED\" gs:managed-name=\"Failed\">\n    <doc xml:space=\"preserve\">generic error (unused)</doc>\n  </member>\n  <member name=\"basic_type_expected\" value=\"1\" c:identifier=\"G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED\" gs:managed-name=\"BasicTypeExpected\">\n    <doc xml:space=\"preserve\">a non-basic #GVariantType was given where a basic type was expected</doc>\n  </member>\n  <member name=\"cannot_infer_type\" value=\"2\" c:identifier=\"G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE\" gs:managed-name=\"CannotInferType\">\n    <doc xml:space=\"preserve\">cannot infer the #GVariantType</doc>\n  </member>\n  <member name=\"definite_type_expected\" value=\"3\" c:identifier=\"G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED\" gs:managed-name=\"DefiniteTypeExpected\">\n    <doc xml:space=\"preserve\">an indefinite #GVariantType was given where a definite type was expected</doc>\n  </member>\n  <member name=\"input_not_at_end\" value=\"4\" c:identifier=\"G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END\" gs:managed-name=\"InputNotAtEnd\">\n    <doc xml:space=\"preserve\">extra data after parsing finished</doc>\n  </member>\n  <member name=\"invalid_character\" value=\"5\" c:identifier=\"G_VARIANT_PARSE_ERROR_INVALID_CHARACTER\" gs:managed-name=\"InvalidCharacter\">\n    <doc xml:space=\"preserve\">invalid character in number or unicode escape</doc>\n  </member>\n  <member name=\"invalid_format_string\" value=\"6\" c:identifier=\"G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING\" gs:managed-name=\"InvalidFormatString\">\n    <doc xml:space=\"preserve\">not a valid #GVariant format string</doc>\n  </member>\n  <member name=\"invalid_object_path\" value=\"7\" c:identifier=\"G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH\" gs:managed-name=\"InvalidObjectPath\">\n    <doc xml:space=\"preserve\">not a valid object path</doc>\n  </member>\n  <member name=\"invalid_signature\" value=\"8\" c:identifier=\"G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE\" gs:managed-name=\"InvalidSignature\">\n    <doc xml:space=\"preserve\">not a valid type signature</doc>\n  </member>\n  <member name=\"invalid_type_string\" value=\"9\" c:identifier=\"G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING\" gs:managed-name=\"InvalidTypeString\">\n    <doc xml:space=\"preserve\">not a valid #GVariant type string</doc>\n  </member>\n  <member name=\"no_common_type\" value=\"10\" c:identifier=\"G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE\" gs:managed-name=\"NoCommonType\">\n    <doc xml:space=\"preserve\">could not find a common type for array entries</doc>\n  </member>\n  <member name=\"number_out_of_range\" value=\"11\" c:identifier=\"G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE\" gs:managed-name=\"NumberOutOfRange\">\n    <doc xml:space=\"preserve\">the numerical value is out of range of the given type</doc>\n  </member>\n  <member name=\"number_too_big\" value=\"12\" c:identifier=\"G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG\" gs:managed-name=\"NumberTooBig\">\n    <doc xml:space=\"preserve\">the numerical value is out of range for any type</doc>\n  </member>\n  <member name=\"type_error\" value=\"13\" c:identifier=\"G_VARIANT_PARSE_ERROR_TYPE_ERROR\" gs:managed-name=\"TypeError\">\n    <doc xml:space=\"preserve\">cannot parse as variant of the specified type</doc>\n  </member>\n  <member name=\"unexpected_token\" value=\"14\" c:identifier=\"G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN\" gs:managed-name=\"UnexpectedToken\">\n    <doc xml:space=\"preserve\">an unexpected token was encountered</doc>\n  </member>\n  <member name=\"unknown_keyword\" value=\"15\" c:identifier=\"G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD\" gs:managed-name=\"UnknownKeyword\">\n    <doc xml:space=\"preserve\">an unknown keyword was encountered</doc>\n  </member>\n  <member name=\"unterminated_string_constant\" value=\"16\" c:identifier=\"G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT\" gs:managed-name=\"UnterminatedStringConstant\">\n    <doc xml:space=\"preserve\">unterminated string constant</doc>\n  </member>\n  <member name=\"value_expected\" value=\"17\" c:identifier=\"G_VARIANT_PARSE_ERROR_VALUE_EXPECTED\" gs:managed-name=\"ValueExpected\">\n    <doc xml:space=\"preserve\">no value given</doc>\n  </member>\n</enumeration>")]
    [GISharp.Core.ErrorDomain("g-variant-parse-error-quark")]
    public enum VariantParseError
    {
        /// <summary>
        /// generic error (unused)
        /// </summary>
        Failed = 0,
        /// <summary>
        /// a non-basic #GVariantType was given where a basic type was expected
        /// </summary>
        BasicTypeExpected = 1,
        /// <summary>
        /// cannot infer the #GVariantType
        /// </summary>
        CannotInferType = 2,
        /// <summary>
        /// an indefinite #GVariantType was given where a definite type was expected
        /// </summary>
        DefiniteTypeExpected = 3,
        /// <summary>
        /// extra data after parsing finished
        /// </summary>
        InputNotAtEnd = 4,
        /// <summary>
        /// invalid character in number or unicode escape
        /// </summary>
        InvalidCharacter = 5,
        /// <summary>
        /// not a valid #GVariant format string
        /// </summary>
        InvalidFormatString = 6,
        /// <summary>
        /// not a valid object path
        /// </summary>
        InvalidObjectPath = 7,
        /// <summary>
        /// not a valid type signature
        /// </summary>
        InvalidSignature = 8,
        /// <summary>
        /// not a valid #GVariant type string
        /// </summary>
        InvalidTypeString = 9,
        /// <summary>
        /// could not find a common type for array entries
        /// </summary>
        NoCommonType = 10,
        /// <summary>
        /// the numerical value is out of range of the given type
        /// </summary>
        NumberOutOfRange = 11,
        /// <summary>
        /// the numerical value is out of range for any type
        /// </summary>
        NumberTooBig = 12,
        /// <summary>
        /// cannot parse as variant of the specified type
        /// </summary>
        TypeError = 13,
        /// <summary>
        /// an unexpected token was encountered
        /// </summary>
        UnexpectedToken = 14,
        /// <summary>
        /// an unknown keyword was encountered
        /// </summary>
        UnknownKeyword = 15,
        /// <summary>
        /// unterminated string constant
        /// </summary>
        UnterminatedStringConstant = 16,
        /// <summary>
        /// no value given
        /// </summary>
        ValueExpected = 17
    }

    /// <summary>
    /// This section introduces the GVariant type system. It is based, in
    /// large part, on the D-Bus type system, with two major changes and
    /// some minor lifting of restrictions. The
    /// [D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html),
    /// therefore, provides a significant amount of
    /// information that is useful when working with GVariant.
    /// </summary>
    /// <remarks>
    /// The first major change with respect to the D-Bus type system is the
    /// introduction of maybe (or "nullable") types.  Any type in GVariant can be
    /// converted to a maybe type, in which case, "nothing" (or "null") becomes a
    /// valid value.  Maybe types have been added by introducing the
    /// character "m" to type strings.
    /// 
    /// The second major change is that the GVariant type system supports the
    /// concept of "indefinite types" -- types that are less specific than
    /// the normal types found in D-Bus.  For example, it is possible to speak
    /// of "an array of any type" in GVariant, where the D-Bus type system
    /// would require you to speak of "an array of integers" or "an array of
    /// strings".  Indefinite types have been added by introducing the
    /// characters "*", "?" and "r" to type strings.
    /// 
    /// Finally, all arbitrary restrictions relating to the complexity of
    /// types are lifted along with the restriction that dictionary entries
    /// may only appear nested inside of arrays.
    /// 
    /// Just as in D-Bus, GVariant types are described with strings ("type
    /// strings").  Subject to the differences mentioned above, these strings
    /// are of the same form as those found in DBus.  Note, however: D-Bus
    /// always works in terms of messages and therefore individual type
    /// strings appear nowhere in its interface.  Instead, "signatures"
    /// are a concatenation of the strings of the type of each argument in a
    /// message.  GVariant deals with single values directly so GVariant type
    /// strings always describe the type of exactly one value.  This means
    /// that a D-Bus signature string is generally not a valid GVariant type
    /// string -- except in the case that it is the signature of a message
    /// containing exactly one argument.
    /// 
    /// An indefinite type is similar in spirit to what may be called an
    /// abstract type in other type systems.  No value can exist that has an
    /// indefinite type as its type, but values can exist that have types
    /// that are subtypes of indefinite types.  That is to say,
    /// g_variant_get_type() will never return an indefinite type, but
    /// calling g_variant_is_of_type() with an indefinite type may return
    /// %TRUE.  For example, you cannot have a value that represents "an
    /// array of no particular type", but you can have an "array of integers"
    /// which certainly matches the type of "an array of no particular type",
    /// since "array of integers" is a subtype of "array of no particular
    /// type".
    /// 
    /// This is similar to how instances of abstract classes may not
    /// directly exist in other type systems, but instances of their
    /// non-abstract subtypes may.  For example, in GTK, no object that has
    /// the type of #GtkBin can exist (since #GtkBin is an abstract class),
    /// but a #GtkWindow can certainly be instantiated, and you would say
    /// that the #GtkWindow is a #GtkBin (since #GtkWindow is a subclass of
    /// #GtkBin).
    /// 
    /// ## GVariant Type Strings
    /// 
    /// A GVariant type string can be any of the following:
    /// 
    /// - any basic type string (listed below)
    /// 
    /// - "v", "r" or "*"
    /// 
    /// - one of the characters 'a' or 'm', followed by another type string
    /// 
    /// - the character '(', followed by a concatenation of zero or more other
    ///   type strings, followed by the character ')'
    /// 
    /// - the character '{', followed by a basic type string (see below),
    ///   followed by another type string, followed by the character '}'
    /// 
    /// A basic type string describes a basic type (as per
    /// g_variant_type_is_basic()) and is always a single character in length.
    /// The valid basic type strings are "b", "y", "n", "q", "i", "u", "x", "t",
    /// "h", "d", "s", "o", "g" and "?".
    /// 
    /// The above definition is recursive to arbitrary depth. "aaaaai" and
    /// "(ui(nq((y)))s)" are both valid type strings, as is
    /// "a(aa(ui)(qna{ya(yd)}))".
    /// 
    /// The meaning of each of the characters is as follows:
    /// - `b`: the type string of %G_VARIANT_TYPE_BOOLEAN; a boolean value.
    /// - `y`: the type string of %G_VARIANT_TYPE_BYTE; a byte.
    /// - `n`: the type string of %G_VARIANT_TYPE_INT16; a signed 16 bit integer.
    /// - `q`: the type string of %G_VARIANT_TYPE_UINT16; an unsigned 16 bit integer.
    /// - `i`: the type string of %G_VARIANT_TYPE_INT32; a signed 32 bit integer.
    /// - `u`: the type string of %G_VARIANT_TYPE_UINT32; an unsigned 32 bit integer.
    /// - `x`: the type string of %G_VARIANT_TYPE_INT64; a signed 64 bit integer.
    /// - `t`: the type string of %G_VARIANT_TYPE_UINT64; an unsigned 64 bit integer.
    /// - `h`: the type string of %G_VARIANT_TYPE_HANDLE; a signed 32 bit value
    ///   that, by convention, is used as an index into an array of file
    ///   descriptors that are sent alongside a D-Bus message.
    /// - `d`: the type string of %G_VARIANT_TYPE_DOUBLE; a double precision
    ///   floating point value.
    /// - `s`: the type string of %G_VARIANT_TYPE_STRING; a string.
    /// - `o`: the type string of %G_VARIANT_TYPE_OBJECT_PATH; a string in the form
    ///   of a D-Bus object path.
    /// - `g`: the type string of %G_VARIANT_TYPE_STRING; a string in the form of
    ///   a D-Bus type signature.
    /// - `?`: the type string of %G_VARIANT_TYPE_BASIC; an indefinite type that
    ///   is a supertype of any of the basic types.
    /// - `v`: the type string of %G_VARIANT_TYPE_VARIANT; a container type that
    ///   contain any other type of value.
    /// - `a`: used as a prefix on another type string to mean an array of that
    ///   type; the type string "ai", for example, is the type of an array of
    ///   signed 32-bit integers.
    /// - `m`: used as a prefix on another type string to mean a "maybe", or
    ///   "nullable", version of that type; the type string "ms", for example,
    ///   is the type of a value that maybe contains a string, or maybe contains
    ///   nothing.
    /// - `()`: used to enclose zero or more other concatenated type strings to
    ///   create a tuple type; the type string "(is)", for example, is the type of
    ///   a pair of an integer and a string.
    /// - `r`: the type string of %G_VARIANT_TYPE_TUPLE; an indefinite type that is
    ///   a supertype of any tuple type, regardless of the number of items.
    /// - `{}`: used to enclose a basic type string concatenated with another type
    ///   string to create a dictionary entry type, which usually appears inside of
    ///   an array to form a dictionary; the type string "a{sd}", for example, is
    ///   the type of a dictionary that maps strings to double precision floating
    ///   point values.
    /// 
    ///   The first type (the basic type) is the key type and the second type is
    ///   the value type. The reason that the first type is restricted to being a
    ///   basic type is so that it can easily be hashed.
    /// - `*`: the type string of %G_VARIANT_TYPE_ANY; the indefinite type that is
    ///   a supertype of all types.  Note that, as with all type strings, this
    ///   character represents exactly one type. It cannot be used inside of tuples
    ///   to mean "any number of items".
    /// 
    /// Any type string of a container that contains an indefinite type is,
    /// itself, an indefinite type. For example, the type string "a*"
    /// (corresponding to %G_VARIANT_TYPE_ARRAY) is an indefinite type
    /// that is a supertype of every array type. "(*s)" is a supertype
    /// of all tuples that contain exactly two items where the second
    /// item is a string.
    /// 
    /// "a{?*}" is an indefinite type that is a supertype of all arrays
    /// containing dictionary entries where the key is any basic type and
    /// the value is any type at all.  This is, by definition, a dictionary,
    /// so this type string corresponds to %G_VARIANT_TYPE_DICTIONARY. Note
    /// that, due to the restriction that the key of a dictionary entry must
    /// be a basic type, "{**}" is not a valid type string.
    /// </remarks>
    [GISharp.Core.GirXml("<record name=\"VariantType\" c:type=\"GVariantType\" glib:type-name=\"GVariantType\" glib:get-type=\"g_variant_type_get_gtype\" c:symbol-prefix=\"variant_type\" gs:managed-name=\"VariantType\" gs:opaque=\"owned\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:glib=\"http://www.gtk.org/introspection/glib/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">This section introduces the GVariant type system. It is based, in\nlarge part, on the D-Bus type system, with two major changes and\nsome minor lifting of restrictions. The\n[D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html),\ntherefore, provides a significant amount of\ninformation that is useful when working with GVariant.\n\nThe first major change with respect to the D-Bus type system is the\nintroduction of maybe (or \"nullable\") types.  Any type in GVariant can be\nconverted to a maybe type, in which case, \"nothing\" (or \"null\") becomes a\nvalid value.  Maybe types have been added by introducing the\ncharacter \"m\" to type strings.\n\nThe second major change is that the GVariant type system supports the\nconcept of \"indefinite types\" -- types that are less specific than\nthe normal types found in D-Bus.  For example, it is possible to speak\nof \"an array of any type\" in GVariant, where the D-Bus type system\nwould require you to speak of \"an array of integers\" or \"an array of\nstrings\".  Indefinite types have been added by introducing the\ncharacters \"*\", \"?\" and \"r\" to type strings.\n\nFinally, all arbitrary restrictions relating to the complexity of\ntypes are lifted along with the restriction that dictionary entries\nmay only appear nested inside of arrays.\n\nJust as in D-Bus, GVariant types are described with strings (\"type\nstrings\").  Subject to the differences mentioned above, these strings\nare of the same form as those found in DBus.  Note, however: D-Bus\nalways works in terms of messages and therefore individual type\nstrings appear nowhere in its interface.  Instead, \"signatures\"\nare a concatenation of the strings of the type of each argument in a\nmessage.  GVariant deals with single values directly so GVariant type\nstrings always describe the type of exactly one value.  This means\nthat a D-Bus signature string is generally not a valid GVariant type\nstring -- except in the case that it is the signature of a message\ncontaining exactly one argument.\n\nAn indefinite type is similar in spirit to what may be called an\nabstract type in other type systems.  No value can exist that has an\nindefinite type as its type, but values can exist that have types\nthat are subtypes of indefinite types.  That is to say,\ng_variant_get_type() will never return an indefinite type, but\ncalling g_variant_is_of_type() with an indefinite type may return\n%TRUE.  For example, you cannot have a value that represents \"an\narray of no particular type\", but you can have an \"array of integers\"\nwhich certainly matches the type of \"an array of no particular type\",\nsince \"array of integers\" is a subtype of \"array of no particular\ntype\".\n\nThis is similar to how instances of abstract classes may not\ndirectly exist in other type systems, but instances of their\nnon-abstract subtypes may.  For example, in GTK, no object that has\nthe type of #GtkBin can exist (since #GtkBin is an abstract class),\nbut a #GtkWindow can certainly be instantiated, and you would say\nthat the #GtkWindow is a #GtkBin (since #GtkWindow is a subclass of\n#GtkBin).\n\n## GVariant Type Strings\n\nA GVariant type string can be any of the following:\n\n- any basic type string (listed below)\n\n- \"v\", \"r\" or \"*\"\n\n- one of the characters 'a' or 'm', followed by another type string\n\n- the character '(', followed by a concatenation of zero or more other\n  type strings, followed by the character ')'\n\n- the character '{', followed by a basic type string (see below),\n  followed by another type string, followed by the character '}'\n\nA basic type string describes a basic type (as per\ng_variant_type_is_basic()) and is always a single character in length.\nThe valid basic type strings are \"b\", \"y\", \"n\", \"q\", \"i\", \"u\", \"x\", \"t\",\n\"h\", \"d\", \"s\", \"o\", \"g\" and \"?\".\n\nThe above definition is recursive to arbitrary depth. \"aaaaai\" and\n\"(ui(nq((y)))s)\" are both valid type strings, as is\n\"a(aa(ui)(qna{ya(yd)}))\".\n\nThe meaning of each of the characters is as follows:\n- `b`: the type string of %G_VARIANT_TYPE_BOOLEAN; a boolean value.\n- `y`: the type string of %G_VARIANT_TYPE_BYTE; a byte.\n- `n`: the type string of %G_VARIANT_TYPE_INT16; a signed 16 bit integer.\n- `q`: the type string of %G_VARIANT_TYPE_UINT16; an unsigned 16 bit integer.\n- `i`: the type string of %G_VARIANT_TYPE_INT32; a signed 32 bit integer.\n- `u`: the type string of %G_VARIANT_TYPE_UINT32; an unsigned 32 bit integer.\n- `x`: the type string of %G_VARIANT_TYPE_INT64; a signed 64 bit integer.\n- `t`: the type string of %G_VARIANT_TYPE_UINT64; an unsigned 64 bit integer.\n- `h`: the type string of %G_VARIANT_TYPE_HANDLE; a signed 32 bit value\n  that, by convention, is used as an index into an array of file\n  descriptors that are sent alongside a D-Bus message.\n- `d`: the type string of %G_VARIANT_TYPE_DOUBLE; a double precision\n  floating point value.\n- `s`: the type string of %G_VARIANT_TYPE_STRING; a string.\n- `o`: the type string of %G_VARIANT_TYPE_OBJECT_PATH; a string in the form\n  of a D-Bus object path.\n- `g`: the type string of %G_VARIANT_TYPE_STRING; a string in the form of\n  a D-Bus type signature.\n- `?`: the type string of %G_VARIANT_TYPE_BASIC; an indefinite type that\n  is a supertype of any of the basic types.\n- `v`: the type string of %G_VARIANT_TYPE_VARIANT; a container type that\n  contain any other type of value.\n- `a`: used as a prefix on another type string to mean an array of that\n  type; the type string \"ai\", for example, is the type of an array of\n  signed 32-bit integers.\n- `m`: used as a prefix on another type string to mean a \"maybe\", or\n  \"nullable\", version of that type; the type string \"ms\", for example,\n  is the type of a value that maybe contains a string, or maybe contains\n  nothing.\n- `()`: used to enclose zero or more other concatenated type strings to\n  create a tuple type; the type string \"(is)\", for example, is the type of\n  a pair of an integer and a string.\n- `r`: the type string of %G_VARIANT_TYPE_TUPLE; an indefinite type that is\n  a supertype of any tuple type, regardless of the number of items.\n- `{}`: used to enclose a basic type string concatenated with another type\n  string to create a dictionary entry type, which usually appears inside of\n  an array to form a dictionary; the type string \"a{sd}\", for example, is\n  the type of a dictionary that maps strings to double precision floating\n  point values.\n\n  The first type (the basic type) is the key type and the second type is\n  the value type. The reason that the first type is restricted to being a\n  basic type is so that it can easily be hashed.\n- `*`: the type string of %G_VARIANT_TYPE_ANY; the indefinite type that is\n  a supertype of all types.  Note that, as with all type strings, this\n  character represents exactly one type. It cannot be used inside of tuples\n  to mean \"any number of items\".\n\nAny type string of a container that contains an indefinite type is,\nitself, an indefinite type. For example, the type string \"a*\"\n(corresponding to %G_VARIANT_TYPE_ARRAY) is an indefinite type\nthat is a supertype of every array type. \"(*s)\" is a supertype\nof all tuples that contain exactly two items where the second\nitem is a string.\n\n\"a{?*}\" is an indefinite type that is a supertype of all arrays\ncontaining dictionary entries where the key is any basic type and\nthe value is any type at all.  This is, by definition, a dictionary,\nso this type string corresponds to %G_VARIANT_TYPE_DICTIONARY. Note\nthat, due to the restriction that the key of a dictionary entry must\nbe a basic type, \"{**}\" is not a valid type string.</doc>\n  <constructor name=\"new\" c:identifier=\"g_variant_type_new\" version=\"2.24\" gs:managed-name=\"New\">\n    <doc xml:space=\"preserve\">Creates a new #GVariantType corresponding to the type string given\nby @type_string.  It is appropriate to call g_variant_type_free() on\nthe return value.\n\nIt is a programmer error to call this function with an invalid type\nstring.  Use g_variant_type_string_is_valid() if you are unsure.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GVariantType</doc>\n      <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"type_string\" transfer-ownership=\"none\" gs:managed-name=\"typeString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid GVariant type string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type_string\" transfer-ownership=\"none\" gs:managed-name=\"typeString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a valid GVariant type string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </constructor>\n  <function name=\"new_array\" c:identifier=\"g_variant_type_new_array\" gs:managed-name=\"NewArray\">\n    <doc xml:space=\"preserve\">Constructs the type corresponding to an array of elements of the\ntype @type.\n\nIt is appropriate to call g_variant_type_free() on the return value.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new array #GVariantType\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"element\" transfer-ownership=\"none\" gs:managed-name=\"element\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"element\" transfer-ownership=\"none\" gs:managed-name=\"element\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"new_dict_entry\" c:identifier=\"g_variant_type_new_dict_entry\" gs:managed-name=\"NewDictEntry\">\n    <doc xml:space=\"preserve\">Constructs the type corresponding to a dictionary entry with a key\nof type @key and a value of type @value.\n\nIt is appropriate to call g_variant_type_free() on the return value.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new dictionary entry #GVariantType\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a basic #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"key\" transfer-ownership=\"none\" gs:managed-name=\"key\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a basic #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n      <parameter name=\"value\" transfer-ownership=\"none\" gs:managed-name=\"value\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"new_maybe\" c:identifier=\"g_variant_type_new_maybe\" gs:managed-name=\"NewMaybe\">\n    <doc xml:space=\"preserve\">Constructs the type corresponding to a maybe instance containing\ntype @type or Nothing.\n\nIt is appropriate to call g_variant_type_free() on the return value.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new maybe #GVariantType\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"element\" transfer-ownership=\"none\" gs:managed-name=\"element\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"element\" transfer-ownership=\"none\" gs:managed-name=\"element\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"new_tuple\" c:identifier=\"g_variant_type_new_tuple\" gs:managed-name=\"NewTuple\">\n    <doc xml:space=\"preserve\">Constructs a new tuple type, from @items.\n\n@length is the number of items in @items, or -1 to indicate that\n@items is %NULL-terminated.\n\nIt is appropriate to call g_variant_type_free() on the return value.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new tuple #GVariantType\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"items\" transfer-ownership=\"none\" gs:managed-name=\"items\" gs:managed-type=\"VariantType[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">an array of #GVariantTypes, one for each item</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"GVariantType**\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n        </array>\n      </parameter>\n      <parameter name=\"length\" transfer-ownership=\"none\" gs:managed-name=\"length\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the length of @items, or -1</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"items\" transfer-ownership=\"none\" gs:managed-name=\"items\" gs:managed-type=\"VariantType[]\" gs:unmanaged-type=\"System.IntPtr[]\">\n        <doc xml:space=\"preserve\">an array of #GVariantTypes, one for each item</doc>\n        <array length=\"1\" zero-terminated=\"0\" c:type=\"GVariantType**\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n          <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n        </array>\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <method name=\"copy\" c:identifier=\"g_variant_type_copy\" gs:managed-name=\"Copy\" gs:special-func=\"copy\">\n    <doc xml:space=\"preserve\">Makes a copy of a #GVariantType.  It is appropriate to call\ng_variant_type_free() on the return value.  @type may not be %NULL.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">a new #GVariantType\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"to_string\" c:identifier=\"g_variant_type_dup_string\" gs:managed-name=\"ToString\" gs:special-func=\"to-string\">\n    <doc xml:space=\"preserve\">Returns a newly-allocated copy of the type string corresponding to\n@type.  The returned string is nul-terminated.  It is appropriate to\ncall g_free() on the return value.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the corresponding type string\n\nSince 2.24</doc>\n      <type name=\"utf8\" c:type=\"gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"element\" c:identifier=\"g_variant_type_element\" gs:managed-name=\"Element\">\n    <doc xml:space=\"preserve\">Determines the element type of an array or maybe type.\n\nThis function may only be used with array or maybe types.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the element type of @type\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">an array or maybe #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"equal\" c:identifier=\"g_variant_type_equal\" gs:managed-name=\"Equals\" gs:special-func=\"equal\">\n    <doc xml:space=\"preserve\">Compares @type1 and @type2 for equality.\n\nOnly returns %TRUE if the types are exactly equal.  Even if one type\nis an indefinite type and the other is a subtype of it, %FALSE will\nbe returned if they are not exactly equal.  If you want to check for\nsubtypes, use g_variant_type_is_subtype_of().\n\nThe argument types of @type1 and @type2 are only #gconstpointer to\nallow use with #GHashTable without function pointer casting.  For\nboth arguments, a valid #GVariantType must be provided.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type1 and @type2 are exactly equal\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type1\" transfer-ownership=\"none\" gs:managed-name=\"type1\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"gconstpointer\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n      <parameter name=\"type2\" transfer-ownership=\"none\" gs:managed-name=\"type2\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"gconstpointer\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type2\" transfer-ownership=\"none\" gs:managed-name=\"type2\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"gconstpointer\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"first\" c:identifier=\"g_variant_type_first\" gs:managed-name=\"First\">\n    <doc xml:space=\"preserve\">Determines the first item type of a tuple or dictionary entry\ntype.\n\nThis function may only be used with tuple or dictionary entry types,\nbut must not be used with the generic tuple type\n%G_VARIANT_TYPE_TUPLE.\n\nIn the case of a dictionary entry type, this returns the type of\nthe key.\n\n%NULL is returned in case of @type being %G_VARIANT_TYPE_UNIT.\n\nThis call, together with g_variant_type_next() provides an iterator\ninterface over tuple and dictionary entry types.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the first item type of @type, or %NULL\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a tuple or dictionary entry #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"free\" c:identifier=\"g_variant_type_free\" gs:managed-name=\"Free\" gs:special-func=\"free\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Frees a #GVariantType that was allocated with\ng_variant_type_copy(), g_variant_type_new() or one of the container\ntype constructor functions.\n\nIn the case that @type is %NULL, this function does nothing.\n\nSince 2.24</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType, or %NULL</doc>\n        <type name=\"VariantType\" c:type=\"GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"get_string_length\" c:identifier=\"g_variant_type_get_string_length\" gs:managed-name=\"get_StringLength\" gs:property=\"StringLength\">\n    <doc xml:space=\"preserve\">Returns the length of the type string corresponding to the given\n@type.  This function must be used to determine the valid extent of\nthe memory region returned by g_variant_type_peek_string().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the length of the corresponding type string\n\nSince 2.24</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"hash\" c:identifier=\"g_variant_type_hash\" gs:managed-name=\"Hash\" gs:special-func=\"hash\" gs:access-modifier=\"protected\">\n    <doc xml:space=\"preserve\">Hashes @type.\n\nThe argument type of @type is only #gconstpointer to allow use with\n#GHashTable without function pointer casting.  A valid\n#GVariantType must be provided.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the hash value\n\nSince 2.24</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"gconstpointer\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_array\" c:identifier=\"g_variant_type_is_array\" gs:managed-name=\"get_IsArray\" gs:property=\"IsArray\">\n    <doc xml:space=\"preserve\">Determines if the given @type is an array type.  This is true if the\ntype string for @type starts with an 'a'.\n\nThis function returns %TRUE for any indefinite type for which every\ndefinite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for\nexample.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is an array type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_basic\" c:identifier=\"g_variant_type_is_basic\" gs:managed-name=\"get_IsBasic\" gs:property=\"IsBasic\">\n    <doc xml:space=\"preserve\">Determines if the given @type is a basic type.\n\nBasic types are booleans, bytes, integers, doubles, strings, object\npaths and signatures.\n\nOnly a basic type may be used as the key of a dictionary entry.\n\nThis function returns %FALSE for all indefinite types except\n%G_VARIANT_TYPE_BASIC.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is a basic type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_container\" c:identifier=\"g_variant_type_is_container\" gs:managed-name=\"get_IsContainer\" gs:property=\"IsContainer\">\n    <doc xml:space=\"preserve\">Determines if the given @type is a container type.\n\nContainer types are any array, maybe, tuple, or dictionary\nentry types plus the variant type.\n\nThis function returns %TRUE for any indefinite type for which every\ndefinite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for\nexample.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is a container type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_definite\" c:identifier=\"g_variant_type_is_definite\" gs:managed-name=\"get_IsDefinite\" gs:property=\"IsDefinite\">\n    <doc xml:space=\"preserve\">Determines if the given @type is definite (ie: not indefinite).\n\nA type is definite if its type string does not contain any indefinite\ntype characters ('*', '?', or 'r').\n\nA #GVariant instance may not have an indefinite type, so calling\nthis function on the result of g_variant_get_type() will always\nresult in %TRUE being returned.  Calling this function on an\nindefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in\n%FALSE being returned.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is definite\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_dict_entry\" c:identifier=\"g_variant_type_is_dict_entry\" gs:managed-name=\"get_IsDictEntry\" gs:property=\"IsDictEntry\">\n    <doc xml:space=\"preserve\">Determines if the given @type is a dictionary entry type.  This is\ntrue if the type string for @type starts with a '{'.\n\nThis function returns %TRUE for any indefinite type for which every\ndefinite subtype is a dictionary entry type --\n%G_VARIANT_TYPE_DICT_ENTRY, for example.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is a dictionary entry type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_maybe\" c:identifier=\"g_variant_type_is_maybe\" gs:managed-name=\"get_IsMaybe\" gs:property=\"IsMaybe\">\n    <doc xml:space=\"preserve\">Determines if the given @type is a maybe type.  This is true if the\ntype string for @type starts with an 'm'.\n\nThis function returns %TRUE for any indefinite type for which every\ndefinite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for\nexample.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is a maybe type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_subtype_of\" c:identifier=\"g_variant_type_is_subtype_of\" gs:managed-name=\"IsSubtypeOf\">\n    <doc xml:space=\"preserve\">Checks if @type is a subtype of @supertype.\n\nThis function returns %TRUE if @type is a subtype of @supertype.  All\ntypes are considered to be subtypes of themselves.  Aside from that,\nonly indefinite types can have subtypes.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is a subtype of @supertype\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n      <parameter name=\"supertype\" transfer-ownership=\"none\" gs:managed-name=\"supertype\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"supertype\" transfer-ownership=\"none\" gs:managed-name=\"supertype\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </parameter>\n    </gs:managed-parameters>\n  </method>\n  <method name=\"is_tuple\" c:identifier=\"g_variant_type_is_tuple\" gs:managed-name=\"get_IsTuple\" gs:property=\"IsTuple\">\n    <doc xml:space=\"preserve\">Determines if the given @type is a tuple type.  This is true if the\ntype string for @type starts with a '(' or if @type is\n%G_VARIANT_TYPE_TUPLE.\n\nThis function returns %TRUE for any indefinite type for which every\ndefinite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for\nexample.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is a tuple type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"is_variant\" c:identifier=\"g_variant_type_is_variant\" gs:managed-name=\"get_IsVariant\" gs:property=\"IsVariant\">\n    <doc xml:space=\"preserve\">Determines if the given @type is the variant type.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type is the variant type\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"key\" c:identifier=\"g_variant_type_key\" gs:managed-name=\"Key\">\n    <doc xml:space=\"preserve\">Determines the key type of a dictionary entry type.\n\nThis function may only be used with a dictionary entry type.  Other\nthan the additional restriction, this call is equivalent to\ng_variant_type_first().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the key type of the dictionary entry\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a dictionary entry #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"n_items\" c:identifier=\"g_variant_type_n_items\" gs:managed-name=\"NItems\">\n    <doc xml:space=\"preserve\">Determines the number of items contained in a tuple or\ndictionary entry type.\n\nThis function may only be used with tuple or dictionary entry types,\nbut must not be used with the generic tuple type\n%G_VARIANT_TYPE_TUPLE.\n\nIn the case of a dictionary entry type, this function will always\nreturn 2.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt64\" gs:unmanaged-type=\"System.UInt64\">\n      <doc xml:space=\"preserve\">the number of items in @type\n\nSince 2.24</doc>\n      <type name=\"gsize\" c:type=\"gsize\" gs:managed-name=\"Gsize\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a tuple or dictionary entry #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"next\" c:identifier=\"g_variant_type_next\" gs:managed-name=\"Next\">\n    <doc xml:space=\"preserve\">Determines the next item type of a tuple or dictionary entry\ntype.\n\n@type must be the result of a previous call to\ng_variant_type_first() or g_variant_type_next().\n\nIf called on the key type of a dictionary entry then this call\nreturns the value type.  If called on the value type of a dictionary\nentry then this call returns %NULL.\n\nFor tuples, %NULL is returned when @type is the last item in a tuple.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the next #GVariantType after @type, or %NULL\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType from a previous call</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"peek_string\" c:identifier=\"g_variant_type_peek_string\" introspectable=\"0\" gs:managed-name=\"PeekString\">\n    <doc xml:space=\"preserve\">Returns the type string corresponding to the given @type.  The\nresult is not nul-terminated; in order to determine its length you\nmust call g_variant_type_get_string_length().\n\nTo get a nul-terminated string, see g_variant_type_dup_string().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the corresponding type string (not nul-terminated)\n\nSince 2.24</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <method name=\"value\" c:identifier=\"g_variant_type_value\" gs:managed-name=\"Value\">\n    <doc xml:space=\"preserve\">Determines the value type of a dictionary entry type.\n\nThis function may only be used with a dictionary entry type.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the value type of the dictionary entry\n\nSince 2.24</doc>\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <instance-parameter name=\"type\" transfer-ownership=\"none\" gs:managed-name=\"type\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a dictionary entry #GVariantType</doc>\n        <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n      </instance-parameter>\n    </parameters>\n    <gs:managed-parameters />\n  </method>\n  <function name=\"checked_\" c:identifier=\"g_variant_type_checked_\" gs:managed-name=\"Checked\">\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"VariantType\" gs:unmanaged-type=\"System.IntPtr\">\n      <type name=\"VariantType\" c:type=\"const GVariantType*\" gs:managed-name=\"VariantType\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"arg0\" transfer-ownership=\"none\" gs:managed-name=\"arg0\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"arg0\" transfer-ownership=\"none\" gs:managed-name=\"arg0\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"string_is_valid\" c:identifier=\"g_variant_type_string_is_valid\" gs:managed-name=\"StringIsValid\">\n    <doc xml:space=\"preserve\">Checks if @type_string is a valid GVariant type string.  This call is\nequivalent to calling g_variant_type_string_scan() and confirming\nthat the following character is a nul terminator.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if @type_string is exactly one valid type string\n\nSince 2.24</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"type_string\" transfer-ownership=\"none\" gs:managed-name=\"typeString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to any string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"type_string\" transfer-ownership=\"none\" gs:managed-name=\"typeString\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to any string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"string_scan\" c:identifier=\"g_variant_type_string_scan\" version=\"2.24\" gs:managed-name=\"StringScan\">\n    <doc xml:space=\"preserve\">Scan for a single complete and valid GVariant type string in @string.\nThe memory pointed to by @limit (or bytes beyond it) is never\naccessed.\n\nIf a valid type string is found, @endptr is updated to point to the\nfirst character past the end of the string that was found and %TRUE\nis returned.\n\nIf there is no valid type string starting at @string, or if the type\nstring does not end before @limit then %FALSE is returned.\n\nFor the simple case of checking if a string is a valid type string,\nsee g_variant_type_string_is_valid().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if a valid type string was found</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to any string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"limit\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"limit\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the end of @string, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">location to store the end pointer, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"string\" transfer-ownership=\"none\" gs:managed-name=\"@string\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">a pointer to any string</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"limit\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"limit\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the end of @string, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"endptr\" direction=\"out\" caller-allocates=\"0\" transfer-ownership=\"full\" optional=\"1\" allow-none=\"1\" gs:managed-name=\"endptr\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">location to store the end pointer, or %NULL</doc>\n        <type name=\"utf8\" c:type=\"const gchar**\" gs:managed-name=\"Utf8\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</record>")]
    public partial class VariantType : GISharp.Core.OwnedOpaque<GISharp.GLib.VariantType>,
        System.IEquatable<GISharp.GLib.VariantType>
    {
        /// <summary>
        /// Returns the length of the type string corresponding to the given
        /// @type.  This function must be used to determine the valid extent of
        /// the memory region returned by g_variant_type_peek_string().
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the length of the corresponding type string
        /// 
        /// Since 2.24
        /// </returns>
        public System.UInt64 StringLength
        {
            get
            {
                return default(System.UInt64);
            }
        }

        /// <summary>
        /// Determines if the given @type is an array type.  This is true if the
        /// type string for @type starts with an 'a'.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is an array type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsArray
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is a basic type.
        /// </summary>
        /// <remarks>
        /// Basic types are booleans, bytes, integers, doubles, strings, object
        /// paths and signatures.
        /// 
        /// Only a basic type may be used as the key of a dictionary entry.
        /// 
        /// This function returns %FALSE for all indefinite types except
        /// %G_VARIANT_TYPE_BASIC.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a basic type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsBasic
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is a container type.
        /// </summary>
        /// <remarks>
        /// Container types are any array, maybe, tuple, or dictionary
        /// entry types plus the variant type.
        /// 
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a container type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsContainer
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is definite (ie: not indefinite).
        /// </summary>
        /// <remarks>
        /// A type is definite if its type string does not contain any indefinite
        /// type characters ('*', '?', or 'r').
        /// 
        /// A #GVariant instance may not have an indefinite type, so calling
        /// this function on the result of g_variant_get_type() will always
        /// result in %TRUE being returned.  Calling this function on an
        /// indefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in
        /// %FALSE being returned.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is definite
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsDefinite
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is a dictionary entry type.  This is
        /// true if the type string for @type starts with a '{'.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a dictionary entry type --
        /// %G_VARIANT_TYPE_DICT_ENTRY, for example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a dictionary entry type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsDictEntry
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is a maybe type.  This is true if the
        /// type string for @type starts with an 'm'.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a maybe type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsMaybe
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is a tuple type.  This is true if the
        /// type string for @type starts with a '(' or if @type is
        /// %G_VARIANT_TYPE_TUPLE.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a tuple type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsTuple
        {
            get
            {
                return default(System.Boolean);
            }
        }

        /// <summary>
        /// Determines if the given @type is the variant type.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is the variant type
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsVariant
        {
            get
            {
                return default(System.Boolean);
            }
        }

        public VariantType(System.IntPtr handle) : base(handle)
        {
        }

        /// <summary>
        /// Creates a new #GVariantType corresponding to the type string given
        /// by @type_string.  It is appropriate to call g_variant_type_free() on
        /// the return value.
        /// </summary>
        /// <remarks>
        /// It is a programmer error to call this function with an invalid type
        /// string.  Use g_variant_type_string_is_valid() if you are unsure.
        /// </remarks>
        /// <param name="typeString">
        /// a valid GVariant type string
        /// </param>
        /// <returns>
        /// a new #GVariantType
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public VariantType(
            System.String typeString) : base(System.IntPtr.Zero)
        {
        }

        /// <summary>
        /// Creates a new #GVariantType corresponding to the type string given
        /// by @type_string.  It is appropriate to call g_variant_type_free() on
        /// the return value.
        /// </summary>
        /// <remarks>
        /// It is a programmer error to call this function with an invalid type
        /// string.  Use g_variant_type_string_is_valid() if you are unsure.
        /// </remarks>
        /// <param name="typeString">
        /// a valid GVariant type string
        /// </param>
        /// <returns>
        /// a new #GVariantType
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.IntPtr g_variant_type_new(
            [System.Runtime.InteropServices.In()] System.IntPtr typeString);

        /// <summary>
        /// Constructs the type corresponding to an array of elements of the
        /// type @type.
        /// </summary>
        /// <remarks>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="element">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new array #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_new_array(
            [System.Runtime.InteropServices.In()] System.IntPtr element);

        /// <summary>
        /// Constructs the type corresponding to an array of elements of the
        /// type @type.
        /// </summary>
        /// <remarks>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="element">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new array #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        public static GISharp.GLib.VariantType NewArray(
            GISharp.GLib.VariantType element)
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Constructs the type corresponding to a dictionary entry with a key
        /// of type @key and a value of type @value.
        /// </summary>
        /// <remarks>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="key">
        /// a basic #GVariantType
        /// </param>
        /// <param name="value">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new dictionary entry #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_new_dict_entry(
            [System.Runtime.InteropServices.In()] System.IntPtr key,
            [System.Runtime.InteropServices.In()] System.IntPtr value);

        /// <summary>
        /// Constructs the type corresponding to a dictionary entry with a key
        /// of type @key and a value of type @value.
        /// </summary>
        /// <remarks>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="key">
        /// a basic #GVariantType
        /// </param>
        /// <param name="value">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new dictionary entry #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        public static GISharp.GLib.VariantType NewDictEntry(
            GISharp.GLib.VariantType key,
            GISharp.GLib.VariantType value)
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Constructs the type corresponding to a maybe instance containing
        /// type @type or Nothing.
        /// </summary>
        /// <remarks>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="element">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new maybe #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_new_maybe(
            [System.Runtime.InteropServices.In()] System.IntPtr element);

        /// <summary>
        /// Constructs the type corresponding to a maybe instance containing
        /// type @type or Nothing.
        /// </summary>
        /// <remarks>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="element">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new maybe #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        public static GISharp.GLib.VariantType NewMaybe(
            GISharp.GLib.VariantType element)
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Constructs a new tuple type, from @items.
        /// </summary>
        /// <remarks>
        /// @length is the number of items in @items, or -1 to indicate that
        /// @items is %NULL-terminated.
        /// 
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="items">
        /// an array of #GVariantTypes, one for each item
        /// </param>
        /// <param name="length">
        /// the length of @items, or -1
        /// </param>
        /// <returns>
        /// a new tuple #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_new_tuple(
            [System.Runtime.InteropServices.In(), System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPArray, SizeParamIndex = 1)] System.IntPtr[] items,
            [System.Runtime.InteropServices.In()] System.Int32 length);

        /// <summary>
        /// Constructs a new tuple type, from @items.
        /// </summary>
        /// <remarks>
        /// @length is the number of items in @items, or -1 to indicate that
        /// @items is %NULL-terminated.
        /// 
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </remarks>
        /// <param name="items">
        /// an array of #GVariantTypes, one for each item
        /// </param>
        /// <param name="length">
        /// the length of @items, or -1
        /// </param>
        /// <returns>
        /// a new tuple #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        public static GISharp.GLib.VariantType NewTuple(
            GISharp.GLib.VariantType[] items)
        {
            return default(GISharp.GLib.VariantType);
        }

        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_checked_(
[System.Runtime.InteropServices.In()] System.IntPtr arg0);

        public static GISharp.GLib.VariantType Checked(
System.String arg0)
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Checks if @type_string is a valid GVariant type string.  This call is
        /// equivalent to calling g_variant_type_string_scan() and confirming
        /// that the following character is a nul terminator.
        /// </summary>
        /// <param name="typeString">
        /// a pointer to any string
        /// </param>
        /// <returns>
        /// %TRUE if @type_string is exactly one valid type string
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_string_is_valid(
            [System.Runtime.InteropServices.In()] System.IntPtr typeString);

        /// <summary>
        /// Checks if @type_string is a valid GVariant type string.  This call is
        /// equivalent to calling g_variant_type_string_scan() and confirming
        /// that the following character is a nul terminator.
        /// </summary>
        /// <param name="typeString">
        /// a pointer to any string
        /// </param>
        /// <returns>
        /// %TRUE if @type_string is exactly one valid type string
        /// 
        /// Since 2.24
        /// </returns>
        public static System.Boolean StringIsValid(
            System.String typeString)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Scan for a single complete and valid GVariant type string in @string.
        /// The memory pointed to by @limit (or bytes beyond it) is never
        /// accessed.
        /// </summary>
        /// <remarks>
        /// If a valid type string is found, @endptr is updated to point to the
        /// first character past the end of the string that was found and %TRUE
        /// is returned.
        /// 
        /// If there is no valid type string starting at @string, or if the type
        /// string does not end before @limit then %FALSE is returned.
        /// 
        /// For the simple case of checking if a string is a valid type string,
        /// see g_variant_type_string_is_valid().
        /// </remarks>
        /// <param name="string">
        /// a pointer to any string
        /// </param>
        /// <param name="limit">
        /// the end of @string, or %NULL
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer, or %NULL
        /// </param>
        /// <returns>
        /// %TRUE if a valid type string was found
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.24")]
        static extern System.Boolean g_variant_type_string_scan(
            [System.Runtime.InteropServices.In()] System.IntPtr @string,
            [System.Runtime.InteropServices.In()] System.IntPtr limit,
            [System.Runtime.InteropServices.Out()] out System.IntPtr endptr);

        /// <summary>
        /// Scan for a single complete and valid GVariant type string in @string.
        /// The memory pointed to by @limit (or bytes beyond it) is never
        /// accessed.
        /// </summary>
        /// <remarks>
        /// If a valid type string is found, @endptr is updated to point to the
        /// first character past the end of the string that was found and %TRUE
        /// is returned.
        /// 
        /// If there is no valid type string starting at @string, or if the type
        /// string does not end before @limit then %FALSE is returned.
        /// 
        /// For the simple case of checking if a string is a valid type string,
        /// see g_variant_type_string_is_valid().
        /// </remarks>
        /// <param name="string">
        /// a pointer to any string
        /// </param>
        /// <param name="limit">
        /// the end of @string, or %NULL
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer, or %NULL
        /// </param>
        /// <returns>
        /// %TRUE if a valid type string was found
        /// </returns>
        [GISharp.Core.Since("2.24")]
        public static System.Boolean StringScan(
            System.String @string,
            System.String limit,
            out System.String endptr)
        {
            endptr = default(System.String);
            return default(System.Boolean);
        }

        /// <summary>
        /// Makes a copy of a #GVariantType.  It is appropriate to call
        /// g_variant_type_free() on the return value.  @type may not be %NULL.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_copy(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Makes a copy of a #GVariantType.  It is appropriate to call
        /// g_variant_type_free() on the return value.  @type may not be %NULL.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        public override GISharp.GLib.VariantType Copy()
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Returns a newly-allocated copy of the type string corresponding to
        /// @type.  The returned string is nul-terminated.  It is appropriate to
        /// call g_free() on the return value.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the corresponding type string
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_dup_string(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Returns a newly-allocated copy of the type string corresponding to
        /// @type.  The returned string is nul-terminated.  It is appropriate to
        /// call g_free() on the return value.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the corresponding type string
        /// 
        /// Since 2.24
        /// </returns>
        public override System.String ToString()
        {
            return default(System.String);
        }

        /// <summary>
        /// Determines the element type of an array or maybe type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with array or maybe types.
        /// </remarks>
        /// <param name="type">
        /// an array or maybe #GVariantType
        /// </param>
        /// <returns>
        /// the element type of @type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_element(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the element type of an array or maybe type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with array or maybe types.
        /// </remarks>
        /// <param name="type">
        /// an array or maybe #GVariantType
        /// </param>
        /// <returns>
        /// the element type of @type
        /// 
        /// Since 2.24
        /// </returns>
        public GISharp.GLib.VariantType Element()
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Compares @type1 and @type2 for equality.
        /// </summary>
        /// <remarks>
        /// Only returns %TRUE if the types are exactly equal.  Even if one type
        /// is an indefinite type and the other is a subtype of it, %FALSE will
        /// be returned if they are not exactly equal.  If you want to check for
        /// subtypes, use g_variant_type_is_subtype_of().
        /// 
        /// The argument types of @type1 and @type2 are only #gconstpointer to
        /// allow use with #GHashTable without function pointer casting.  For
        /// both arguments, a valid #GVariantType must be provided.
        /// </remarks>
        /// <param name="type1">
        /// a #GVariantType
        /// </param>
        /// <param name="type2">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type1 and @type2 are exactly equal
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_equal(
            [System.Runtime.InteropServices.In()] System.IntPtr type1,
            [System.Runtime.InteropServices.In()] System.IntPtr type2);

        /// <summary>
        /// Compares @type1 and @type2 for equality.
        /// </summary>
        /// <remarks>
        /// Only returns %TRUE if the types are exactly equal.  Even if one type
        /// is an indefinite type and the other is a subtype of it, %FALSE will
        /// be returned if they are not exactly equal.  If you want to check for
        /// subtypes, use g_variant_type_is_subtype_of().
        /// 
        /// The argument types of @type1 and @type2 are only #gconstpointer to
        /// allow use with #GHashTable without function pointer casting.  For
        /// both arguments, a valid #GVariantType must be provided.
        /// </remarks>
        /// <param name="type1">
        /// a #GVariantType
        /// </param>
        /// <param name="type2">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type1 and @type2 are exactly equal
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean Equals(
            GISharp.GLib.VariantType type2)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Determines the first item type of a tuple or dictionary entry
        /// type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with tuple or dictionary entry types,
        /// but must not be used with the generic tuple type
        /// %G_VARIANT_TYPE_TUPLE.
        /// 
        /// In the case of a dictionary entry type, this returns the type of
        /// the key.
        /// 
        /// %NULL is returned in case of @type being %G_VARIANT_TYPE_UNIT.
        /// 
        /// This call, together with g_variant_type_next() provides an iterator
        /// interface over tuple and dictionary entry types.
        /// </remarks>
        /// <param name="type">
        /// a tuple or dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the first item type of @type, or %NULL
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_first(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the first item type of a tuple or dictionary entry
        /// type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with tuple or dictionary entry types,
        /// but must not be used with the generic tuple type
        /// %G_VARIANT_TYPE_TUPLE.
        /// 
        /// In the case of a dictionary entry type, this returns the type of
        /// the key.
        /// 
        /// %NULL is returned in case of @type being %G_VARIANT_TYPE_UNIT.
        /// 
        /// This call, together with g_variant_type_next() provides an iterator
        /// interface over tuple and dictionary entry types.
        /// </remarks>
        /// <param name="type">
        /// a tuple or dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the first item type of @type, or %NULL
        /// 
        /// Since 2.24
        /// </returns>
        public GISharp.GLib.VariantType First()
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Frees a #GVariantType that was allocated with
        /// g_variant_type_copy(), g_variant_type_new() or one of the container
        /// type constructor functions.
        /// </summary>
        /// <remarks>
        /// In the case that @type is %NULL, this function does nothing.
        /// 
        /// Since 2.24
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType, or %NULL
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_variant_type_free(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Frees a #GVariantType that was allocated with
        /// g_variant_type_copy(), g_variant_type_new() or one of the container
        /// type constructor functions.
        /// </summary>
        /// <remarks>
        /// In the case that @type is %NULL, this function does nothing.
        /// 
        /// Since 2.24
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType, or %NULL
        /// </param>
        protected override void Free()
        {
        }

        /// <summary>
        /// Returns the length of the type string corresponding to the given
        /// @type.  This function must be used to determine the valid extent of
        /// the memory region returned by g_variant_type_peek_string().
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the length of the corresponding type string
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt64 g_variant_type_get_string_length(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Hashes @type.
        /// </summary>
        /// <remarks>
        /// The argument type of @type is only #gconstpointer to allow use with
        /// #GHashTable without function pointer casting.  A valid
        /// #GVariantType must be provided.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the hash value
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_variant_type_hash(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Hashes @type.
        /// </summary>
        /// <remarks>
        /// The argument type of @type is only #gconstpointer to allow use with
        /// #GHashTable without function pointer casting.  A valid
        /// #GVariantType must be provided.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the hash value
        /// 
        /// Since 2.24
        /// </returns>
        protected System.UInt32 Hash()
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Determines if the given @type is an array type.  This is true if the
        /// type string for @type starts with an 'a'.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is an array type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_array(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines if the given @type is a basic type.
        /// </summary>
        /// <remarks>
        /// Basic types are booleans, bytes, integers, doubles, strings, object
        /// paths and signatures.
        /// 
        /// Only a basic type may be used as the key of a dictionary entry.
        /// 
        /// This function returns %FALSE for all indefinite types except
        /// %G_VARIANT_TYPE_BASIC.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a basic type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_basic(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines if the given @type is a container type.
        /// </summary>
        /// <remarks>
        /// Container types are any array, maybe, tuple, or dictionary
        /// entry types plus the variant type.
        /// 
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a container type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_container(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines if the given @type is definite (ie: not indefinite).
        /// </summary>
        /// <remarks>
        /// A type is definite if its type string does not contain any indefinite
        /// type characters ('*', '?', or 'r').
        /// 
        /// A #GVariant instance may not have an indefinite type, so calling
        /// this function on the result of g_variant_get_type() will always
        /// result in %TRUE being returned.  Calling this function on an
        /// indefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in
        /// %FALSE being returned.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is definite
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_definite(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines if the given @type is a dictionary entry type.  This is
        /// true if the type string for @type starts with a '{'.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a dictionary entry type --
        /// %G_VARIANT_TYPE_DICT_ENTRY, for example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a dictionary entry type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_dict_entry(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines if the given @type is a maybe type.  This is true if the
        /// type string for @type starts with an 'm'.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a maybe type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_maybe(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Checks if @type is a subtype of @supertype.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE if @type is a subtype of @supertype.  All
        /// types are considered to be subtypes of themselves.  Aside from that,
        /// only indefinite types can have subtypes.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <param name="supertype">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a subtype of @supertype
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_subtype_of(
            [System.Runtime.InteropServices.In()] System.IntPtr type,
            [System.Runtime.InteropServices.In()] System.IntPtr supertype);

        /// <summary>
        /// Checks if @type is a subtype of @supertype.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE if @type is a subtype of @supertype.  All
        /// types are considered to be subtypes of themselves.  Aside from that,
        /// only indefinite types can have subtypes.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <param name="supertype">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a subtype of @supertype
        /// 
        /// Since 2.24
        /// </returns>
        public System.Boolean IsSubtypeOf(
            GISharp.GLib.VariantType supertype)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Determines if the given @type is a tuple type.  This is true if the
        /// type string for @type starts with a '(' or if @type is
        /// %G_VARIANT_TYPE_TUPLE.
        /// </summary>
        /// <remarks>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for
        /// example.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a tuple type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_tuple(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines if the given @type is the variant type.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is the variant type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_variant_type_is_variant(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the key type of a dictionary entry type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with a dictionary entry type.  Other
        /// than the additional restriction, this call is equivalent to
        /// g_variant_type_first().
        /// </remarks>
        /// <param name="type">
        /// a dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the key type of the dictionary entry
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_key(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the key type of a dictionary entry type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with a dictionary entry type.  Other
        /// than the additional restriction, this call is equivalent to
        /// g_variant_type_first().
        /// </remarks>
        /// <param name="type">
        /// a dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the key type of the dictionary entry
        /// 
        /// Since 2.24
        /// </returns>
        public GISharp.GLib.VariantType Key()
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Determines the number of items contained in a tuple or
        /// dictionary entry type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with tuple or dictionary entry types,
        /// but must not be used with the generic tuple type
        /// %G_VARIANT_TYPE_TUPLE.
        /// 
        /// In the case of a dictionary entry type, this function will always
        /// return 2.
        /// </remarks>
        /// <param name="type">
        /// a tuple or dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the number of items in @type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt64 g_variant_type_n_items(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the number of items contained in a tuple or
        /// dictionary entry type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with tuple or dictionary entry types,
        /// but must not be used with the generic tuple type
        /// %G_VARIANT_TYPE_TUPLE.
        /// 
        /// In the case of a dictionary entry type, this function will always
        /// return 2.
        /// </remarks>
        /// <param name="type">
        /// a tuple or dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the number of items in @type
        /// 
        /// Since 2.24
        /// </returns>
        public System.UInt64 NItems()
        {
            return default(System.UInt64);
        }

        /// <summary>
        /// Determines the next item type of a tuple or dictionary entry
        /// type.
        /// </summary>
        /// <remarks>
        /// @type must be the result of a previous call to
        /// g_variant_type_first() or g_variant_type_next().
        /// 
        /// If called on the key type of a dictionary entry then this call
        /// returns the value type.  If called on the value type of a dictionary
        /// entry then this call returns %NULL.
        /// 
        /// For tuples, %NULL is returned when @type is the last item in a tuple.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType from a previous call
        /// </param>
        /// <returns>
        /// the next #GVariantType after @type, or %NULL
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_next(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the next item type of a tuple or dictionary entry
        /// type.
        /// </summary>
        /// <remarks>
        /// @type must be the result of a previous call to
        /// g_variant_type_first() or g_variant_type_next().
        /// 
        /// If called on the key type of a dictionary entry then this call
        /// returns the value type.  If called on the value type of a dictionary
        /// entry then this call returns %NULL.
        /// 
        /// For tuples, %NULL is returned when @type is the last item in a tuple.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType from a previous call
        /// </param>
        /// <returns>
        /// the next #GVariantType after @type, or %NULL
        /// 
        /// Since 2.24
        /// </returns>
        public GISharp.GLib.VariantType Next()
        {
            return default(GISharp.GLib.VariantType);
        }

        /// <summary>
        /// Returns the type string corresponding to the given @type.  The
        /// result is not nul-terminated; in order to determine its length you
        /// must call g_variant_type_get_string_length().
        /// </summary>
        /// <remarks>
        /// To get a nul-terminated string, see g_variant_type_dup_string().
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the corresponding type string (not nul-terminated)
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_peek_string(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Returns the type string corresponding to the given @type.  The
        /// result is not nul-terminated; in order to determine its length you
        /// must call g_variant_type_get_string_length().
        /// </summary>
        /// <remarks>
        /// To get a nul-terminated string, see g_variant_type_dup_string().
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the corresponding type string (not nul-terminated)
        /// 
        /// Since 2.24
        /// </returns>
        public System.String PeekString()
        {
            return default(System.String);
        }

        /// <summary>
        /// Determines the value type of a dictionary entry type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with a dictionary entry type.
        /// </remarks>
        /// <param name="type">
        /// a dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the value type of the dictionary entry
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_variant_type_value(
            [System.Runtime.InteropServices.In()] System.IntPtr type);

        /// <summary>
        /// Determines the value type of a dictionary entry type.
        /// </summary>
        /// <remarks>
        /// This function may only be used with a dictionary entry type.
        /// </remarks>
        /// <param name="type">
        /// a dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the value type of the dictionary entry
        /// 
        /// Since 2.24
        /// </returns>
        public GISharp.GLib.VariantType Value()
        {
            return default(GISharp.GLib.VariantType);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as GISharp.GLib.VariantType);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public static bool operator ==(GISharp.GLib.VariantType one, GISharp.GLib.VariantType two)
        {
            if ((object)one == null)
            {
                return (object)two == null;
            }
            return one.Equals(two);
        }

        public static bool operator !=(GISharp.GLib.VariantType one, GISharp.GLib.VariantType two)
        {
            return !(one == two);
        }
    }

    /// <summary>
    /// Declares a type of function which takes no arguments
    /// and has no return value. It is used to specify the type
    /// function passed to g_atexit().
    /// </summary>
    [GISharp.Core.GirXml("<callback name=\"VoidFunc\" c:type=\"GVoidFunc\" gs:managed-name=\"VoidFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Declares a type of function which takes no arguments\nand has no return value. It is used to specify the type\nfunction passed to g_atexit().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n</callback>")]
    [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public delegate void VoidFuncNative();

    /// <summary>
    /// Declares a type of function which takes no arguments
    /// and has no return value. It is used to specify the type
    /// function passed to g_atexit().
    /// </summary>
    [GISharp.Core.GirXml("<callback name=\"VoidFunc\" c:type=\"GVoidFunc\" gs:managed-name=\"VoidFunc\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n  <doc xml:space=\"preserve\">Declares a type of function which takes no arguments\nand has no return value. It is used to specify the type\nfunction passed to g_atexit().</doc>\n  <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n    <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n  </return-value>\n</callback>")]
    public delegate void VoidFunc();

    [GISharp.Core.GirXml("<gs:static-class name=\"Idle\" gs:managed-name=\"Idle\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\">\n  <function name=\"add_full\" c:identifier=\"g_idle_add_full\" shadows=\"add\" gs:managed-name=\"Add\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Adds a function to be called whenever there are no higher priority\nevents pending.  If the function returns %FALSE it is automatically\nremoved from the list of event sources and will not be called again.\n\nThis internally creates a main loop source using g_idle_source_new()\nand attaches it to the main loop context using g_source_attach().\nYou can do these steps manually if you need greater control.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the ID (greater than 0) of the event source.</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:default=\"Priority.Default\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the idle source. Typically this will be in the\n           range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"2\" destroy=\"3\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">function to call when the idle is removed, or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"2\" destroy=\"3\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:default=\"Priority.Default\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the idle source. Typically this will be in the\n           range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"remove_by_data\" c:identifier=\"g_idle_remove_by_data\" gs:managed-name=\"RemoveByData\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Removes the idle function with the given data.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Boolean\" gs:unmanaged-type=\"System.Boolean\">\n      <doc xml:space=\"preserve\">%TRUE if an idle source was found and removed.</doc>\n      <type name=\"gboolean\" c:type=\"gboolean\" gs:managed-name=\"Gboolean\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the idle source's callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the data for the idle source's callback.</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"source_new\" c:identifier=\"g_idle_source_new\" gs:managed-name=\"SourceNew\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Creates a new idle source.\n\nThe source will not initially be associated with any #GMainContext\nand must be added to one with g_source_attach() before it will be\nexecuted. Note that the default priority for idle sources is\n%G_PRIORITY_DEFAULT_IDLE, as compared to other sources which\nhave a default priority of %G_PRIORITY_DEFAULT.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly-created idle source</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n  </function>\n</gs:static-class>")]
    public static partial class Idle : System.Object
    {
        /// <summary>
        /// Adds a function to be called whenever there are no higher priority
        /// events pending.  If the function returns %FALSE it is automatically
        /// removed from the list of event sources and will not be called again.
        /// </summary>
        /// <remarks>
        /// This internally creates a main loop source using g_idle_source_new()
        /// and attaches it to the main loop context using g_source_attach().
        /// You can do these steps manually if you need greater control.
        /// </remarks>
        /// <param name="priority">
        /// the priority of the idle source. Typically this will be in the
        ///            range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the idle is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_idle_add_full(
            [System.Runtime.InteropServices.In()] System.Int32 priority,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc function,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify);

        /// <summary>
        /// Adds a function to be called whenever there are no higher priority
        /// events pending.  If the function returns %FALSE it is automatically
        /// removed from the list of event sources and will not be called again.
        /// </summary>
        /// <remarks>
        /// This internally creates a main loop source using g_idle_source_new()
        /// and attaches it to the main loop context using g_source_attach().
        /// You can do these steps manually if you need greater control.
        /// </remarks>
        /// <param name="priority">
        /// the priority of the idle source. Typically this will be in the
        ///            range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the idle is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        public static System.UInt32 Add(
            GISharp.GLib.SourceFunc function,
            System.Int32 priority = Priority.Default)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Removes the idle function with the given data.
        /// </summary>
        /// <param name="data">
        /// the data for the idle source's callback.
        /// </param>
        /// <returns>
        /// %TRUE if an idle source was found and removed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.Boolean g_idle_remove_by_data(
            [System.Runtime.InteropServices.In()] System.IntPtr data);

        /// <summary>
        /// Removes the idle function with the given data.
        /// </summary>
        /// <param name="data">
        /// the data for the idle source's callback.
        /// </param>
        /// <returns>
        /// %TRUE if an idle source was found and removed.
        /// </returns>
        public static System.Boolean RemoveByData(
            System.IntPtr data)
        {
            return default(System.Boolean);
        }

        /// <summary>
        /// Creates a new idle source.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed. Note that the default priority for idle sources is
        /// %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
        /// have a default priority of %G_PRIORITY_DEFAULT.
        /// </remarks>
        /// <returns>
        /// the newly-created idle source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_idle_source_new();

        /// <summary>
        /// Creates a new idle source.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed. Note that the default priority for idle sources is
        /// %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
        /// have a default priority of %G_PRIORITY_DEFAULT.
        /// </remarks>
        /// <returns>
        /// the newly-created idle source
        /// </returns>
        public static GISharp.GLib.Source SourceNew()
        {
            return default(GISharp.GLib.Source);
        }
    }

    [GISharp.Core.GirXml("<gs:static-class name=\"Log\" gs:managed-name=\"Log\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\">\n  <constant name=\"DOMAIN\" value=\"0\" c:type=\"G_LOG_DOMAIN\" gs:managed-name=\"Domain\" gs:managed-type=\"System.SByte\" gs:unmanaged-type=\"System.SByte\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Defines the log domain.\n\nFor applications, this is typically left as the default %NULL\n(or \"\") domain. Libraries should define this so that any messages\nwhich they log can be differentiated from messages from other\nlibraries and application code. But be careful not to define\nit in any public header files.\n\nFor example, GTK+ uses this in its Makefile.am:\n|[\nINCLUDES = -DG_LOG_DOMAIN=\\\"Gtk\\\"\n]|</doc>\n    <type name=\"gchar\" c:type=\"gchar\" gs:managed-name=\"Gchar\" />\n  </constant>\n  <constant name=\"FATAL_MASK\" value=\"0\" c:type=\"G_LOG_FATAL_MASK\" gs:managed-name=\"FatalMask\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">GLib log levels that are considered fatal by default.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"LEVEL_USER_SHIFT\" value=\"8\" c:type=\"G_LOG_LEVEL_USER_SHIFT\" gs:managed-name=\"LevelUserShift\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Log levels below 1&lt;&lt;G_LOG_LEVEL_USER_SHIFT are used by GLib.\nHigher bits can be used for user-defined log levels.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <function name=\"default_handler\" c:identifier=\"g_log_default_handler\" gs:managed-name=\"DefaultHandler\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">The default log handler set up by GLib; g_log_set_default_handler()\nallows to install an alternate default log handler.\nThis is used if no log handler has been set for the particular log\ndomain and log level combination. It outputs the message to stderr\nor stdout and if the log level is fatal it calls abort(). It automatically\nprints a new-line character after the message, so one does not need to be\nmanually included in @message.\n\nThe behavior of this log handler can be influenced by a number of\nenvironment variables:\n\n- `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which\n  messages should be prefixed by the program name and PID of the\n  aplication.\n\n- `G_MESSAGES_DEBUG`: A space-separated list of log domains for\n  which debug and informational messages are printed. By default\n  these messages are not printed.\n\nstderr is used for levels %G_LOG_LEVEL_ERROR, %G_LOG_LEVEL_CRITICAL,\n%G_LOG_LEVEL_WARNING and %G_LOG_LEVEL_MESSAGE. stdout is used for\nthe rest.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain of the message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the level of the message</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n      <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"unused_data\" transfer-ownership=\"none\" gs:managed-name=\"unusedData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data passed from g_log() which is unused</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain of the message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the level of the message</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n      <parameter name=\"message\" transfer-ownership=\"none\" gs:managed-name=\"message\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the message</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"unused_data\" transfer-ownership=\"none\" gs:managed-name=\"unusedData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data passed from g_log() which is unused</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"remove_handler\" c:identifier=\"g_log_remove_handler\" gs:managed-name=\"RemoveHandler\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Removes the log handler.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"handler_id\" transfer-ownership=\"none\" gs:managed-name=\"handlerId\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the id of the handler, which was returned\n    in g_log_set_handler()</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"handler_id\" transfer-ownership=\"none\" gs:managed-name=\"handlerId\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the id of the handler, which was returned\n    in g_log_set_handler()</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"set_always_fatal\" c:identifier=\"g_log_set_always_fatal\" gs:managed-name=\"SetAlwaysFatal\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Sets the message levels which are always fatal, in any log domain.\nWhen a message with any of these levels is logged the program terminates.\nYou can only set the levels defined by GLib to be fatal.\n%G_LOG_LEVEL_ERROR is always fatal.\n\nYou can also make some message levels fatal at runtime by setting\nthe `G_DEBUG` environment variable (see\n[Running GLib Applications](glib-running.html)).</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n      <doc xml:space=\"preserve\">the old fatal mask</doc>\n      <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"fatal_mask\" transfer-ownership=\"none\" gs:managed-name=\"fatalMask\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the mask containing bits set for each level\n    of error which is to be fatal</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"fatal_mask\" transfer-ownership=\"none\" gs:managed-name=\"fatalMask\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the mask containing bits set for each level\n    of error which is to be fatal</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"set_default_handler\" c:identifier=\"g_log_set_default_handler\" version=\"2.6\" introspectable=\"0\" gs:managed-name=\"SetDefaultHandler\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Installs a default log handler which is used if no\nlog handler has been set for the particular log domain\nand log level combination. By default, GLib uses\ng_log_default_handler() as default log handler.</doc>\n    <return-value gs:managed-type=\"LogFunc\" gs:unmanaged-type=\"LogFuncNative\">\n      <doc xml:space=\"preserve\">the previous default log handler</doc>\n      <type name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"log_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"logFunc\" gs:managed-type=\"LogFunc\" gs:unmanaged-type=\"LogFuncNative\">\n        <doc xml:space=\"preserve\">the log handler function</doc>\n        <type name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data passed to the log handler</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"log_func\" transfer-ownership=\"none\" closure=\"1\" gs:managed-name=\"logFunc\" gs:managed-type=\"LogFunc\" gs:unmanaged-type=\"LogFuncNative\">\n        <doc xml:space=\"preserve\">the log handler function</doc>\n        <type name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"set_fatal_mask\" c:identifier=\"g_log_set_fatal_mask\" gs:managed-name=\"SetFatalMask\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Sets the log levels which are fatal in the given domain.\n%G_LOG_LEVEL_ERROR is always fatal.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n      <doc xml:space=\"preserve\">the old fatal mask for the log domain</doc>\n      <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"fatal_mask\" transfer-ownership=\"none\" gs:managed-name=\"fatalMask\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the new fatal mask</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"fatal_mask\" transfer-ownership=\"none\" gs:managed-name=\"fatalMask\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the new fatal mask</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"set_handler\" c:identifier=\"g_log_set_handler\" introspectable=\"0\" gs:managed-name=\"SetHandler\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Sets the log handler for a domain and a set of log levels.\nTo handle fatal and recursive messages the @log_levels parameter\nmust be combined with the #G_LOG_FLAG_FATAL and #G_LOG_FLAG_RECURSION\nbit flags.\n\nNote that since the #G_LOG_LEVEL_ERROR log level is always fatal, if\nyou want to set a handler for this log level you must combine it with\n#G_LOG_FLAG_FATAL.\n\nHere is an example for adding a log handler for all warning messages\nin the default domain:\n|[&lt;!-- language=\"C\" --&gt;\ng_log_set_handler (NULL, G_LOG_LEVEL_WARNING | G_LOG_FLAG_FATAL\n                   | G_LOG_FLAG_RECURSION, my_log_handler, NULL);\n]|\n\nThis example adds a log handler for all critical messages from GTK+:\n|[&lt;!-- language=\"C\" --&gt;\ng_log_set_handler (\"Gtk\", G_LOG_LEVEL_CRITICAL | G_LOG_FLAG_FATAL\n                   | G_LOG_FLAG_RECURSION, my_log_handler, NULL);\n]|\n\nThis example adds a log handler for all messages from GLib:\n|[&lt;!-- language=\"C\" --&gt;\ng_log_set_handler (\"GLib\", G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL\n                   | G_LOG_FLAG_RECURSION, my_log_handler, NULL);\n]|</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the id of the new handler</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain, or %NULL for the default \"\"\n    application domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"log_levels\" transfer-ownership=\"none\" gs:managed-name=\"logLevels\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the log levels to apply the log handler for.\n    To handle fatal and recursive messages as well, combine\n    the log levels with the #G_LOG_FLAG_FATAL and\n    #G_LOG_FLAG_RECURSION bit flags.</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n      <parameter name=\"log_func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"logFunc\" gs:managed-type=\"LogFunc\" gs:unmanaged-type=\"LogFuncNative\">\n        <doc xml:space=\"preserve\">the log handler function</doc>\n        <type name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data passed to the log handler</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain, or %NULL for the default \"\"\n    application domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"log_levels\" transfer-ownership=\"none\" gs:managed-name=\"logLevels\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the log levels to apply the log handler for.\n    To handle fatal and recursive messages as well, combine\n    the log levels with the #G_LOG_FLAG_FATAL and\n    #G_LOG_FLAG_RECURSION bit flags.</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n      <parameter name=\"log_func\" transfer-ownership=\"none\" closure=\"3\" gs:managed-name=\"logFunc\" gs:managed-type=\"LogFunc\" gs:unmanaged-type=\"LogFuncNative\">\n        <doc xml:space=\"preserve\">the log handler function</doc>\n        <type name=\"LogFunc\" c:type=\"GLogFunc\" gs:managed-name=\"LogFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"logv\" c:identifier=\"g_logv\" introspectable=\"0\" gs:managed-name=\"Logv\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Logs an error or debugging message.\n\nIf the log level has been set as fatal, the abort()\nfunction is called to terminate the program.\n\nIf g_log_default_handler() is used as the log handler function, a new-line\ncharacter will automatically be appended to @..., and need not be entered\nmanually.</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.Void\" gs:unmanaged-type=\"System.Void\">\n      <type name=\"none\" c:type=\"void\" gs:managed-name=\"None\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the log level</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the message format. See the printf() documentation</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"args\" transfer-ownership=\"none\" gs:managed-name=\"args\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the parameters to insert into the format string</doc>\n        <type name=\"va_list\" c:type=\"va_list\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"log_domain\" transfer-ownership=\"none\" gs:managed-name=\"logDomain\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the log domain</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"log_level\" transfer-ownership=\"none\" gs:managed-name=\"logLevel\" gs:managed-type=\"LogLevelFlags\" gs:unmanaged-type=\"LogLevelFlags\">\n        <doc xml:space=\"preserve\">the log level</doc>\n        <type name=\"LogLevelFlags\" c:type=\"GLogLevelFlags\" gs:managed-name=\"LogLevelFlags\" />\n      </parameter>\n      <parameter name=\"format\" transfer-ownership=\"none\" gs:managed-name=\"format\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the message format. See the printf() documentation</doc>\n        <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n      </parameter>\n      <parameter name=\"args\" transfer-ownership=\"none\" gs:managed-name=\"args\" gs:managed-type=\"System.Object[]\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">the parameters to insert into the format string</doc>\n        <type name=\"va_list\" c:type=\"va_list\" gs:managed-name=\"VaList\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</gs:static-class>")]
    public static partial class Log : System.Object
    {
        /// <summary>
        /// Defines the log domain.
        /// </summary>
        /// <remarks>
        /// For applications, this is typically left as the default %NULL
        /// (or "") domain. Libraries should define this so that any messages
        /// which they log can be differentiated from messages from other
        /// libraries and application code. But be careful not to define
        /// it in any public header files.
        /// 
        /// For example, GTK+ uses this in its Makefile.am:
        /// |[
        /// INCLUDES = -DG_LOG_DOMAIN=\"Gtk\"
        /// ]|
        /// </remarks>
        public const System.SByte Domain = 0;

        /// <summary>
        /// GLib log levels that are considered fatal by default.
        /// </summary>
        public const System.Int32 FatalMask = 0;

        /// <summary>
        /// Log levels below 1&lt;&lt;G_LOG_LEVEL_USER_SHIFT are used by GLib.
        /// Higher bits can be used for user-defined log levels.
        /// </summary>
        public const System.Int32 LevelUserShift = 8;

        /// <summary>
        /// The default log handler set up by GLib; g_log_set_default_handler()
        /// allows to install an alternate default log handler.
        /// This is used if no log handler has been set for the particular log
        /// domain and log level combination. It outputs the message to stderr
        /// or stdout and if the log level is fatal it calls abort(). It automatically
        /// prints a new-line character after the message, so one does not need to be
        /// manually included in @message.
        /// </summary>
        /// <remarks>
        /// The behavior of this log handler can be influenced by a number of
        /// environment variables:
        /// 
        /// - `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which
        ///   messages should be prefixed by the program name and PID of the
        ///   aplication.
        /// 
        /// - `G_MESSAGES_DEBUG`: A space-separated list of log domains for
        ///   which debug and informational messages are printed. By default
        ///   these messages are not printed.
        /// 
        /// stderr is used for levels %G_LOG_LEVEL_ERROR, %G_LOG_LEVEL_CRITICAL,
        /// %G_LOG_LEVEL_WARNING and %G_LOG_LEVEL_MESSAGE. stdout is used for
        /// the rest.
        /// </remarks>
        /// <param name="logDomain">
        /// the log domain of the message
        /// </param>
        /// <param name="logLevel">
        /// the level of the message
        /// </param>
        /// <param name="message">
        /// the message
        /// </param>
        /// <param name="unusedData">
        /// data passed from g_log() which is unused
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_log_default_handler(
            [System.Runtime.InteropServices.In()] System.IntPtr logDomain,
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogLevelFlags logLevel,
            [System.Runtime.InteropServices.In()] System.IntPtr message,
            [System.Runtime.InteropServices.In()] System.IntPtr unusedData);

        /// <summary>
        /// The default log handler set up by GLib; g_log_set_default_handler()
        /// allows to install an alternate default log handler.
        /// This is used if no log handler has been set for the particular log
        /// domain and log level combination. It outputs the message to stderr
        /// or stdout and if the log level is fatal it calls abort(). It automatically
        /// prints a new-line character after the message, so one does not need to be
        /// manually included in @message.
        /// </summary>
        /// <remarks>
        /// The behavior of this log handler can be influenced by a number of
        /// environment variables:
        /// 
        /// - `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which
        ///   messages should be prefixed by the program name and PID of the
        ///   aplication.
        /// 
        /// - `G_MESSAGES_DEBUG`: A space-separated list of log domains for
        ///   which debug and informational messages are printed. By default
        ///   these messages are not printed.
        /// 
        /// stderr is used for levels %G_LOG_LEVEL_ERROR, %G_LOG_LEVEL_CRITICAL,
        /// %G_LOG_LEVEL_WARNING and %G_LOG_LEVEL_MESSAGE. stdout is used for
        /// the rest.
        /// </remarks>
        /// <param name="logDomain">
        /// the log domain of the message
        /// </param>
        /// <param name="logLevel">
        /// the level of the message
        /// </param>
        /// <param name="message">
        /// the message
        /// </param>
        /// <param name="unusedData">
        /// data passed from g_log() which is unused
        /// </param>
        public static void DefaultHandler(
            System.String logDomain,
            GISharp.GLib.LogLevelFlags logLevel,
            System.String message,
            System.IntPtr unusedData)
        {
        }

        /// <summary>
        /// Removes the log handler.
        /// </summary>
        /// <param name="logDomain">
        /// the log domain
        /// </param>
        /// <param name="handlerId">
        /// the id of the handler, which was returned
        ///     in g_log_set_handler()
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_log_remove_handler(
            [System.Runtime.InteropServices.In()] System.IntPtr logDomain,
            [System.Runtime.InteropServices.In()] System.UInt32 handlerId);

        /// <summary>
        /// Removes the log handler.
        /// </summary>
        /// <param name="logDomain">
        /// the log domain
        /// </param>
        /// <param name="handlerId">
        /// the id of the handler, which was returned
        ///     in g_log_set_handler()
        /// </param>
        public static void RemoveHandler(
            System.String logDomain,
            System.UInt32 handlerId)
        {
        }

        /// <summary>
        /// Sets the message levels which are always fatal, in any log domain.
        /// When a message with any of these levels is logged the program terminates.
        /// You can only set the levels defined by GLib to be fatal.
        /// %G_LOG_LEVEL_ERROR is always fatal.
        /// </summary>
        /// <remarks>
        /// You can also make some message levels fatal at runtime by setting
        /// the `G_DEBUG` environment variable (see
        /// [Running GLib Applications](glib-running.html)).
        /// </remarks>
        /// <param name="fatalMask">
        /// the mask containing bits set for each level
        ///     of error which is to be fatal
        /// </param>
        /// <returns>
        /// the old fatal mask
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.LogLevelFlags g_log_set_always_fatal(
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogLevelFlags fatalMask);

        /// <summary>
        /// Sets the message levels which are always fatal, in any log domain.
        /// When a message with any of these levels is logged the program terminates.
        /// You can only set the levels defined by GLib to be fatal.
        /// %G_LOG_LEVEL_ERROR is always fatal.
        /// </summary>
        /// <remarks>
        /// You can also make some message levels fatal at runtime by setting
        /// the `G_DEBUG` environment variable (see
        /// [Running GLib Applications](glib-running.html)).
        /// </remarks>
        /// <param name="fatalMask">
        /// the mask containing bits set for each level
        ///     of error which is to be fatal
        /// </param>
        /// <returns>
        /// the old fatal mask
        /// </returns>
        public static GISharp.GLib.LogLevelFlags SetAlwaysFatal(
            GISharp.GLib.LogLevelFlags fatalMask)
        {
            return default(GISharp.GLib.LogLevelFlags);
        }

        /// <summary>
        /// Installs a default log handler which is used if no
        /// log handler has been set for the particular log domain
        /// and log level combination. By default, GLib uses
        /// g_log_default_handler() as default log handler.
        /// </summary>
        /// <param name="logFunc">
        /// the log handler function
        /// </param>
        /// <param name="userData">
        /// data passed to the log handler
        /// </param>
        /// <returns>
        /// the previous default log handler
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern GISharp.GLib.LogFunc g_log_set_default_handler(
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogFunc logFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Installs a default log handler which is used if no
        /// log handler has been set for the particular log domain
        /// and log level combination. By default, GLib uses
        /// g_log_default_handler() as default log handler.
        /// </summary>
        /// <param name="logFunc">
        /// the log handler function
        /// </param>
        /// <param name="userData">
        /// data passed to the log handler
        /// </param>
        /// <returns>
        /// the previous default log handler
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public static GISharp.GLib.LogFunc SetDefaultHandler(
            GISharp.GLib.LogFunc logFunc)
        {
            return default(GISharp.GLib.LogFunc);
        }

        /// <summary>
        /// Sets the log levels which are fatal in the given domain.
        /// %G_LOG_LEVEL_ERROR is always fatal.
        /// </summary>
        /// <param name="logDomain">
        /// the log domain
        /// </param>
        /// <param name="fatalMask">
        /// the new fatal mask
        /// </param>
        /// <returns>
        /// the old fatal mask for the log domain
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern GISharp.GLib.LogLevelFlags g_log_set_fatal_mask(
            [System.Runtime.InteropServices.In()] System.IntPtr logDomain,
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogLevelFlags fatalMask);

        /// <summary>
        /// Sets the log levels which are fatal in the given domain.
        /// %G_LOG_LEVEL_ERROR is always fatal.
        /// </summary>
        /// <param name="logDomain">
        /// the log domain
        /// </param>
        /// <param name="fatalMask">
        /// the new fatal mask
        /// </param>
        /// <returns>
        /// the old fatal mask for the log domain
        /// </returns>
        public static GISharp.GLib.LogLevelFlags SetFatalMask(
            System.String logDomain,
            GISharp.GLib.LogLevelFlags fatalMask)
        {
            return default(GISharp.GLib.LogLevelFlags);
        }

        /// <summary>
        /// Sets the log handler for a domain and a set of log levels.
        /// To handle fatal and recursive messages the @log_levels parameter
        /// must be combined with the #G_LOG_FLAG_FATAL and #G_LOG_FLAG_RECURSION
        /// bit flags.
        /// </summary>
        /// <remarks>
        /// Note that since the #G_LOG_LEVEL_ERROR log level is always fatal, if
        /// you want to set a handler for this log level you must combine it with
        /// #G_LOG_FLAG_FATAL.
        /// 
        /// Here is an example for adding a log handler for all warning messages
        /// in the default domain:
        /// |[&lt;!-- language="C" --&gt;
        /// g_log_set_handler (NULL, G_LOG_LEVEL_WARNING | G_LOG_FLAG_FATAL
        ///                    | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
        /// ]|
        /// 
        /// This example adds a log handler for all critical messages from GTK+:
        /// |[&lt;!-- language="C" --&gt;
        /// g_log_set_handler ("Gtk", G_LOG_LEVEL_CRITICAL | G_LOG_FLAG_FATAL
        ///                    | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
        /// ]|
        /// 
        /// This example adds a log handler for all messages from GLib:
        /// |[&lt;!-- language="C" --&gt;
        /// g_log_set_handler ("GLib", G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL
        ///                    | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
        /// ]|
        /// </remarks>
        /// <param name="logDomain">
        /// the log domain, or %NULL for the default ""
        ///     application domain
        /// </param>
        /// <param name="logLevels">
        /// the log levels to apply the log handler for.
        ///     To handle fatal and recursive messages as well, combine
        ///     the log levels with the #G_LOG_FLAG_FATAL and
        ///     #G_LOG_FLAG_RECURSION bit flags.
        /// </param>
        /// <param name="logFunc">
        /// the log handler function
        /// </param>
        /// <param name="userData">
        /// data passed to the log handler
        /// </param>
        /// <returns>
        /// the id of the new handler
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_log_set_handler(
            [System.Runtime.InteropServices.In()] System.IntPtr logDomain,
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogLevelFlags logLevels,
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogFunc logFunc,
            [System.Runtime.InteropServices.In()] System.IntPtr userData);

        /// <summary>
        /// Sets the log handler for a domain and a set of log levels.
        /// To handle fatal and recursive messages the @log_levels parameter
        /// must be combined with the #G_LOG_FLAG_FATAL and #G_LOG_FLAG_RECURSION
        /// bit flags.
        /// </summary>
        /// <remarks>
        /// Note that since the #G_LOG_LEVEL_ERROR log level is always fatal, if
        /// you want to set a handler for this log level you must combine it with
        /// #G_LOG_FLAG_FATAL.
        /// 
        /// Here is an example for adding a log handler for all warning messages
        /// in the default domain:
        /// |[&lt;!-- language="C" --&gt;
        /// g_log_set_handler (NULL, G_LOG_LEVEL_WARNING | G_LOG_FLAG_FATAL
        ///                    | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
        /// ]|
        /// 
        /// This example adds a log handler for all critical messages from GTK+:
        /// |[&lt;!-- language="C" --&gt;
        /// g_log_set_handler ("Gtk", G_LOG_LEVEL_CRITICAL | G_LOG_FLAG_FATAL
        ///                    | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
        /// ]|
        /// 
        /// This example adds a log handler for all messages from GLib:
        /// |[&lt;!-- language="C" --&gt;
        /// g_log_set_handler ("GLib", G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL
        ///                    | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
        /// ]|
        /// </remarks>
        /// <param name="logDomain">
        /// the log domain, or %NULL for the default ""
        ///     application domain
        /// </param>
        /// <param name="logLevels">
        /// the log levels to apply the log handler for.
        ///     To handle fatal and recursive messages as well, combine
        ///     the log levels with the #G_LOG_FLAG_FATAL and
        ///     #G_LOG_FLAG_RECURSION bit flags.
        /// </param>
        /// <param name="logFunc">
        /// the log handler function
        /// </param>
        /// <param name="userData">
        /// data passed to the log handler
        /// </param>
        /// <returns>
        /// the id of the new handler
        /// </returns>
        public static System.UInt32 SetHandler(
            System.String logDomain,
            GISharp.GLib.LogLevelFlags logLevels,
            GISharp.GLib.LogFunc logFunc)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Logs an error or debugging message.
        /// </summary>
        /// <remarks>
        /// If the log level has been set as fatal, the abort()
        /// function is called to terminate the program.
        /// 
        /// If g_log_default_handler() is used as the log handler function, a new-line
        /// character will automatically be appended to @..., and need not be entered
        /// manually.
        /// </remarks>
        /// <param name="logDomain">
        /// the log domain
        /// </param>
        /// <param name="logLevel">
        /// the log level
        /// </param>
        /// <param name="format">
        /// the message format. See the printf() documentation
        /// </param>
        /// <param name="args">
        /// the parameters to insert into the format string
        /// </param>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern void g_logv(
            [System.Runtime.InteropServices.In()] System.IntPtr logDomain,
            [System.Runtime.InteropServices.In()] GISharp.GLib.LogLevelFlags logLevel,
            [System.Runtime.InteropServices.In()] System.IntPtr format,
            [System.Runtime.InteropServices.In()] System.IntPtr args);

        /// <summary>
        /// Logs an error or debugging message.
        /// </summary>
        /// <remarks>
        /// If the log level has been set as fatal, the abort()
        /// function is called to terminate the program.
        /// 
        /// If g_log_default_handler() is used as the log handler function, a new-line
        /// character will automatically be appended to @..., and need not be entered
        /// manually.
        /// </remarks>
        /// <param name="logDomain">
        /// the log domain
        /// </param>
        /// <param name="logLevel">
        /// the log level
        /// </param>
        /// <param name="format">
        /// the message format. See the printf() documentation
        /// </param>
        /// <param name="args">
        /// the parameters to insert into the format string
        /// </param>
        public static void Logv(
            System.String logDomain,
            GISharp.GLib.LogLevelFlags logLevel,
            System.String format,
            System.Object[] args)
        {
        }
    }

    [GISharp.Core.GirXml("<gs:static-class name=\"Priority\" gs:managed-name=\"Priority\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\">\n  <constant name=\"DEFAULT\" value=\"0\" c:type=\"G_PRIORITY_DEFAULT\" gs:managed-name=\"Default\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Use this for default priority event sources.\n\nIn GLib this priority is used when adding timeout functions\nwith g_timeout_add(). In GDK this priority is used for events\nfrom the X server.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"DEFAULT_IDLE\" value=\"200\" c:type=\"G_PRIORITY_DEFAULT_IDLE\" gs:managed-name=\"DefaultIdle\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Use this for default priority idle functions.\n\nIn GLib this priority is used when adding idle functions with\ng_idle_add().</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"HIGH\" value=\"-100\" c:type=\"G_PRIORITY_HIGH\" gs:managed-name=\"High\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Use this for high priority event sources.\n\nIt is not used within GLib or GTK+.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"HIGH_IDLE\" value=\"100\" c:type=\"G_PRIORITY_HIGH_IDLE\" gs:managed-name=\"HighIdle\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Use this for high priority idle functions.\n\nGTK+ uses #G_PRIORITY_HIGH_IDLE + 10 for resizing operations,\nand #G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is\ndone to ensure that any pending resizes are processed before any\npending redraws, so that widgets are not redrawn twice unnecessarily.)</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"LOW\" value=\"300\" c:type=\"G_PRIORITY_LOW\" gs:managed-name=\"Low\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Use this for very low priority background tasks.\n\nIt is not used within GLib or GTK+.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n</gs:static-class>")]
    public static partial class Priority : System.Object
    {
        /// <summary>
        /// Use this for default priority event sources.
        /// </summary>
        /// <remarks>
        /// In GLib this priority is used when adding timeout functions
        /// with g_timeout_add(). In GDK this priority is used for events
        /// from the X server.
        /// </remarks>
        public const System.Int32 Default = 0;

        /// <summary>
        /// Use this for default priority idle functions.
        /// </summary>
        /// <remarks>
        /// In GLib this priority is used when adding idle functions with
        /// g_idle_add().
        /// </remarks>
        public const System.Int32 DefaultIdle = 200;

        /// <summary>
        /// Use this for high priority event sources.
        /// </summary>
        /// <remarks>
        /// It is not used within GLib or GTK+.
        /// </remarks>
        public const System.Int32 High = -100;

        /// <summary>
        /// Use this for high priority idle functions.
        /// </summary>
        /// <remarks>
        /// GTK+ uses #G_PRIORITY_HIGH_IDLE + 10 for resizing operations,
        /// and #G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is
        /// done to ensure that any pending resizes are processed before any
        /// pending redraws, so that widgets are not redrawn twice unnecessarily.)
        /// </remarks>
        public const System.Int32 HighIdle = 100;

        /// <summary>
        /// Use this for very low priority background tasks.
        /// </summary>
        /// <remarks>
        /// It is not used within GLib or GTK+.
        /// </remarks>
        public const System.Int32 Low = 300;
    }

    [GISharp.Core.GirXml("<gs:static-class name=\"Timeout\" gs:managed-name=\"Timeout\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\">\n  <function name=\"add_full\" c:identifier=\"g_timeout_add_full\" shadows=\"add\" gs:managed-name=\"Add\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Sets a function to be called at regular intervals, with the given\npriority.  The function is called repeatedly until it returns\n%FALSE, at which point the timeout is automatically destroyed and\nthe function will not be called again.  The @notify function is\ncalled when the timeout is destroyed.  The first call to the\nfunction will be at the end of the first @interval.\n\nNote that timeout functions may be delayed, due to the processing of other\nevent sources. Thus they should not be relied on for precise timing.\nAfter each call to the timeout function, the time of the next\ntimeout is recalculated based on the current time and the given interval\n(it does not try to 'catch up' time lost in delays).\n\nThis internally creates a main loop source using g_timeout_source_new()\nand attaches it to the main loop context using g_source_attach(). You can\ndo these steps manually if you need greater control.\n\nThe interval given in terms of monotonic time, not wall clock time.\nSee g_get_monotonic_time().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the ID (greater than 0) of the event source.</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:default=\"Priority.Default\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the timeout source. Typically this will be in\n           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the time between calls to the function, in milliseconds\n            (1/1000ths of a second)</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"3\" destroy=\"4\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">function to call when the timeout is removed, or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the time between calls to the function, in milliseconds\n            (1/1000ths of a second)</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"3\" destroy=\"4\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:default=\"Priority.Default\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the timeout source. Typically this will be in\n           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"add_seconds_full\" c:identifier=\"g_timeout_add_seconds_full\" shadows=\"add_seconds\" version=\"2.14\" gs:managed-name=\"AddSeconds\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Sets a function to be called at regular intervals, with @priority.\nThe function is called repeatedly until it returns %FALSE, at which\npoint the timeout is automatically destroyed and the function will\nnot be called again.\n\nUnlike g_timeout_add(), this function operates at whole second granularity.\nThe initial starting point of the timer is determined by the implementation\nand the implementation is expected to group multiple timers together so that\nthey fire all at the same time.\nTo allow this grouping, the @interval to the first timer is rounded\nand can deviate up to one second from the specified interval.\nSubsequent timer iterations will generally run at the specified interval.\n\nNote that timeout functions may be delayed, due to the processing of other\nevent sources. Thus they should not be relied on for precise timing.\nAfter each call to the timeout function, the time of the next\ntimeout is recalculated based on the current time and the given @interval\n\nIf you want timing more precise than whole seconds, use g_timeout_add()\ninstead.\n\nThe grouping of timers to fire at the same time results in a more power\nand CPU efficient behavior so if your timer is in multiples of seconds\nand you don't require the first timer exactly one second from now, the\nuse of g_timeout_add_seconds() is preferred over g_timeout_add().\n\nThis internally creates a main loop source using\ng_timeout_source_new_seconds() and attaches it to the main loop context\nusing g_source_attach(). You can do these steps manually if you need\ngreater control.\n\nThe interval given is in terms of monotonic time, not wall clock\ntime.  See g_get_monotonic_time().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">the ID (greater than 0) of the event source.</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:default=\"Priority.Default\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the timeout source. Typically this will be in\n           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the time between calls to the function, in seconds</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"3\" destroy=\"4\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"data\" transfer-ownership=\"none\" gs:managed-name=\"data\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">data to pass to @function</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" nullable=\"1\" allow-none=\"1\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">function to call when the timeout is removed, or %NULL</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the time between calls to the function, in seconds</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"function\" transfer-ownership=\"none\" scope=\"notified\" closure=\"3\" destroy=\"4\" gs:managed-name=\"function\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">function to call</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:default=\"Priority.Default\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the timeout source. Typically this will be in\n           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"source_new\" c:identifier=\"g_timeout_source_new\" gs:managed-name=\"SourceNew\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Creates a new timeout source.\n\nThe source will not initially be associated with any #GMainContext\nand must be added to one with g_source_attach() before it will be\nexecuted.\n\nThe interval given is in terms of monotonic time, not wall clock\ntime.  See g_get_monotonic_time().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly-created timeout source</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the timeout interval in milliseconds.</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the timeout interval in milliseconds.</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"source_new_seconds\" c:identifier=\"g_timeout_source_new_seconds\" version=\"2.14\" gs:managed-name=\"SourceNewSeconds\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Creates a new timeout source.\n\nThe source will not initially be associated with any #GMainContext\nand must be added to one with g_source_attach() before it will be\nexecuted.\n\nThe scheduling granularity/accuracy of this timeout source will be\nin seconds.\n\nThe interval given in terms of monotonic time, not wall clock time.\nSee g_get_monotonic_time().</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">the newly-created timeout source</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the timeout interval in seconds</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"interval\" transfer-ownership=\"none\" gs:managed-name=\"interval\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the timeout interval in seconds</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</gs:static-class>")]
    public static partial class Timeout : System.Object
    {
        /// <summary>
        /// Sets a function to be called at regular intervals, with the given
        /// priority.  The function is called repeatedly until it returns
        /// %FALSE, at which point the timeout is automatically destroyed and
        /// the function will not be called again.  The @notify function is
        /// called when the timeout is destroyed.  The first call to the
        /// function will be at the end of the first @interval.
        /// </summary>
        /// <remarks>
        /// Note that timeout functions may be delayed, due to the processing of other
        /// event sources. Thus they should not be relied on for precise timing.
        /// After each call to the timeout function, the time of the next
        /// timeout is recalculated based on the current time and the given interval
        /// (it does not try to 'catch up' time lost in delays).
        /// 
        /// This internally creates a main loop source using g_timeout_source_new()
        /// and attaches it to the main loop context using g_source_attach(). You can
        /// do these steps manually if you need greater control.
        /// 
        /// The interval given in terms of monotonic time, not wall clock time.
        /// See g_get_monotonic_time().
        /// </remarks>
        /// <param name="priority">
        /// the priority of the timeout source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="interval">
        /// the time between calls to the function, in milliseconds
        ///             (1/1000ths of a second)
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the timeout is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.UInt32 g_timeout_add_full(
            [System.Runtime.InteropServices.In()] System.Int32 priority,
            [System.Runtime.InteropServices.In()] System.UInt32 interval,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc function,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify);

        /// <summary>
        /// Sets a function to be called at regular intervals, with the given
        /// priority.  The function is called repeatedly until it returns
        /// %FALSE, at which point the timeout is automatically destroyed and
        /// the function will not be called again.  The @notify function is
        /// called when the timeout is destroyed.  The first call to the
        /// function will be at the end of the first @interval.
        /// </summary>
        /// <remarks>
        /// Note that timeout functions may be delayed, due to the processing of other
        /// event sources. Thus they should not be relied on for precise timing.
        /// After each call to the timeout function, the time of the next
        /// timeout is recalculated based on the current time and the given interval
        /// (it does not try to 'catch up' time lost in delays).
        /// 
        /// This internally creates a main loop source using g_timeout_source_new()
        /// and attaches it to the main loop context using g_source_attach(). You can
        /// do these steps manually if you need greater control.
        /// 
        /// The interval given in terms of monotonic time, not wall clock time.
        /// See g_get_monotonic_time().
        /// </remarks>
        /// <param name="priority">
        /// the priority of the timeout source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="interval">
        /// the time between calls to the function, in milliseconds
        ///             (1/1000ths of a second)
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the timeout is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        public static System.UInt32 Add(
            System.UInt32 interval,
            GISharp.GLib.SourceFunc function,
            System.Int32 priority = Priority.Default)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Sets a function to be called at regular intervals, with @priority.
        /// The function is called repeatedly until it returns %FALSE, at which
        /// point the timeout is automatically destroyed and the function will
        /// not be called again.
        /// </summary>
        /// <remarks>
        /// Unlike g_timeout_add(), this function operates at whole second granularity.
        /// The initial starting point of the timer is determined by the implementation
        /// and the implementation is expected to group multiple timers together so that
        /// they fire all at the same time.
        /// To allow this grouping, the @interval to the first timer is rounded
        /// and can deviate up to one second from the specified interval.
        /// Subsequent timer iterations will generally run at the specified interval.
        /// 
        /// Note that timeout functions may be delayed, due to the processing of other
        /// event sources. Thus they should not be relied on for precise timing.
        /// After each call to the timeout function, the time of the next
        /// timeout is recalculated based on the current time and the given @interval
        /// 
        /// If you want timing more precise than whole seconds, use g_timeout_add()
        /// instead.
        /// 
        /// The grouping of timers to fire at the same time results in a more power
        /// and CPU efficient behavior so if your timer is in multiples of seconds
        /// and you don't require the first timer exactly one second from now, the
        /// use of g_timeout_add_seconds() is preferred over g_timeout_add().
        /// 
        /// This internally creates a main loop source using
        /// g_timeout_source_new_seconds() and attaches it to the main loop context
        /// using g_source_attach(). You can do these steps manually if you need
        /// greater control.
        /// 
        /// The interval given is in terms of monotonic time, not wall clock
        /// time.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="priority">
        /// the priority of the timeout source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="interval">
        /// the time between calls to the function, in seconds
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the timeout is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.UInt32 g_timeout_add_seconds_full(
            [System.Runtime.InteropServices.In()] System.Int32 priority,
            [System.Runtime.InteropServices.In()] System.UInt32 interval,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc function,
            [System.Runtime.InteropServices.In()] System.IntPtr data,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify);

        /// <summary>
        /// Sets a function to be called at regular intervals, with @priority.
        /// The function is called repeatedly until it returns %FALSE, at which
        /// point the timeout is automatically destroyed and the function will
        /// not be called again.
        /// </summary>
        /// <remarks>
        /// Unlike g_timeout_add(), this function operates at whole second granularity.
        /// The initial starting point of the timer is determined by the implementation
        /// and the implementation is expected to group multiple timers together so that
        /// they fire all at the same time.
        /// To allow this grouping, the @interval to the first timer is rounded
        /// and can deviate up to one second from the specified interval.
        /// Subsequent timer iterations will generally run at the specified interval.
        /// 
        /// Note that timeout functions may be delayed, due to the processing of other
        /// event sources. Thus they should not be relied on for precise timing.
        /// After each call to the timeout function, the time of the next
        /// timeout is recalculated based on the current time and the given @interval
        /// 
        /// If you want timing more precise than whole seconds, use g_timeout_add()
        /// instead.
        /// 
        /// The grouping of timers to fire at the same time results in a more power
        /// and CPU efficient behavior so if your timer is in multiples of seconds
        /// and you don't require the first timer exactly one second from now, the
        /// use of g_timeout_add_seconds() is preferred over g_timeout_add().
        /// 
        /// This internally creates a main loop source using
        /// g_timeout_source_new_seconds() and attaches it to the main loop context
        /// using g_source_attach(). You can do these steps manually if you need
        /// greater control.
        /// 
        /// The interval given is in terms of monotonic time, not wall clock
        /// time.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="priority">
        /// the priority of the timeout source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="interval">
        /// the time between calls to the function, in seconds
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the timeout is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public static System.UInt32 AddSeconds(
            System.UInt32 interval,
            GISharp.GLib.SourceFunc function,
            System.Int32 priority = Priority.Default)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Creates a new timeout source.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// 
        /// The interval given is in terms of monotonic time, not wall clock
        /// time.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="interval">
        /// the timeout interval in milliseconds.
        /// </param>
        /// <returns>
        /// the newly-created timeout source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        static extern System.IntPtr g_timeout_source_new(
            [System.Runtime.InteropServices.In()] System.UInt32 interval);

        /// <summary>
        /// Creates a new timeout source.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// 
        /// The interval given is in terms of monotonic time, not wall clock
        /// time.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="interval">
        /// the timeout interval in milliseconds.
        /// </param>
        /// <returns>
        /// the newly-created timeout source
        /// </returns>
        public static GISharp.GLib.Source SourceNew(
            System.UInt32 interval)
        {
            return default(GISharp.GLib.Source);
        }

        /// <summary>
        /// Creates a new timeout source.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// 
        /// The scheduling granularity/accuracy of this timeout source will be
        /// in seconds.
        /// 
        /// The interval given in terms of monotonic time, not wall clock time.
        /// See g_get_monotonic_time().
        /// </remarks>
        /// <param name="interval">
        /// the timeout interval in seconds
        /// </param>
        /// <returns>
        /// the newly-created timeout source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.14")]
        static extern System.IntPtr g_timeout_source_new_seconds(
            [System.Runtime.InteropServices.In()] System.UInt32 interval);

        /// <summary>
        /// Creates a new timeout source.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// 
        /// The scheduling granularity/accuracy of this timeout source will be
        /// in seconds.
        /// 
        /// The interval given in terms of monotonic time, not wall clock time.
        /// See g_get_monotonic_time().
        /// </remarks>
        /// <param name="interval">
        /// the timeout interval in seconds
        /// </param>
        /// <returns>
        /// the newly-created timeout source
        /// </returns>
        [GISharp.Core.Since("2.14")]
        public static GISharp.GLib.Source SourceNewSeconds(
            System.UInt32 interval)
        {
            return default(GISharp.GLib.Source);
        }
    }

    [GISharp.Core.GirXml("<gs:static-class name=\"UnixSignal\" gs:managed-name=\"UnixSignal\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\">\n  <function name=\"add_full\" c:identifier=\"g_unix_signal_add_full\" shadows=\"add\" version=\"2.30\" skip=\"0\" gs:managed-name=\"Add\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">A convenience function for g_unix_signal_source_new(), which\nattaches to the default #GMainContext.  You can remove the watch\nusing g_source_remove().</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n      <doc xml:space=\"preserve\">An ID (greater than 0) for the event source</doc>\n      <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the signal source. Typically this will be in\n           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"signum\" transfer-ownership=\"none\" gs:managed-name=\"signum\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">Signal number</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"handler\" transfer-ownership=\"none\" scope=\"notified\" closure=\"3\" destroy=\"4\" gs:managed-name=\"handler\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">Callback</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n      <parameter name=\"user_data\" transfer-ownership=\"none\" gs:managed-name=\"userData\" gs:managed-type=\"System.IntPtr\" gs:unmanaged-type=\"System.IntPtr\">\n        <doc xml:space=\"preserve\">Data for @handler</doc>\n        <type name=\"gpointer\" c:type=\"gpointer\" gs:managed-name=\"Gpointer\" />\n      </parameter>\n      <parameter name=\"notify\" transfer-ownership=\"none\" scope=\"async\" gs:managed-name=\"notify\" gs:managed-type=\"DestroyNotify\" gs:unmanaged-type=\"DestroyNotifyNative\">\n        <doc xml:space=\"preserve\">#GDestroyNotify for @handler</doc>\n        <type name=\"DestroyNotify\" c:type=\"GDestroyNotify\" gs:managed-name=\"DestroyNotify\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"priority\" transfer-ownership=\"none\" gs:managed-name=\"priority\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">the priority of the signal source. Typically this will be in\n           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"signum\" transfer-ownership=\"none\" gs:managed-name=\"signum\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">Signal number</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n      <parameter name=\"handler\" transfer-ownership=\"none\" scope=\"notified\" closure=\"3\" destroy=\"4\" gs:managed-name=\"handler\" gs:managed-type=\"SourceFunc\" gs:unmanaged-type=\"SourceFuncNative\">\n        <doc xml:space=\"preserve\">Callback</doc>\n        <type name=\"SourceFunc\" c:type=\"GSourceFunc\" gs:managed-name=\"SourceFunc\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n  <function name=\"source_new\" c:identifier=\"g_unix_signal_source_new\" version=\"2.30\" skip=\"0\" gs:managed-name=\"SourceNew\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Create a #GSource that will be dispatched upon delivery of the UNIX\nsignal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,\n`SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`\nwere added.\n\nNote that unlike the UNIX default, all sources which have created a\nwatch will be dispatched, regardless of which underlying thread\ninvoked g_unix_signal_source_new().\n\nFor example, an effective use of this function is to handle `SIGTERM`\ncleanly; flushing any outstanding files, and then calling\ng_main_loop_quit ().  It is not safe to do any of this a regular\nUNIX signal handler; your handler may be invoked while malloc() or\nanother library function is running, causing reentrancy if you\nattempt to use it from the handler.  None of the GLib/GObject API\nis safe against this kind of reentrancy.\n\nThe interaction of this source when combined with native UNIX\nfunctions like sigprocmask() is not defined.\n\nThe source will not initially be associated with any #GMainContext\nand must be added to one with g_source_attach() before it will be\nexecuted.</doc>\n    <return-value transfer-ownership=\"full\" gs:managed-type=\"Source\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">A newly created #GSource</doc>\n      <type name=\"Source\" c:type=\"GSource*\" gs:managed-name=\"Source\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"signum\" transfer-ownership=\"none\" gs:managed-name=\"signum\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">A signal number</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"signum\" transfer-ownership=\"none\" gs:managed-name=\"signum\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\">\n        <doc xml:space=\"preserve\">A signal number</doc>\n        <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</gs:static-class>")]
    public static partial class UnixSignal : System.Object
    {
        /// <summary>
        /// A convenience function for g_unix_signal_source_new(), which
        /// attaches to the default #GMainContext.  You can remove the watch
        /// using g_source_remove().
        /// </summary>
        /// <param name="priority">
        /// the priority of the signal source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="signum">
        /// Signal number
        /// </param>
        /// <param name="handler">
        /// Callback
        /// </param>
        /// <param name="userData">
        /// Data for @handler
        /// </param>
        /// <param name="notify">
        /// #GDestroyNotify for @handler
        /// </param>
        /// <returns>
        /// An ID (greater than 0) for the event source
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.30")]
        static extern System.UInt32 g_unix_signal_add_full(
            [System.Runtime.InteropServices.In()] System.Int32 priority,
            [System.Runtime.InteropServices.In()] System.Int32 signum,
            [System.Runtime.InteropServices.In()] GISharp.GLib.SourceFunc handler,
            [System.Runtime.InteropServices.In()] System.IntPtr userData,
            [System.Runtime.InteropServices.In()] GISharp.GLib.DestroyNotify notify);

        /// <summary>
        /// A convenience function for g_unix_signal_source_new(), which
        /// attaches to the default #GMainContext.  You can remove the watch
        /// using g_source_remove().
        /// </summary>
        /// <param name="priority">
        /// the priority of the signal source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="signum">
        /// Signal number
        /// </param>
        /// <param name="handler">
        /// Callback
        /// </param>
        /// <param name="userData">
        /// Data for @handler
        /// </param>
        /// <param name="notify">
        /// #GDestroyNotify for @handler
        /// </param>
        /// <returns>
        /// An ID (greater than 0) for the event source
        /// </returns>
        [GISharp.Core.Since("2.30")]
        public static System.UInt32 Add(
            System.Int32 priority,
            System.Int32 signum,
            GISharp.GLib.SourceFunc handler)
        {
            return default(System.UInt32);
        }

        /// <summary>
        /// Create a #GSource that will be dispatched upon delivery of the UNIX
        /// signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
        /// `SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
        /// were added.
        /// </summary>
        /// <remarks>
        /// Note that unlike the UNIX default, all sources which have created a
        /// watch will be dispatched, regardless of which underlying thread
        /// invoked g_unix_signal_source_new().
        /// 
        /// For example, an effective use of this function is to handle `SIGTERM`
        /// cleanly; flushing any outstanding files, and then calling
        /// g_main_loop_quit ().  It is not safe to do any of this a regular
        /// UNIX signal handler; your handler may be invoked while malloc() or
        /// another library function is running, causing reentrancy if you
        /// attempt to use it from the handler.  None of the GLib/GObject API
        /// is safe against this kind of reentrancy.
        /// 
        /// The interaction of this source when combined with native UNIX
        /// functions like sigprocmask() is not defined.
        /// 
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// </remarks>
        /// <param name="signum">
        /// A signal number
        /// </param>
        /// <returns>
        /// A newly created #GSource
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.30")]
        static extern System.IntPtr g_unix_signal_source_new(
            [System.Runtime.InteropServices.In()] System.Int32 signum);

        /// <summary>
        /// Create a #GSource that will be dispatched upon delivery of the UNIX
        /// signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
        /// `SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
        /// were added.
        /// </summary>
        /// <remarks>
        /// Note that unlike the UNIX default, all sources which have created a
        /// watch will be dispatched, regardless of which underlying thread
        /// invoked g_unix_signal_source_new().
        /// 
        /// For example, an effective use of this function is to handle `SIGTERM`
        /// cleanly; flushing any outstanding files, and then calling
        /// g_main_loop_quit ().  It is not safe to do any of this a regular
        /// UNIX signal handler; your handler may be invoked while malloc() or
        /// another library function is running, causing reentrancy if you
        /// attempt to use it from the handler.  None of the GLib/GObject API
        /// is safe against this kind of reentrancy.
        /// 
        /// The interaction of this source when combined with native UNIX
        /// functions like sigprocmask() is not defined.
        /// 
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// </remarks>
        /// <param name="signum">
        /// A signal number
        /// </param>
        /// <returns>
        /// A newly created #GSource
        /// </returns>
        [GISharp.Core.Since("2.30")]
        public static GISharp.GLib.Source SourceNew(
            System.Int32 signum)
        {
            return default(GISharp.GLib.Source);
        }
    }

    [GISharp.Core.GirXml("<gs:static-class name=\"Version\" gs:managed-name=\"Version\" xmlns:gs=\"http://gisharp.org/introspection/gisharp/1.0\">\n  <constant name=\"MAJOR_\" value=\"2\" c:type=\"GLIB_MAJOR_VERSION\" gs:managed-name=\"Major\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">The major version number of the GLib library.\n\nLike #glib_major_version, but from the headers used at\napplication compile time, rather than from the library\nlinked against at application run time.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"MICRO_\" value=\"1\" c:type=\"GLIB_MICRO_VERSION\" gs:managed-name=\"Micro\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">The micro version number of the GLib library.\n\nLike #gtk_micro_version, but from the headers used at\napplication compile time, rather than from the library\nlinked against at application run time.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"MINOR_\" value=\"42\" c:type=\"GLIB_MINOR_VERSION\" gs:managed-name=\"Minor\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">The minor version number of the GLib library.\n\nLike #gtk_minor_version, but from the headers used at\napplication compile time, rather than from the library\nlinked against at application run time.</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <constant name=\"MIN_REQUIRED\" value=\"2\" c:type=\"GLIB_VERSION_MIN_REQUIRED\" version=\"2.32\" gs:managed-name=\"MinRequired\" gs:managed-type=\"System.Int32\" gs:unmanaged-type=\"System.Int32\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">A macro that should be defined by the user prior to including\nthe glib.h header.\nThe definition should be one of the predefined GLib version\nmacros: %GLIB_VERSION_2_26, %GLIB_VERSION_2_28,...\n\nThis macro defines the earliest version of GLib that the package is\nrequired to be able to compile against.\n\nIf the compiler is configured to warn about the use of deprecated\nfunctions, then using functions that were deprecated in version\n%GLIB_VERSION_MIN_REQUIRED or earlier will cause warnings (but\nusing functions deprecated in later releases will not).</doc>\n    <type name=\"gint\" c:type=\"gint\" gs:managed-name=\"Gint\" />\n  </constant>\n  <function name=\"check\" c:identifier=\"glib_check_version\" version=\"2.6\" gs:managed-name=\"Check\" xmlns:c=\"http://www.gtk.org/introspection/c/1.0\" xmlns=\"http://www.gtk.org/introspection/core/1.0\">\n    <doc xml:space=\"preserve\">Checks that the GLib library in use is compatible with the\ngiven version. Generally you would pass in the constants\n#GLIB_MAJOR_VERSION, #GLIB_MINOR_VERSION, #GLIB_MICRO_VERSION\nas the three arguments to this function; that produces\na check that the library in use is compatible with\nthe version of GLib the application or module was compiled\nagainst.\n\nCompatibility is defined by two things: first the version\nof the running library is newer than the version\n@required_major.required_minor.@required_micro. Second\nthe running library must be binary compatible with the\nversion @required_major.required_minor.@required_micro\n(same major version.)</doc>\n    <return-value transfer-ownership=\"none\" gs:managed-type=\"System.String\" gs:unmanaged-type=\"System.IntPtr\">\n      <doc xml:space=\"preserve\">%NULL if the GLib library is compatible with the\n    given version, or a string describing the version mismatch.\n    The returned string is owned by GLib and must not be modified\n    or freed.</doc>\n      <type name=\"utf8\" c:type=\"const gchar*\" gs:managed-name=\"Utf8\" />\n    </return-value>\n    <parameters>\n      <parameter name=\"required_major\" transfer-ownership=\"none\" gs:managed-name=\"requiredMajor\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the required major version</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"required_minor\" transfer-ownership=\"none\" gs:managed-name=\"requiredMinor\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the required minor version</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"required_micro\" transfer-ownership=\"none\" gs:managed-name=\"requiredMicro\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the required micro version</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </parameters>\n    <gs:managed-parameters>\n      <parameter name=\"required_major\" transfer-ownership=\"none\" gs:managed-name=\"requiredMajor\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the required major version</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"required_minor\" transfer-ownership=\"none\" gs:managed-name=\"requiredMinor\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the required minor version</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n      <parameter name=\"required_micro\" transfer-ownership=\"none\" gs:managed-name=\"requiredMicro\" gs:managed-type=\"System.UInt32\" gs:unmanaged-type=\"System.UInt32\">\n        <doc xml:space=\"preserve\">the required micro version</doc>\n        <type name=\"guint\" c:type=\"guint\" gs:managed-name=\"Guint\" />\n      </parameter>\n    </gs:managed-parameters>\n  </function>\n</gs:static-class>")]
    public static partial class Version : System.Object
    {
        /// <summary>
        /// The major version number of the GLib library.
        /// </summary>
        /// <remarks>
        /// Like #glib_major_version, but from the headers used at
        /// application compile time, rather than from the library
        /// linked against at application run time.
        /// </remarks>
        public const System.Int32 Major = 2;

        /// <summary>
        /// The micro version number of the GLib library.
        /// </summary>
        /// <remarks>
        /// Like #gtk_micro_version, but from the headers used at
        /// application compile time, rather than from the library
        /// linked against at application run time.
        /// </remarks>
        public const System.Int32 Micro = 1;

        /// <summary>
        /// The minor version number of the GLib library.
        /// </summary>
        /// <remarks>
        /// Like #gtk_minor_version, but from the headers used at
        /// application compile time, rather than from the library
        /// linked against at application run time.
        /// </remarks>
        public const System.Int32 Minor = 42;

        /// <summary>
        /// A macro that should be defined by the user prior to including
        /// the glib.h header.
        /// The definition should be one of the predefined GLib version
        /// macros: %GLIB_VERSION_2_26, %GLIB_VERSION_2_28,...
        /// </summary>
        /// <remarks>
        /// This macro defines the earliest version of GLib that the package is
        /// required to be able to compile against.
        /// 
        /// If the compiler is configured to warn about the use of deprecated
        /// functions, then using functions that were deprecated in version
        /// %GLIB_VERSION_MIN_REQUIRED or earlier will cause warnings (but
        /// using functions deprecated in later releases will not).
        /// </remarks>
        [GISharp.Core.Since("2.32")]
        public const System.Int32 MinRequired = 2;

        /// <summary>
        /// Checks that the GLib library in use is compatible with the
        /// given version. Generally you would pass in the constants
        /// #GLIB_MAJOR_VERSION, #GLIB_MINOR_VERSION, #GLIB_MICRO_VERSION
        /// as the three arguments to this function; that produces
        /// a check that the library in use is compatible with
        /// the version of GLib the application or module was compiled
        /// against.
        /// </summary>
        /// <remarks>
        /// Compatibility is defined by two things: first the version
        /// of the running library is newer than the version
        /// @required_major.required_minor.@required_micro. Second
        /// the running library must be binary compatible with the
        /// version @required_major.required_minor.@required_micro
        /// (same major version.)
        /// </remarks>
        /// <param name="requiredMajor">
        /// the required major version
        /// </param>
        /// <param name="requiredMinor">
        /// the required minor version
        /// </param>
        /// <param name="requiredMicro">
        /// the required micro version
        /// </param>
        /// <returns>
        /// %NULL if the GLib library is compatible with the
        ///     given version, or a string describing the version mismatch.
        ///     The returned string is owned by GLib and must not be modified
        ///     or freed.
        /// </returns>
        [System.Runtime.InteropServices.DllImport("glib-2.0.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [GISharp.Core.Since("2.6")]
        static extern System.IntPtr glib_check_version(
            [System.Runtime.InteropServices.In()] System.UInt32 requiredMajor,
            [System.Runtime.InteropServices.In()] System.UInt32 requiredMinor,
            [System.Runtime.InteropServices.In()] System.UInt32 requiredMicro);

        /// <summary>
        /// Checks that the GLib library in use is compatible with the
        /// given version. Generally you would pass in the constants
        /// #GLIB_MAJOR_VERSION, #GLIB_MINOR_VERSION, #GLIB_MICRO_VERSION
        /// as the three arguments to this function; that produces
        /// a check that the library in use is compatible with
        /// the version of GLib the application or module was compiled
        /// against.
        /// </summary>
        /// <remarks>
        /// Compatibility is defined by two things: first the version
        /// of the running library is newer than the version
        /// @required_major.required_minor.@required_micro. Second
        /// the running library must be binary compatible with the
        /// version @required_major.required_minor.@required_micro
        /// (same major version.)
        /// </remarks>
        /// <param name="requiredMajor">
        /// the required major version
        /// </param>
        /// <param name="requiredMinor">
        /// the required minor version
        /// </param>
        /// <param name="requiredMicro">
        /// the required micro version
        /// </param>
        /// <returns>
        /// %NULL if the GLib library is compatible with the
        ///     given version, or a string describing the version mismatch.
        ///     The returned string is owned by GLib and must not be modified
        ///     or freed.
        /// </returns>
        [GISharp.Core.Since("2.6")]
        public static System.String Check(
            System.UInt32 requiredMajor,
            System.UInt32 requiredMinor,
            System.UInt32 requiredMicro)
        {
            return default(System.String);
        }
    }
}